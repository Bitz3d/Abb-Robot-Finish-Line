MODULE GrpBase(SYSMODULE,NOSTEPIN)
!**************************************
!* This module is for gripper control *
!**************************************

RECORD grp_config
 string HdlLabel;
 num HdlNumber;
 string ActLabel;  
 num ActNumber;
 string ValveLabel;  
 string ValveOutputPos1;  
 string ValveOutputPos2;
 bool ValveTypStatic;
 num PulseTimeOffsetPos1;
 num PulseTimeOffsetPos2;
 string Cyl01Label;
 string Cyl01InputPos1Label;
 string Cyl01InputPos2Label;
 string Cyl01InputPos1;
 string Cyl01InputPos2;
 string Cyl02Label;
 string Cyl02InputPos1Label;
 string Cyl02InputPos2Label;
 string Cyl02InputPos1;
 string Cyl02InputPos2;
 string Cyl03Label;
 string Cyl03InputPos1Label;
 string Cyl03InputPos2Label;
 string Cyl03InputPos1;
 string Cyl03InputPos2;
 string Cyl04Label;
 string Cyl04InputPos1Label;
 string Cyl04InputPos2Label;
 string Cyl04InputPos1;
 string Cyl04InputPos2;
 string Cyl05Label;
 string Cyl05InputPos1Label;
 string Cyl05InputPos2Label;
 string Cyl05InputPos1;
 string Cyl05InputPos2;
 string Cyl06Label;
 string Cyl06InputPos1Label;
 string Cyl06InputPos2Label;
 string Cyl06InputPos1;
 string Cyl06InputPos2;
 string Cyl07Label;
 string Cyl07InputPos1Label;
 string Cyl07InputPos2Label;
 string Cyl07InputPos1;
 string Cyl07InputPos2;
 string Cyl08Label;
 string Cyl08InputPos1Label;
 string Cyl08InputPos2Label;
 string Cyl08InputPos1;
 string Cyl08InputPos2;
 num MaxCheckTime;
 string AirpressInputLabel;
 string AirpressInput;
 string VacuumOutputUS2Label;
 string VacuumOutputUS2;
 string VacuumInputBLabel;
 string VacuumInputB;
ENDRECORD

RECORD grp_pos
	num  pos_value;
ENDRECORD

RECORD grp_part
 string HdlLabel;  
 num HdlNumber;
 string PartLabel;
 num PartCtrlNumber;
 string PartCtrlInputLabel;  
 string PartCtrlInput;  
ENDRECORD

! 2010.11.09  / ABB Robert Goebelt  / BMW Philip Parsons
! 2012.07.16  / ABB Robert Goebelt
! 2012.08.22  / ABB Robert Goebelt
! 2013.02.25	/	ABB Robert Goebelt
! 2013.03.01  / ABB Robert Goebelt  / BMW Philip Parsons
! 2013.04.26  / ABB Robert Goebelt / BMW Philip Parsons !640
CONST string st_Version_GrpBase:="6.4.2 GrpBase";
!
CONST grp_pos Pos_1:=[1];
CONST grp_pos Pos_2:=[2];
!
CONST num n_MaxRob:=4;
!L7 = n_MaxHdl:=7;
CONST num n_MaxHdl:=7;
! n_MaxHdl:=15;
CONST num n_MaxAct:=99;
CONST num n_MaxPp:=32;
!
!st_PpNameC{n_GrpLang}
CONST string st_HandlingName{3}:=["Hdl_","Hdl_","Hdl_"];
CONST string st_ActuatorName{3}:=["Grp_","StG_","StG_"];
!Germany="StG_11"  England="Grp_11"
CONST string st_PpNameA:="GR";
CONST string st_PpNameB:="_B";
CONST string st_PpNameC{3}:=["PP","TK","TK"];
!Germany="GR01_B01TK"  England="GR01_B01PP"
CONST string st_PLC_do:="PLC_do_GRPartCtrl_";
CONST string st_PLC_di_NoPart:="PLC_di_NoPart";
!
LOCAL CONST num n_ValvePulsTime:=0.3;
!
VAR string st_VarAliasDi;
VAR string st_VarAliasDo;
VAR signaldi diGrp;
VAR signaldo doGrp;
!
PERS bool b_HdlOnRob{n_MaxRob,n_MaxHdl};
!
!640
!TASK PERS num n_GrpPosSoll{100}:=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
!640
LOCAL VAR bool b_DatExists:=FALSE;
!640
LOCAL VAR string st_GrpHeader{3};
LOCAL VAR string st_GrpLine1{3};
LOCAL VAR string st_GrpLine2{3};
LOCAL VAR string st_GrpLine3{3};
LOCAL VAR string st_GrpLine4{3};
LOCAL VAR string st_GrpLine5{3};
LOCAL VAR string st_GrpLines{5};
!640

!*******************************************************************************


PROC GrpSet(grp_pos pos,grp_config Grp1\grp_config Grp2\grp_config Grp3\grp_config Grp4\grp_config Grp5\ PERS loaddata PartLoad| switch noGripChk)
!*******************************************
!* Procedure for operating gripper outputs *
!*******************************************

VAR num n_PulsTime;
VAR bool b_Return:=FALSE;
VAR bool b_NoPart:=FALSE;
VAR bool b_Present_Grp{5};
VAR string st_ArgGrpName;
VAR string st_ArgGrpPosName;
VAR string st_HdlLabel;
VAR string st_ActLabel;
VAR string st_ActName;
VAR num n_HdlNum;
VAR num n_ActNum;
VAR string st_UnitLabel;
VAR string st_InputLabel;
VAR string st_GrpBoxLine1;
VAR string st_GrpBoxLine2;
VAR num n_Gripper_Nr:=0 ;
VAR num n_Cylinder_Nr:=0 ;
VAR grp_config Temp_GRP ;
VAR String st_cyl_Label ;
VAR String st_cyl_InputPos1Label ;
VAR String st_cyl_InputPos2Label ;
VAR String st_cyl_InputPos1 ;
VAR String st_cyl_InputPos2 ;

!Warten bis Roboter steht (auser Task oder während der Bewegung öffnen/schliessen
!Wait until robot (auser task is open or during the movement / Close!

IF TaskRunMec( ) THEN
	!Check if task controls any mechanical units and robot stopped
	IF NOT Present(noGripChk) AND TaskRunMec( ) WaitTime \InPos,0.1;
ENDIF

n_Step:=30;
st_VarAliasDi:=st_PLC_di_NoPart;
AliasIO st_VarAliasDi, diGrp;
IF diGrp =1 b_NoPart:=TRUE;

st_ArgGrpPosName:=ArgName(Pos);
FOR n_Gripper_Nr FROM 1 TO 5 DO
	!b_Present_Grp{n_Gripper_Nr}:=FALSE ;

	TEST n_Gripper_Nr
	CASE 1:
		Temp_GRP:=GRP1;
		st_ArgGrpName:=ArgName(GRP1);
		b_Present_Grp{1}:=TRUE;
	CASE 2:
		IF Present(GRP2)Then
			Temp_GRP:=GRP2;
		 st_ArgGrpName:=ArgName(GRP2);
			b_Present_Grp{2}:=TRUE;
		ENDIF
	CASE 3:
		IF Present(GRP3)Then
			Temp_GRP:=GRP3;
		 st_ArgGrpName:=ArgName(GRP3);
			b_Present_Grp{3}:=TRUE;
		ENDIF
	CASE 4:
		IF Present(GRP4)Then
			Temp_GRP:=GRP4;
		 st_ArgGrpName:=ArgName(GRP4);
			b_Present_Grp{4}:=TRUE;
		ENDIF
	CASE 5:
		IF Present(GRP5)Then
			Temp_GRP:=GRP5;
		 st_ArgGrpName:=ArgName(GRP5);
			b_Present_Grp{5}:=TRUE;
		ENDIF
	ENDTEST	
			
	IF b_Present_Grp{n_Gripper_Nr} THEN
		st_HdlLabel:=Temp_GRP.HdlLabel;
		st_ActLabel:=Temp_GRP.ActLabel;
		n_HdlNum:=Temp_GRP.HdlNumber;
		n_ActNum:=Temp_GRP.ActNumber;
		st_ActName:=st_ActuatorName{n_GrpLang}+NumToStr (n_ActNum,0);
		
		IF Temp_GRP.AirpressInput <> stEmpty THEN
			n_Step:=9;
			st_InputLabel:=Temp_GRP.AirpressInputLabel;
			st_VarAliasDi:=Temp_GRP.AirpressInput;
			AliasIO st_VarAliasDi, diGrp;
		
			WaitDI diGrp ,1\MaxTime:=2;
			!***************************************
			!* Waiting for Gripper Pressure Switch *
			!***************************************
		
			IF b_Return RETURN;
		ENDIF

 IF Temp_GRP.VacuumOutputUS2 <> stEmpty  THEN
	 n_Step:=5;
	 st_VarAliasDo:=Temp_GRP.VacuumOutputUS2;
	 AliasIO st_VarAliasDo, doGrp;
	 Set doGrp;
 ENDIF	

		IF pos.pos_value=1 THEN
			IF Temp_GRP.ValveOutputPos2 <> stEmpty  THEN
				n_Step:=2;
				st_VarAliasDo:=Temp_GRP.ValveOutputPos2;
				AliasIO st_VarAliasDo, doGrp;
				Reset doGrp;
			ENDIF	
		
			IF Temp_GRP.ValveOutputPos1 <> stEmpty  THEN
				n_Step:=1;
				st_VarAliasDo:=Temp_GRP.ValveOutputPos1;
				AliasIO st_VarAliasDo, doGrp;
			
				IF Temp_GRP.ValveTypStatic=TRUE THEN
					Set doGrp;
				ELSE
					n_PulsTime:=n_ValvePulsTime+Temp_GRP.PulseTimeOffsetPos1;
					PulseDO \High\PLength:=n_PulsTime, doGrp;
				ENDIF
			ELSE
				CallByVar "GrpSet_"+st_ActName+"_Pos_", pos.pos_value;
			ENDIF
		! 
		ELSEIF pos.pos_value=2 THEN
			!
			IF Temp_GRP.ValveOutputPos1 <> stEmpty  THEN
				n_Step:=1;
				st_VarAliasDo:=Temp_GRP.ValveOutputPos1;
				AliasIO st_VarAliasDo, doGrp;
				Reset doGrp;
			ENDIF	
			
			IF Temp_GRP.ValveOutputPos2 <> stEmpty  THEN

				n_Step:=2;
				st_VarAliasDo:=Temp_GRP.ValveOutputPos2;
				AliasIO st_VarAliasDo, doGrp;
				
				IF Temp_GRP.VacuumInputB <> stEmpty AND b_NoPart=TRUE GOTO nextGrp;
				IF Temp_GRP.ValveTypStatic=TRUE THEN
					Set doGrp;
				ELSE
					n_PulsTime:=n_ValvePulsTime+Temp_GRP.PulseTimeOffsetPos2;
					PulseDO \High\PLength:=n_PulsTime, doGrp;
				ENDIF
				nextGrp:
			ELSE
				CallByVar "GrpSet_"+st_ActName+"_Pos_", pos.pos_value;
			ENDIF 
		ELSE !pos.pos_value
			!Wenn Position >2/When position >2
			CallByVar "GrpSet_"+st_ActName+"_Pos_", pos.pos_value;   
		ENDIF !pos.pos_value
		!640
		!IF TaskRunMec( ) n_GrpPosSoll{Temp_GRP.ActNumber}:=pos.pos_value;
		!640
	ENDIF !b_Present_Grp
ENDFOR


!********************************

IF Present(noGripChk) RETURN;

FOR n_Gripper_Nr FROM 1 TO 5 DO

	TEST n_Gripper_Nr
	CASE 1:
		IF b_Present_Grp{1}Then
			Temp_GRP:=GRP1;
		 st_ArgGrpName:=ArgName(GRP1);
		ENDIF
	CASE 2:
		IF b_Present_Grp{2}Then
			Temp_GRP:=GRP2;
		 st_ArgGrpName:=ArgName(GRP2);
		ENDIF
	CASE 3:
		IF b_Present_Grp{3}Then
			Temp_GRP:=GRP3;
		 st_ArgGrpName:=ArgName(GRP3);
		ENDIF
	CASE 4:
		IF b_Present_Grp{4}Then
			Temp_GRP:=GRP4;
		 st_ArgGrpName:=ArgName(GRP4);
		ENDIF
	CASE 5:
		IF b_Present_Grp{5}Then
			Temp_GRP:=GRP5;
		 st_ArgGrpName:=ArgName(GRP5);
		ENDIF
	ENDTEST	

	IF b_Present_Grp{n_Gripper_Nr} THEN
	
		!Grp. Überwachung/Monitoring
		
		st_HdlLabel:=Temp_GRP.HdlLabel;
		st_ActLabel:=Temp_GRP.ActLabel;
		n_HdlNum:=Temp_GRP.HdlNumber;
		n_ActNum:=Temp_GRP.ActNumber;
		st_ActName:=st_ActuatorName{n_GrpLang}+NumToStr (n_ActNum,0);
	
		FOR n_Cylinder_Nr FROM 1 TO 8 DO
			TEST n_Cylinder_Nr
			
			CASE 1:
				st_cyl_Label:=temp_GRP.Cyl01Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl01InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl01InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl01InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl01InputPos2;
			CASE 2:
				st_cyl_Label:=temp_GRP.Cyl02Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl02InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl02InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl02InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl02InputPos2;
			CASE 3:
				st_cyl_Label:=temp_GRP.Cyl03Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl03InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl03InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl03InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl03InputPos2;
			CASE 4:
				st_cyl_Label:=temp_GRP.Cyl04Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl04InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl04InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl04InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl04InputPos2;
			CASE 5:
				st_cyl_Label:=temp_GRP.Cyl05Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl05InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl05InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl05InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl05InputPos2;
			CASE 6:
				st_cyl_Label:=temp_GRP.Cyl06Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl06InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl06InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl06InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl06InputPos2;
			CASE 7:
				st_cyl_Label:=temp_GRP.Cyl07Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl07InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl07InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl07InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl07InputPos2;
			CASE 8:
				st_cyl_Label:=temp_GRP.Cyl08Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl08InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl08InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl08InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl08InputPos2;
			ENDTEST			
			
			IF pos.pos_value=1 THEN
				!Sauger\Vacuum
		
				IF Temp_GRP.VacuumInputB <> stEmpty THEN
					n_Step:=10;
					st_UnitLabel:="";
					st_InputLabel:=Temp_GRP.VacuumInputBLabel;
					st_VarAliasDi:=Temp_GRP.VacuumInputB;
					AliasIO st_VarAliasDi, diGrp;
				
					WaitDI diGrp ,0\MaxTime:=Temp_GRP.MaxCheckTime;
					!**************************************************
					!* Waiting for Gripper Vauccum switch input B off *
					!**************************************************
					
					IF b_Return RETURN;
				ELSE !Temp_GRP.VacuumInputB <> stEmpty
		
					!Zylinder Vor = 0 /Cylinder adv/forward=0 
					IF st_cyl_InputPos2 <> stEmpty THEN				
						n_Step:=20 + n_Cylinder_Nr;
						st_UnitLabel:=st_cyl_Label;
						st_InputLabel:=st_cyl_InputPos2Label;
						st_VarAliasDi:=st_cyl_InputPos2;
						AliasIO st_VarAliasDi, diGrp;
						WaitDI diGrp ,0\MaxTime:=temp_GRP.MaxCheckTime;
						!**************************************************
						!* Waiting for Gripper Cylinder 2nd Pos input off *
						!**************************************************
			
						IF b_Return RETURN;
					ENDIF
					
					!Zylinder Vor = 1/Cylinder Advance/Forward=1
					
					IF st_cyl_InputPos1 <> stEmpty THEN
						n_Step:=10 + n_Cylinder_Nr;
						st_UnitLabel:=st_cyl_Label;
						st_InputLabel:=st_cyl_InputPos1Label;
						st_VarAliasDi:=st_cyl_InputPos1;
						AliasIO st_VarAliasDi, diGrp;
				
						WaitDI diGrp ,1\MaxTime:=Temp_Grp.MaxCheckTime;
						!*************************************************
						!* Waiting for Gripper Cylinder 1st Pos input on *
						!*************************************************
			
						IF b_Return RETURN;
					ENDIF
				ENDIF !temp_Grp.VacuumInputB <> stEmpty
			ELSEIF pos.pos_value=2 THEN
				!
				!Sauger\Vacuum
				!
				IF Temp_GRP.VacuumInputB <> stEmpty THEN
					IF  b_NoPart=FALSE THEN
					n_Step:=20;
					st_UnitLabel:="";
					st_InputLabel:=Temp_GRP.VacuumInputBLabel;
					st_VarAliasDi:=Temp_GRP.VacuumInputB;
					AliasIO st_VarAliasDi, diGrp;
					
					WaitDI diGrp ,1\MaxTime:=Temp_GRP.MaxCheckTime;
					!*************************************************
					!* Waiting for Gripper Vauccum Switch input B on *
					!*************************************************
				
					IF b_Return RETURN;
				 ELSE
				 	WaitTime 0.2;
				 ENDIF
				ELSE !Temp_Grp.VacuumInputB <> stEmpty
		
					!Zylinder Rück = 0\Cylinder Retract\Back=0
					
					IF st_cyl_InputPos1 <> stEmpty THEN				
						n_Step:=10 + n_Cylinder_Nr;
						st_UnitLabel:=st_cyl_Label;
						st_InputLabel:=st_cyl_InputPos1Label;
						st_VarAliasDi:=st_cyl_InputPos1;
						AliasIO st_VarAliasDi, diGrp;
						
						WaitDI diGrp ,0\MaxTime:=temp_GRP.MaxCheckTime;
						!**************************************************
						!* Waiting for Gripper Cylinder ist Pos input off *
						!**************************************************
			
						IF b_Return RETURN;
					ENDIF
					
					!Zylinder Vor = 1/Cylinder Advance/Forward=1
					
					IF st_cyl_InputPos2 <> stEmpty THEN
						n_Step:=20 + n_Cylinder_Nr;
						st_UnitLabel:=st_cyl_Label;
						st_InputLabel:=st_cyl_InputPos2Label;
						st_VarAliasDi:=st_cyl_InputPos2;
						AliasIO st_VarAliasDi, diGrp;
				
						WaitDI diGrp ,1\MaxTime:=Temp_Grp.MaxCheckTime;
						!*************************************************
						!* Waiting for Gripper Cylinder 2nd Pos input on *
						!*************************************************
			
						IF b_Return RETURN;
					ENDIF
						
				ENDIF !Temp_Grp.VacuumInputB <> stEmpty
			!ELSE !pos.pos_value
				!Wenn Position 3
				! RETURN;
			ENDIF !pos.pos_value
		ENDFOR !n_Cylinder_Nr
	ENDIF !b_Present_Grp
ENDFOR !n_Gripper_Nr

!Set robot load data run without part selected
IF Present(PartLoad) THEN
	n_Step:=30;
 st_VarAliasDi:=st_PLC_di_NoPart;
 AliasIO st_VarAliasDi, diGrp;
 IF diGrp =0 GripLoad PartLoad;
ENDIF

ERROR
!** Error Handler **

st_MsgBoxElogLine4:="Grp_Base/GrpSet";
!
TEST  ERRNO
	
CASE ERR_NORUNUNIT:
	
	st_MsgBoxHeader:=["No contact with IO unit ","Kein Kontakt zu EA Einheit ","???"];
	st_MsgBoxLine3:=["Check Wire break ","Überprüfe Drahtbruch ","???"];
	st_MsgBoxLine4:=["Check other error messages in the log","Überprüfe andere Fehlermeldungen im Log","???"];
	
	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
		n_MsgBoxPLC_Error:=154;
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	st_GrpBoxLine1:=st_ArgGrpName;
	st_GrpBoxLine2:=" ";
	MsgBox \diBreakSignal:=SYS_di_ErrReset\Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2\ErrorToPLC;
	
	TEST n_MsgBoxAnswer
		CASE 0:
			RETRY;
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST
	
CASE ERR_ARGVALERR:

	!Number < 0 oder keine Ganzzahl\Incorrect value <-8388607 or >8388607
	st_MsgBoxHeader:=["Error Position "+st_ArgGrpName,"Fehler Position "+st_ArgGrpName,"???"+st_ArgGrpName];
	st_MsgBoxLine3:=["Incorrect Value Configured ","positions Wert < 0 oder keine Ganzzahl","???"];
	st_MsgBoxLine4:=["Check System Configuration","Überprüfe Konfiguration","???"];
	
	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	st_GrpBoxLine1:="Datentyp grp_pos / num  pos_value = "+NumToStr (pos.pos_value,0);
	st_GrpBoxLine2:=st_ArgGrpPosName;
	MsgBox \Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2;
	
	TEST n_MsgBoxAnswer
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST

CASE ERR_REFUNKPRC :
	st_MsgBoxHeader:=["Error ProcCall GrpSet","Fehler Routinen Aufruf GrpSet","???"];
	st_MsgBoxLine3:=["Routine is not available","Routine ist nicht vorhanden!","???"];
	st_MsgBoxLine4:=["Check Modul Grp_Spec","Überprüfe Modul Grp_Spec","???"];
	
	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	st_GrpBoxLine1:="GrpSet_"+st_ActName+"_Pos_"+NumToStr (pos.pos_value,0);
	st_GrpBoxLine2:=st_ArgGrpPosName;
	MsgBox \Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2;
	
	TEST n_MsgBoxAnswer
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST

CASE ERR_ALIASIO_DEF,ERR_ALIASIO_TYPE:
	st_MsgBoxHeader:=["Configuration Error "+st_ArgGrpName,"Fehler Konfiguration "+st_ArgGrpName,"???"];
	st_MsgBoxLine3:=["IO signal is missing or incorrectly defined","IO Signal ist nicht vorhanden oder Falsch definiert","???"];
	st_MsgBoxLine4:=["Check Configuration","Überprüfe Konfiguration","???"];

	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	TEST n_Step
	CASE 1:
		st_GrpBoxLine1:="Datentyp grp_config / string ValveOutputPos1 = "+st_VarAliasDo;
		st_GrpBoxLine2:=st_VarAliasDo;
	CASE 2:
		st_GrpBoxLine1:="Datentyp grp_config / string ValveOutputPos2 = "+st_VarAliasDo;
		st_GrpBoxLine2:=st_VarAliasDo;
	CASE 5:
		st_GrpBoxLine1:="Datentyp grp_config / string VacuumOutputUS2 = "+st_VarAliasDo;
		st_GrpBoxLine2:=st_VarAliasDo;
	CASE 9:
		st_GrpBoxLine1:="Datentyp grp_config / string AirpressInput = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 10,20:
		st_GrpBoxLine1:="Datentyp grp_config / string VacuumInputB = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 11:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl01InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 12:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl02InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 13:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl03InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 14:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl04InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 15:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl05InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 16:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl06InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 17:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl07InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 18:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl08InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 21:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl01InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 22:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl02InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 23:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl03InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 24:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl04InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 25:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl05InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 26:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl06InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 27:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl07InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 28:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl08InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 30:
		st_MsgBoxHeader:=["Configuration Error GrpBase / IOcfg","Fehler Konfiguration GrpBase / IOcfg","???"];
		st_GrpBoxLine1:="st_PLC_di_NoPart = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	DEFAULT:
		ErrWrite "n_Step Case Err"," ";
		!n_SW_WO_Step Case Err";
		Stop;
	ENDTEST
	
	MsgBox \Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2;
	TEST n_MsgBoxAnswer
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST

CASE ERR_WAIT_MAXTIME :
	TEST n_Step
	CASE 9:
		st_MsgBoxHeader:=["Gripper Air Pressure Sensor:  "+st_InputLabel,"Warte auf Druckschalter:  "+st_InputLabel,"???"];
		st_MsgBoxSignal:=st_VarAliasDi;
		st_MsgBoxSignalValue:="1";
		st_GrpBoxLine2:=st_HandlingName{n_GrpLang}+NumToStr (n_HdlNum,0)+":  "+st_HdlLabel+" / "+st_ActuatorName{n_GrpLang}+NumToStr (n_ActNum,0)+":  "+st_ActLabel;
		st_MsgBoxLine3:=["Check Air Pressure or Sensor","Überprüfe Druckluft oder Druckschalter","???"];
		st_MsgBoxbutton4:=["Retry","Wiederhole","???"];
		IF TaskRunMec( )=FALSE st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
		IF TaskRunMec( ) n_MsgBoxPLC_Error:=150;
		!MsgBox \diBreakSignal:=SYS_di_ErrReset\Line2:=st_GrpBoxLine2\ErrorToPLC;
		!
    IF OpMode()=OP_AUTO THEN 
    	MsgBox \diBreakSignal:=SYS_di_ErrReset\Line2:=st_GrpBoxLine2\ErrorToPLC;
		  TEST n_MsgBoxAnswer
		   CASE 0,4:
			  RETRY;
		  ENDTEST
	  ELSE
	  	MsgBox \Line2:=st_GrpBoxLine2\ErrorToPLC;
		  TEST n_MsgBoxAnswer
		   CASE 4:
			   RETRY;
		   CASE 5:
			  b_Return:=TRUE;
			  TRYNEXT;
		  ENDTEST
    ENDIF
    !		
	CASE 10,20:
		st_MsgBoxHeader:=["Waiting for Vacuum Switch:  "+st_InputLabel,"Warte auf Vakuum:  "+st_InputLabel,"???"];
		st_MsgBoxSignal:=st_VarAliasDi;
		
		IF pos.pos_value=1 THEN
			st_MsgBoxSignalValue:="0";
			st_MsgBoxLine3:=["Sensor should be off","Unterdruck steht noch immer an","???"];
		ELSEIF pos.pos_value=2 THEN
			st_MsgBoxSignalValue:="1";
			st_MsgBoxLine3:=["Sensor should be on","Unterdruck nicht erreicht","???"];
		ENDIF
		
		st_GrpBoxLine2:=st_HandlingName{n_GrpLang}+NumToStr (n_HdlNum,0)+":  "+st_HdlLabel+" / "+st_ActuatorName{n_GrpLang}+NumToStr (n_ActNum,0)+":  "+st_ActLabel+" / "+st_UnitLabel;
		st_MsgBoxLine4:=["Check Suction or Vacuum Switch","Überprüfe Sauger oder der Vakuumschalter","???"];
		st_MsgBoxbutton4:=["Retry","Wiederhole","???"];
		
		IF TaskRunMec( )=FALSE THEN
			st_MsgBoxbutton1:=["Simulate","Einzeln Simulieren","???"];
			st_MsgBoxbutton2:=["Simulate All","Alle Simulieren","???"];
		ENDIF	
			
		IF TaskRunMec( ) n_MsgBoxPLC_Error:=151;
		
		SetGO PLC_go_GRNumber, n_HdlNum;
		SetGO PLC_go_GRActNumber, n_ActNum;
		SetGO PLC_go_GRActPos, pos.pos_value;
		Set PLC_do_GRActError;
		MsgBox \diBreakSignal:=SYS_di_ErrReset\Line2:=st_GrpBoxLine2\ErrorToPLC;
		Reset PLC_do_GRActError;
		
		TEST n_MsgBoxAnswer
		CASE 0,4:
			IF DOutput(doGrp) = 0 PulseDO \High\PLength:=n_PulsTime, doGrp;
			RETRY;
		CASE 1:
			TRYNEXT;
		CASE 2:
			b_Return:=TRUE;
			TRYNEXT;
		ENDTEST
	CASE 11,12,13,14,15,16,17,18:
		st_MsgBoxHeader:=["Waiting Gripper End Position:  "+st_InputLabel,"Warte auf Endlage:  "+st_InputLabel,"???"];
		st_MsgBoxSignal:=st_VarAliasDi;
		
		IF pos.pos_value=1 THEN
			st_MsgBoxSignalValue:="1";
			st_MsgBoxLine3:=["Cylinder Sensor should be on","Spanner hat Endlage nicht erreicht","???"];
		ELSEIF pos.pos_value=2 THEN
			st_MsgBoxSignalValue:="0";
			st_MsgBoxLine3:=["Cylinder Sensor should be off","Spanner ist nicht gefahren","???"];
		ENDIF 
		
		st_GrpBoxLine2:=st_HandlingName{n_GrpLang}+NumToStr (n_HdlNum,0)+":  "+st_HdlLabel+" / "+st_ActuatorName{n_GrpLang}+NumToStr (n_ActNum,0)+":  "+st_ActLabel+" / "+st_UnitLabel;
		st_MsgBoxLine4:=["Check if Cylinder Stuck or Faulty Sensor","Überprüfe ob der Spanner klemmt oder der Initiator defekt ist","???"];
		st_MsgBoxbutton4:=["Retry","Wiederhole","???"];
		
		IF TaskRunMec( )=FALSE THEN
			st_MsgBoxbutton1:=["Simulate","Einzeln Simulieren","???"];
			st_MsgBoxbutton2:=["Simulate All","Alle Simulieren","???"];
		ENDIF	
		
		IF TaskRunMec( ) n_MsgBoxPLC_Error:=152;
		SetGO PLC_go_GRNumber, n_HdlNum;
		SetGO PLC_go_GRActNumber, n_ActNum;
		SetGO PLC_go_GRActPos, pos.pos_value;
		Set PLC_do_GRActError;
		MsgBox \diBreakSignal:=SYS_di_ErrReset\Line2:=st_GrpBoxLine2\ErrorToPLC;
		Reset PLC_do_GRActError;
		
		TEST n_MsgBoxAnswer
		CASE 0,4:
			IF DOutput(doGrp) = 0 PulseDO \High\PLength:=n_PulsTime, doGrp;
			RETRY;
		CASE 1:
			TRYNEXT;
		CASE 2:
			b_Return:=TRUE;
			TRYNEXT;
		ENDTEST
	CASE 21,22,23,24,25,26,27,28:
		st_MsgBoxHeader:=["Waiting Gripper End Position:  "+st_InputLabel,"Warte auf Endlage:  "+st_InputLabel,"???"];
		st_MsgBoxSignal:=st_VarAliasDi;
		
		IF pos.pos_value=2 THEN
			st_MsgBoxSignalValue:="1";
			st_MsgBoxLine3:=["Cylinder Sensor should be on","Spanner hat Endlage nicht erreicht","???"];
		ELSEIF pos.pos_value=1 THEN
			st_MsgBoxSignalValue:="0";
			st_MsgBoxLine3:=["Cylinder Sensor should be off","Spanner ist nicht gefahren","???"];
		ENDIF 
		
		st_GrpBoxLine2:=st_HandlingName{n_GrpLang}+NumToStr (n_HdlNum,0)+":  "+st_HdlLabel+" / "+st_ActuatorName{n_GrpLang}+NumToStr (n_ActNum,0)+":  "+st_ActLabel+" / "+st_UnitLabel;
		st_MsgBoxLine4:=["Check if Cylinder Stuck or Faulty Sensor","Überprüfe ob der Spanner klemmt oder der Initiator defekt ist","???"];
		st_MsgBoxbutton4:=["Retry","Wiederhole","???"];
		
		IF TaskRunMec( )=FALSE THEN
			st_MsgBoxbutton1:=["Simulate","Einzeln Simulieren","???"];
			st_MsgBoxbutton2:=["Simulate All","Alle Simulieren","???"];
		ENDIF	
		
		IF TaskRunMec( ) n_MsgBoxPLC_Error:=152;
		SetGO PLC_go_GRNumber, n_HdlNum;
		SetGO PLC_go_GRActNumber, n_ActNum;
		SetGO PLC_go_GRActPos, pos.pos_value;
		Set PLC_do_GRActError;
		MsgBox \diBreakSignal:=SYS_di_ErrReset\Line2:=st_GrpBoxLine2\ErrorToPLC;
		Reset PLC_do_GRActError;
		
		TEST n_MsgBoxAnswer
		CASE 0,4:
			IF DOutput(doGrp) = 0 PulseDO \High\PLength:=n_PulsTime, doGrp;
			RETRY;
		CASE 1:
			TRYNEXT;
		CASE 2:
			b_Return:=TRUE;
			TRYNEXT;
		ENDTEST
	DEFAULT:
		ErrWrite "n_Step Case Err"," ";
		!n_SW_WO_Step Case Err";
		Stop;
	ENDTEST
ENDTEST

ENDPROC !GrpSet

!*****************************************************************************************

PROC GrpChk(grp_pos pos, grp_config Grp1\ grp_config Grp2\ grp_config Grp3\	grp_config Grp4\ grp_config Grp5)
!*************************************
!* Procedure to Check Gripper Status * 
!*************************************

VAR num n_PulsTime;
VAR bool b_Return:=FALSE;
VAR bool b_NoPart:=FALSE;
VAR bool b_Present_Grp{5};
VAR string st_ArgGrpName;
VAR string st_ArgGrpPosName;
VAR string st_HdlLabel;
VAR string st_ActLabel;
VAR string st_ActName;
VAR num n_HdlNum;
VAR num n_ActNum;
VAR string st_UnitLabel;
VAR string st_InputLabel;
VAR string st_GrpBoxLine1;
VAR string st_GrpBoxLine2;
VAR grp_pos tempos;
VAR num n_Gripper_Nr:=0 ;
VAR num n_Cylinder_Nr:=0 ;
VAR grp_config Temp_GRP ;
VAR String st_cyl_Label ;
VAR String st_cyl_InputPos1Label ;
VAR String st_cyl_InputPos2Label ;
VAR String st_cyl_InputPos1 ;
VAR String st_cyl_InputPos2 ;

n_Step:=30;
st_VarAliasDi:=st_PLC_di_NoPart;
AliasIO st_VarAliasDi, diGrp;
IF diGrp =1 b_NoPart:=TRUE;

st_ArgGrpPosName:=ArgName(pos);		
FOR n_Gripper_Nr FROM 1 TO 5 DO
	
	TEST n_Gripper_Nr
	CASE 1:
		Temp_GRP:=GRP1;
		st_ArgGrpName:=ArgName(GRP1);
		b_Present_Grp{1}:=TRUE;
	CASE 2:
		IF Present(GRP2) THEN
			Temp_GRP:=GRP2;
		 st_ArgGrpName:=ArgName(GRP2);
			b_Present_Grp{2}:=TRUE;
		ENDIF
	CASE 3:
		IF Present(GRP3) THEN
			Temp_GRP:=GRP3;
		 st_ArgGrpName:=ArgName(GRP3);
			b_Present_Grp{3}:=TRUE;
		ENDIF
	CASE 4:
		IF Present(GRP4) THEN
			Temp_GRP:=GRP4;
		 st_ArgGrpName:=ArgName(GRP4);
			b_Present_Grp{4}:=TRUE;
		ENDIF
	CASE 5:
		IF Present(GRP5) THEN
			Temp_GRP:=GRP5;
		 st_ArgGrpName:=ArgName(GRP5);
			b_Present_Grp{5}:=TRUE;
		ENDIF
	ENDTEST	

	IF b_Present_Grp{n_Gripper_Nr} THEN
	
		!Grp. Überwachung/Monitoring
		
		st_HdlLabel:=Temp_GRP.HdlLabel;
		st_ActLabel:=Temp_GRP.ActLabel;
		n_HdlNum:=Temp_GRP.HdlNumber;
		n_ActNum:=Temp_GRP.ActNumber;
		st_ActName:=st_ActuatorName{n_GrpLang}+NumToStr (n_ActNum,0);
	
		FOR n_Cylinder_Nr FROM 1 TO 8 DO
			TEST n_Cylinder_Nr
			
			CASE 1:
				st_cyl_Label:=temp_GRP.Cyl01Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl01InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl01InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl01InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl01InputPos2;
			CASE 2:
				st_cyl_Label:=temp_GRP.Cyl02Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl02InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl02InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl02InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl02InputPos2;
			CASE 3:
				st_cyl_Label:=temp_GRP.Cyl03Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl03InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl03InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl03InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl03InputPos2;
			CASE 4:
				st_cyl_Label:=temp_GRP.Cyl04Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl04InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl04InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl04InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl04InputPos2;
			CASE 5:
				st_cyl_Label:=temp_GRP.Cyl05Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl05InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl05InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl05InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl05InputPos2;
			CASE 6:
				st_cyl_Label:=temp_GRP.Cyl06Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl06InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl06InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl06InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl06InputPos2;
			CASE 7:
				st_cyl_Label:=temp_GRP.Cyl07Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl07InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl07InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl07InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl07InputPos2;
			CASE 8:
				st_cyl_Label:=temp_GRP.Cyl08Label;
				st_cyl_InputPos1Label:=temp_GRP.Cyl08InputPos1Label;
				st_cyl_InputPos2Label:=temp_GRP.Cyl08InputPos2Label;
				st_cyl_InputPos1:=temp_GRP.Cyl08InputPos1;
				st_cyl_InputPos2:=temp_GRP.Cyl08InputPos2;
			ENDTEST			
		
			!Grp. Druckluft Überwachung/Monitoring
			
			IF Temp_GRP.AirpressInput <> stEmpty THEN
				n_Step:=9;
				st_InputLabel:=Temp_GRP.AirpressInputLabel;
				st_VarAliasDi:=Temp_GRP.AirpressInput;
				AliasIO st_VarAliasDi, diGrp;
			
				WaitDI diGrp ,1\MaxTime:=2;
				!***************************************
				!* Waiting for Gripper Pressure Switch *
				!***************************************
			
				IF b_Return RETURN;
			ENDIF

			IF pos.pos_value=1 THEN
				!Sauger\Vacuum
		
				IF Temp_GRP.VacuumInputB <> stEmpty THEN
					n_Step:=10;
					st_UnitLabel:="";
					st_InputLabel:=Temp_GRP.VacuumInputBLabel;
					st_VarAliasDi:=Temp_GRP.VacuumInputB;
					AliasIO st_VarAliasDi, diGrp;
				
					WaitDI diGrp ,0\MaxTime:=Temp_GRP.MaxCheckTime;
					!**************************************************
					!* Waiting for Gripper Vauccum switch input B off *
					!**************************************************
					
					IF b_Return RETURN;
				ELSE !Temp_GRP.VacuumInputB <> stEmpty
		
					!Zylinder Vor = 0 /Cylinder adv/forward=0 
					IF st_cyl_InputPos2 <> stEmpty THEN				
						n_Step:=20 + n_Cylinder_Nr;
						st_UnitLabel:=st_cyl_Label;
						st_InputLabel:=st_cyl_InputPos2Label;
						st_VarAliasDi:=st_cyl_InputPos2;
						AliasIO st_VarAliasDi, diGrp;
						WaitDI diGrp ,0\MaxTime:=temp_GRP.MaxCheckTime;
						!**************************************************
						!* Waiting for Gripper Cylinder 2nd Pos input off *
						!**************************************************
			
						IF b_Return RETURN;
					ENDIF
					
					!Zylinder Vor = 1/Cylinder Advance/Forward=1
					
					IF st_cyl_InputPos1 <> stEmpty THEN
						n_Step:=10 + n_Cylinder_Nr;
						st_UnitLabel:=st_cyl_Label;
						st_InputLabel:=st_cyl_InputPos1Label;
						st_VarAliasDi:=st_cyl_InputPos1;
						AliasIO st_VarAliasDi, diGrp;
				
						WaitDI diGrp ,1\MaxTime:=Temp_Grp.MaxCheckTime;
						!*************************************************
						!* Waiting for Gripper Cylinder 1st Pos input on *
						!*************************************************
			
						IF b_Return RETURN;
					ENDIF
				ENDIF !temp_Grp.VacuumInputB <> stEmpty
			ELSEIF pos.pos_value=2 THEN
				!
				!Sauger\Vacuum
				!
				IF Temp_GRP.VacuumInputB <> stEmpty THEN
					IF  b_NoPart=FALSE THEN
					n_Step:=20;
					st_UnitLabel:="";
					st_InputLabel:=Temp_GRP.VacuumInputBLabel;
					st_VarAliasDi:=Temp_GRP.VacuumInputB;
					AliasIO st_VarAliasDi, diGrp;
					
					WaitDI diGrp ,1\MaxTime:=Temp_GRP.MaxCheckTime;
					!*************************************************
					!* Waiting for Gripper Vauccum Switch input B on *
					!*************************************************
				
					IF b_Return RETURN;
				 ENDIF
				ELSE !Temp_Grp.VacuumInputB <> stEmpty
		
					!Zylinder Rück = 0\Cylinder Retract\Back=0
					
					IF st_cyl_InputPos1 <> stEmpty THEN				
						n_Step:=10 + n_Cylinder_Nr;
						st_UnitLabel:=st_cyl_Label;
						st_InputLabel:=st_cyl_InputPos1Label;
						st_VarAliasDi:=st_cyl_InputPos1;
						AliasIO st_VarAliasDi, diGrp;
						
						WaitDI diGrp ,0\MaxTime:=Temp_GRP.MaxCheckTime;
						!**************************************************
						!* Waiting for Gripper Cylinder ist Pos input off *
						!**************************************************
			
						IF b_Return RETURN;
					ENDIF
					
					!Zylinder Vor = 1/Cylinder Advance/Forward=1
					
					IF st_cyl_InputPos2 <> stEmpty THEN
						n_Step:=20 + n_Cylinder_Nr;
						st_UnitLabel:=st_cyl_Label;
						st_InputLabel:=st_cyl_InputPos2Label;
						st_VarAliasDi:=st_cyl_InputPos2;
						AliasIO st_VarAliasDi, diGrp;
				
						WaitDI diGrp ,1\MaxTime:=Temp_Grp.MaxCheckTime;
						!*************************************************
						!* Waiting for Gripper Cylinder 2nd Pos input on *
						!*************************************************
			
						IF b_Return RETURN;
					ENDIF
						
				ENDIF !Temp_Grp.VacuumInputB <> stEmpty
			ELSE !pos.pos_value
				!Wenn Position >2/When position >2
				CallByVar "GrpChk_"+st_ActName+"_Pos_", pos.pos_value;   
			ENDIF !pos.pos_value
		ENDFOR !n_Cylinder_Nr
	ENDIF !b_Present_Grp
ENDFOR !n_Gripper_Nr
!
ERROR
!** Error Handler **

st_MsgBoxElogLine4:="Grp_Base/Grpchk";
!
TEST ERRNO
	
	CASE ERR_NORUNUNIT:
	!640
	st_MsgBoxHeader:=["No contact with IO unit ","Kein Kontakt zu EA Einheit ","???"];
	st_MsgBoxLine3:=["Check Wire break ","Überprüfe Drahtbruch ","???"];
	st_MsgBoxLine4:=["Check other error messages in the log","Überprüfe andere Fehlermeldungen im Log","???"];
	
	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
		n_MsgBoxPLC_Error:=154;
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	st_GrpBoxLine1:=st_ArgGrpName;
	st_GrpBoxLine2:=" ";
	MsgBox \diBreakSignal:=SYS_di_ErrReset\Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2\ErrorToPLC;
	
	TEST n_MsgBoxAnswer
		CASE 0:
			RETRY;
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST
	!640
CASE ERR_ARGVALERR:
	!Number < 0 oder keine Ganzzahl
	st_MsgBoxHeader:=["Error position "+st_ArgGrpName,"Fehler Position "+st_ArgGrpName,"???"+st_ArgGrpName];
	st_MsgBoxLine3:=["Incorrect Value Configured ","positions Wert < 0 oder keine Ganzzahl","???"];
	st_MsgBoxLine4:=["Check System Configuration","Überprüfe Konfiguration","???"];

	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	st_GrpBoxLine1:="Datentyp grp_pos / num  pos_value = "+NumToStr (tempos.pos_value,0);
	st_GrpBoxLine2:=st_ArgGrpPosName;
	MsgBox \Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2;
	
	TEST n_MsgBoxAnswer
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST
CASE ERR_REFUNKPRC:
	st_MsgBoxHeader:=["Error ProcCall GrpSet","Fehler Routinen Aufruf GrpSet","???"];
	st_MsgBoxLine3:=["Routine is not available","Routine ist nicht vorhanden!","???"];
	st_MsgBoxLine4:=["check Modul Grp_Spec","Überprüfe Modul Grp_Spec","???"];

	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	st_GrpBoxLine1:="GrpSet_"+st_ActName+"_Pos_"+NumToStr (tempos.pos_value,0);
	st_GrpBoxLine2:=st_ArgGrpPosName;
	MsgBox \Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2;
	
	TEST n_MsgBoxAnswer
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST
CASE ERR_ALIASIO_DEF:
	st_MsgBoxHeader:=["Configuration Error "+st_ArgGrpName,"Fehler Konfiguration "+st_ArgGrpName,"???"];
	st_MsgBoxLine3:=["IO signal is missing or incorrectly defined","IO Signal ist nicht vorhanden oder Falsch geschrieben","???"];
	st_MsgBoxLine4:=["Check Configuration","Überprüfe Konfiguration","???"];

	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	TEST n_Step
	CASE 1:
		st_GrpBoxLine1:="Datentyp grp_config / string ValveOutputPos1 = "+st_VarAliasDo;
		st_GrpBoxLine2:=st_VarAliasDo;
	CASE 2:
		st_GrpBoxLine1:="Datentyp grp_config / string ValveOutputPos2 = "+st_VarAliasDo;
		st_GrpBoxLine2:=st_VarAliasDo;
	CASE 9:
		st_GrpBoxLine1:="Datentyp grp_config / string AirpressInput = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 10,20:
		st_GrpBoxLine1:="Datentyp grp_config / string VacuumInputB = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 11:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl01InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 12:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl02InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 13:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl03InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 14:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl04InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 15:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl05InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 16:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl06InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 17:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl07InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 18:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl08InputPos1 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 21:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl01InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 22:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl02InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 23:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl03InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 24:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl04InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 25:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl05InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 26:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl06InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 27:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl07InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 28:
		st_GrpBoxLine1:="Datentyp grp_config / string Cyl08InputPos2 = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 30:
		st_MsgBoxHeader:=["Configuration Error GrpBase / IOcfg","Fehler Konfiguration GrpBase / IOcfg","???"];
		st_GrpBoxLine1:="st_PLC_di_NoPart = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	DEFAULT:
		ErrWrite "n_Step Case Err"," ";
		!n_SW_WO_Step Case Err";
		Stop;
	ENDTEST
	
	MsgBox \Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2;
	
	TEST n_MsgBoxAnswer
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST
CASE ERR_WAIT_MAXTIME:
	TEST n_Step
	CASE 9:
		st_MsgBoxHeader:=["Gripper Air Pressure Sensor:  "+st_InputLabel,"Warte auf Druckschalter:  "+st_InputLabel,"???"];
		st_MsgBoxSignal:=st_VarAliasDi;
		st_MsgBoxSignalValue:="1";
		st_GrpBoxLine2:=st_HandlingName{n_GrpLang}+NumToStr (n_HdlNum,0)+":  "+st_HdlLabel+" / "+st_ActuatorName{n_GrpLang}+NumToStr (n_ActNum,0)+":  "+st_ActLabel;
		st_MsgBoxLine3:=["Check Air Pressure or Sensor","Überprüfe Druckluft oder Druckschalter","???"];
		st_MsgBoxbutton4:=["Retry","Wiederhole","???"];
		IF TaskRunMec( )=FALSE st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
		IF TaskRunMec( ) n_MsgBoxPLC_Error:=150;
		MsgBox \diBreakSignal:=SYS_di_ErrReset\Line2:=st_GrpBoxLine2\ErrorToPLC;

		TEST n_MsgBoxAnswer
		CASE 0,4:
			RETRY;
		CASE 5:
			b_Return:=TRUE;
			TRYNEXT;
		ENDTEST
	CASE 10,20:
		st_MsgBoxHeader:=["Waiting for Vacuum Switch:  "+st_InputLabel,"Warte auf Vakuum:  "+st_InputLabel,"???"];
		st_MsgBoxSignal:=st_VarAliasDi;

		IF tempos.pos_value=1 THEN
			st_MsgBoxSignalValue:="0";
			st_MsgBoxLine3:=["Sensor should be off","Unterdruck steht noch immer an","???"];
		ELSEIF tempos.pos_value=2 THEN
			st_MsgBoxSignalValue:="1";
			st_MsgBoxLine3:=["Sensor should be on","Unterdruck nicht erreicht","???"];
		ENDIF
		
		st_GrpBoxLine2:=st_HandlingName{n_GrpLang}+NumToStr (n_HdlNum,0)+":  "+st_HdlLabel+" / "+st_ActuatorName{n_GrpLang}+NumToStr (n_ActNum,0)+":  "+st_ActLabel+" / "+st_UnitLabel;
		st_MsgBoxLine4:=["Check Suction or Vacuum Switch","Überprüfe Sauger oder der Vakuumschalter","???"];
		st_MsgBoxbutton4:=["Retry","Wiederhole","???"];
		
		IF TaskRunMec( )=FALSE THEN
			st_MsgBoxbutton1:=["Simulate","Einzeln Simulieren","???"];
			st_MsgBoxbutton2:=["Simulate All","Alle Simulieren","???"];
		ENDIF	
		
		IF TaskRunMec( ) n_MsgBoxPLC_Error:=151;
		SetGO PLC_go_GRNumber, n_HdlNum;
		SetGO PLC_go_GRActNumber, n_ActNum;
		SetGO PLC_go_GRActPos, pos.pos_value;
		Set PLC_do_GRActError;
		MsgBox \diBreakSignal:=SYS_di_ErrReset\Line2:=st_GrpBoxLine2\ErrorToPLC;
		Reset PLC_do_GRActError;
		
		TEST n_MsgBoxAnswer
		CASE 0,4:
			RETRY;
		CASE 1:
			TRYNEXT;
		CASE 2:
			b_Return:=TRUE;
			TRYNEXT;
		ENDTEST
	CASE 11,12,13,14,15,16,17,18:
		st_MsgBoxHeader:=["Waiting Gripper End Position:  "+st_InputLabel,"Warte auf Endlage:  "+st_InputLabel,"???"];
		st_MsgBoxSignal:=st_VarAliasDi;
		
		IF tempos.pos_value=1 THEN
			st_MsgBoxSignalValue:="1";
			st_MsgBoxLine3:=["Cylinder Sensor should be on","Spanner hat Endlage nicht erreicht","???"];
		ELSEIF tempos.pos_value=2 THEN
			st_MsgBoxSignalValue:="0";
			st_MsgBoxLine3:=["Cylinder Sensor should be off","Spanner ist nicht gefahren","???"];
		ENDIF 
		
		st_GrpBoxLine2:=st_HandlingName{n_GrpLang}+NumToStr (n_HdlNum,0)+":  "+st_HdlLabel+" / "+st_ActuatorName{n_GrpLang}+NumToStr (n_ActNum,0)+":  "+st_ActLabel+" / "+st_UnitLabel;
		st_MsgBoxLine4:=["Check if Cylinder Stuck or Faulty Sensor","Überprüfe ob der Spanner klemmt oder der Initiator defekt ist","???"];
		st_MsgBoxbutton4:=["Retry","Wiederhole","???"];
		
		IF TaskRunMec( )=FALSE THEN
			st_MsgBoxbutton1:=["Simulate","Einzeln Simulieren","???"];
			st_MsgBoxbutton2:=["Simulate All","Alle Simulieren","???"];
		ENDIF	
		
		IF TaskRunMec( ) n_MsgBoxPLC_Error:=152;
		SetGO PLC_go_GRNumber, n_HdlNum;
		SetGO PLC_go_GRActNumber, n_ActNum;
		SetGO PLC_go_GRActPos, pos.pos_value;
		Set PLC_do_GRActError;
		MsgBox \diBreakSignal:=SYS_di_ErrReset\Line2:=st_GrpBoxLine2\ErrorToPLC;
		Reset PLC_do_GRActError;
		
		TEST n_MsgBoxAnswer
		CASE 0,4:
			RETRY;
		CASE 1:
			TRYNEXT;
		CASE 2:
			b_Return:=TRUE;
			TRYNEXT;
		ENDTEST
	CASE 21,22,23,24,25,26,27,28:
		st_MsgBoxHeader:=["Waiting Gripper End Position:  "+st_InputLabel,"Warte auf Endlage:  "+st_InputLabel,"???"];
		st_MsgBoxSignal:=st_VarAliasDi;

		IF tempos.pos_value=2 THEN
			st_MsgBoxSignalValue:="1";
			st_MsgBoxLine3:=["Cylinder Sensor should be on","Spanner hat Endlage nicht erreicht","???"];
		ELSEIF tempos.pos_value=1 THEN
			st_MsgBoxSignalValue:="0";
			st_MsgBoxLine3:=["Cylinder Sensor should be off","Spanner ist nicht gefahren","???"];
		ENDIF 
		
		st_GrpBoxLine2:=st_HandlingName{n_GrpLang}+NumToStr (n_HdlNum,0)+":  "+st_HdlLabel+" / "+st_ActuatorName{n_GrpLang}+NumToStr (n_ActNum,0)+":  "+st_ActLabel+" / "+st_UnitLabel;
		st_MsgBoxLine4:=["Check if Cylinder Stuck or Faulty Sensor","Überprüfe ob der Spanner klemmt oder der Initiator defekt ist","???"];
		st_MsgBoxbutton4:=["Retry","Wiederhole","???"];
		
		IF TaskRunMec( )=FALSE THEN
			st_MsgBoxbutton1:=["Simulate","Einzeln Simulieren","???"];
			st_MsgBoxbutton2:=["Simulate All","Alle Simulieren","???"];
		ENDIF	
		
		IF TaskRunMec( ) n_MsgBoxPLC_Error:=152;
		SetGO PLC_go_GRNumber, n_HdlNum;
		SetGO PLC_go_GRActNumber, n_ActNum;
		SetGO PLC_go_GRActPos, pos.pos_value;
		Set PLC_do_GRActError;
		MsgBox \diBreakSignal:=SYS_di_ErrReset\Line2:=st_GrpBoxLine2\ErrorToPLC;
		Reset PLC_do_GRActError;
		
		TEST n_MsgBoxAnswer
		CASE 0,4:
			RETRY;
		CASE 1:
			TRYNEXT;
		CASE 2:
			b_Return:=TRUE;
			TRYNEXT;
		ENDTEST
	DEFAULT:
		ErrWrite "n_Step Case Err"," ";
		!n_SW_WO_Step Case Err";
		Stop;
	ENDTEST
ENDTEST !ErrNo
ENDPROC !(GrpChk)

!*****************************************************************************************
!
PROC GrpPartChk(dionum Value, grp_part Part1\grp_part Part2\grp_part Part3\grp_part Part4\grp_part Part5)
!***********************************
!* Procedure to Check Part Control * 
!***********************************
VAR bool b_NoPart:=FALSE;
VAR bool b_Present_Part{5};
VAR string st_Temp_PartName{5};
VAR string st_ArgPartName;
VAR string st_ArgPartValue;
VAR string st_HdlLabel;
VAR string st_PartLabel;
VAR num n_HdlNum;
VAR num n_PpNum;
VAR string st_InputLabel;
VAR string st_GrpBoxLine1;
VAR string st_GrpBoxLine2;
VAR num n_Part_Nr ;
VAR grp_part Temp_Grp_Part;

n_Step:=10;
st_VarAliasDi:=st_PLC_di_NoPart;
AliasIO st_VarAliasDi, diGrp;
IF diGrp =1 RETURN;

st_ArgPartValue:=ArgName(Value);
n_Step:=1;

FOR n_Part_Nr from 1 to 5 DO
	
	TEST n_Part_Nr
	CASE 1 :
		Temp_Grp_Part:=Part1;
		st_ArgPartName:=ArgName(Part1);
		b_Present_Part{1}:=TRUE;
	CASE 2 :
		IF Present (Part2) THEN
			Temp_Grp_Part:=Part2;
		 st_ArgPartName:=ArgName(Part2);
			b_Present_Part{2}:=TRUE;
		ENDIF
	CASE 3 :
		IF Present (Part3) THEN
			Temp_Grp_Part:=Part3;
		 st_ArgPartName:=ArgName(Part3);
			b_Present_Part{3}:=TRUE;
		ENDIF
	CASE 4 :
		IF Present (Part4) THEN
			Temp_Grp_Part:=Part4;
		 st_ArgPartName:=ArgName(Part4);
			b_Present_Part{4}:=TRUE;
		ENDIF
	CASE 5 :
		IF Present (Part5) THEN
			Temp_Grp_Part:=Part5;
		 st_ArgPartName:=ArgName(Part5);
			b_Present_Part{5}:=TRUE;
		ENDIF
	ENDTEST	

	IF b_Present_Part{n_Part_Nr} THEN
		n_PpNum:=Temp_Grp_Part.PartCtrlNumber;
		n_HdlNum:=Temp_Grp_Part.HdlNumber;
	
		IF n_PpNum > 9 THEN
			st_VarAliasDo:=st_PLC_do+NumToStr(n_PpNum,0);
		ELSE
			st_VarAliasDo:=st_PLC_do+"0"+NumToStr(n_PpNum,0);
		ENDIF
		
		AliasIO st_VarAliasDo, doGrp;
		SetGO PLC_go_GRNumber, n_HdlNum;
		SetDO doGrp, Value;
	ENDIF
ENDFOR

FOR n_Part_Nr from 1 to 5 Do
	IF b_Present_Part{n_Part_Nr} THEN

		TEST n_Part_Nr
		CASE 1 :
			Temp_Grp_Part:=Part1;
		 st_ArgPartName:=ArgName(Part1);
		CASE 2 :
			Temp_Grp_Part:=Part2;
		 st_ArgPartName:=ArgName(Part2);
		CASE 3 :
			Temp_Grp_Part:=Part3;
		 st_ArgPartName:=ArgName(Part3);
		CASE 4 :
			Temp_Grp_Part:=Part4;
		 st_ArgPartName:=ArgName(Part4);
		CASE 5 :
			Temp_Grp_Part:=Part5;
		 st_ArgPartName:=ArgName(Part5);
		ENDTEST	

		st_HdlLabel:=Temp_Grp_Part.HdlLabel;
		st_PartLabel:=Temp_Grp_Part.PartLabel;
		n_HdlNum:=Temp_Grp_Part.HdlNumber;
		!
		n_Step:=2;
		st_InputLabel:=Temp_Grp_Part.PartCtrlInputLabel;
		st_VarAliasDi:=Temp_Grp_Part.PartCtrlInput;
		AliasIO st_VarAliasDi, diGrp;
		!
		n_Step:=3;
		WaitDI diGrp ,Value\MaxTime:=2;
		!****************************
		!* Waiting for Part Control *
		!****************************

	ENDIF !b_Present_Part{n_Part_Nr}
ENDFOR

ERROR
!** Error Handler **

SkipWarn;
st_MsgBoxElogLine4:="Grp_Base/GrpPartChk";

TEST ERRNO
	
CASE ERR_NORUNUNIT:
	!640
	st_MsgBoxHeader:=["No contact with IO unit ","Kein Kontakt zu EA Einheit ","???"];
	st_MsgBoxLine3:=["Check Wire break ","Überprüfe Drahtbruch ","???"];
	st_MsgBoxLine4:=["Check other error messages in the log","Überprüfe andere Fehlermeldungen im Log","???"];
	
	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
		n_MsgBoxPLC_Error:=154;
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	st_GrpBoxLine1:=st_ArgPartName;
	st_GrpBoxLine2:=" ";
	MsgBox \diBreakSignal:=SYS_di_ErrReset\Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2\ErrorToPLC;
	
	TEST n_MsgBoxAnswer
		CASE 0:
			RETRY;
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST
	!640	
CASE ERR_ARGNAME:
	IF Value=0 THEN
		st_ArgPartValue:="0";
	ELSEIF Value=1 THEN
		st_ArgPartValue:="1";
	ENDIF
	
	TRYNEXT;
CASE ERR_ALIASIO_DEF:
	st_MsgBoxHeader:=["Configuration Error "+st_ArgPartName,"Fehler Konfiguration "+st_ArgPartName,"???"+st_ArgPartName];
	st_MsgBoxLine3:=["IO signal is missing or incorrectly defined","IO Signal ist nicht vorhanden oder Falsch geschrieben","???"];
	st_MsgBoxLine4:=["Check Configuration","Überprüfe Konfiguration","???"];

	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	TEST n_Step
	CASE 1:
		st_MsgBoxHeader:=["Configuration Error "+st_ArgPartName,"Fehler Konfiguration "+st_ArgPartName,"???"+st_ArgPartName];
		st_GrpBoxLine1:="Datentyp grp_part / num PartCtrlNumber = "+NumToStr (n_PpNum,0);
		st_GrpBoxLine2:=st_VarAliasDo;
	CASE 2:
		st_MsgBoxHeader:=["Configuration Error "+st_ArgPartName,"Fehler Konfiguration "+st_ArgPartName,"???"+st_ArgPartName];
		st_GrpBoxLine1:="Datentyp grp_part / string PartCtrlInput = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	CASE 10:
		st_MsgBoxHeader:=["Configuration Error GrpBase / IOcfg","Fehler Konfiguration GrpBase / IOcfg","???"];
		st_GrpBoxLine1:="st_PLC_di_NoPart = "+st_VarAliasDi;
		st_GrpBoxLine2:=st_VarAliasDi;
	DEFAULT:
		ErrWrite "n_Step Case Err"," ";
		!n_SW_WO_Step Case Err";
		Stop;
	ENDTEST
	
	MsgBox \Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2;
	
	TEST n_MsgBoxAnswer
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST
CASE ERR_WAIT_MAXTIME:
	TEST n_Step
	CASE 3:
		st_MsgBoxHeader:=["Part Control Error:  "+st_InputLabel,"Warte auf Bauteilkontrolle:  "+st_InputLabel,"???"];
		st_MsgBoxSignal:=st_VarAliasDi;
		st_MsgBoxSignalValue:=st_ArgPartValue;
		st_GrpBoxLine2:=st_HandlingName{n_GrpLang}+NumToStr (n_HdlNum,0)+":  "+st_HdlLabel+" / "+st_ArgPartName+":  "+st_PartLabel;
		
		IF Value=0 THEN
			st_MsgBoxLine3:=["Sensor should be off","Bauteil sollte nicht vorhanden sein","???"];
		ELSEIF Value=1 THEN
			st_MsgBoxLine3:=["Sensor should be on","Bauteil sollte vorhanden sein","???"];
		ENDIF
		
		st_MsgBoxLine4:=["Check Part or Sensor","Überprüfe Initiator oder Bauteil","???"];
		st_MsgBoxbutton4:=["Retry","Wiederhole","???"];
		IF TaskRunMec( ) n_MsgBoxPLC_Error:=153;
		MsgBox \diBreakSignal:=SYS_di_ErrReset\Line2:=st_GrpBoxLine2\ErrorToPLC;
	
		TEST n_MsgBoxAnswer
		CASE 0,4:
			RETRY;
		ENDTEST
	DEFAULT:
		ErrWrite "n_Step Case Err"," ";
		!n_SW_WO_Step Case Err";
		Stop;
	ENDTEST
ENDTEST
ENDPROC !(GrpPartChk)


!*****************************************************************************************


PROC GrpPartPlcUpd(num HdlNumber)
!*************************************************************
!* Procedure to send Part Control status to PLC using handle * 
!*************************************************************
VAR string st_GrpBoxLine1;
VAR string st_GrpBoxLine2;
VAR grp_part GrpPartTemp;
VAR string st_PP_Name;
VAR num n_Pp;

 
IF HdlNumber=0 RETURN;
!
SetGO PLC_go_GRNumber, HdlNumber;
!
st_VarAliasDo:="";
FOR i FROM 1 TO n_MaxPp DO
	b_DatExists:=TRUE;
	!640
	n_Pp:=i;
	!IF i > 9 THEN
	!	st_PP_Name:=st_PpNameA + "0" + ValToStr(HdlNumber) + st_PpNameB + ValToStr(i)+ st_PpNameC{n_GrpLang};
	!	GetDataVal st_PpNameA + "0" + ValToStr(HdlNumber) + st_PpNameB + ValToStr(i)+ st_PpNameC{n_GrpLang},GrpPartTemp;
	!	
	!	IF b_DatExists THEN
	!		st_VarAliasDo:=st_PLC_do+NumToStr(GrpPartTemp.PartCtrlNumber,0);
	!	ENDIF
	!ELSE
	!	st_PP_Name:=st_PpNameA + "0" + ValToStr(HdlNumber) + st_PpNameB +"0"+ ValToStr(i)+ st_PpNameC{n_GrpLang};
	!	GetDataVal st_PpNameA + "0" + ValToStr(HdlNumber) + st_PpNameB +"0"+ ValToStr(i)+ st_PpNameC{n_GrpLang},GrpPartTemp;
	!	
	!	IF b_DatExists THEN
	!		st_VarAliasDo:=st_PLC_do+"0"+NumToStr(GrpPartTemp.PartCtrlNumber,0);
	!	ENDIF
	!ENDIF
	
 st_PP_Name:=st_PpNameA + NumToStrAddZero(HdlNumber) + st_PpNameB + NumToStrAddZero(n_Pp)+ st_PpNameC{n_GrpLang};
 GetDataVal st_PpNameA + NumToStrAddZero(HdlNumber) + st_PpNameB + NumToStrAddZero(n_Pp)+ st_PpNameC{n_GrpLang},GrpPartTemp;
 !	
 IF b_DatExists st_VarAliasDo:=st_PLC_do+NumToStrAddZero(GrpPartTemp.PartCtrlNumber);
 !640		

 IF st_VarAliasDo <> stEmpty THEN
	 AliasIO st_VarAliasDo, doGrp;
	 IF GrpPartRead(GrpPartTemp) THEN
		 Set doGrp;
	 ELSE
		 Reset doGrp;
	 ENDIF
 ENDIF
	
ENDFOR
!
ERROR
SkipWarn;
!
TEST ERRNO

CASE ERR_SYM_ACCESS:
	b_DatExists:=FALSE;
	TRYNEXT;
CASE ERR_ALIASIO_DEF,ERR_ALIASIO_TYPE:
	st_MsgBoxHeader:=["Configuration Error "+st_PP_Name,"Fehler Konfiguration "+st_PP_Name,"???"];
	st_MsgBoxLine3:=["IO signal is missing or incorrectly defined","IO Signal ist nicht vorhanden oder Falsch definiert","???"];
	st_MsgBoxLine4:=["Check Configuration","Überprüfe Konfiguration","???"];

	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	st_GrpBoxLine1:="Datentyp grp_part OR PLC Signal = "+st_VarAliasDo;
	st_GrpBoxLine2:=st_VarAliasDo;
	
	MsgBox \Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2;
	TPWrite st_PP_Name\Num:=n_Pp;

	Stop;
	TEST n_MsgBoxAnswer
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST
ENDTEST
!
ENDPROC !(GrpPartPlcUpd)

!640
PROC GripLoad_CTRL (\PERS loaddata Normal_Run,\PERS loaddata Dry_Run )
!************************************************
!*  Procedure to set the correct gripload data  *
!*   according to the operation of the machine  *
!************************************************

VAR string st_ArgGrpName;
VAR string st_GrpBoxLine1;
VAR string st_GrpBoxLine2;
 
!Stop Advance pointer
WaitTime \InPos,0;
 
! Check optional argument has been configured
IF Present (Normal_Run)<>TRUE RAISE 1;

 st_VarAliasDi:=st_PLC_di_NoPart;
 AliasIO st_VarAliasDi, diGrp;
 
!Check to dry run mode i.e No Parts
IF diGrp=1 THEN
	IF Present (Dry_Run) THEN
		GripLoad Dry_Run;
  ELSE
    GripLoad load0;
  ENDIF
ELSE
  GripLoad Normal_Run;
ENDIF
 
ERROR
!** Error Handler**
SkipWarn;

st_MsgBoxElogLine4:="Grp_Base/GripLoad_CTRL";

TEST ERRNO
CASE 1:
  WHILE TRUE DO
  	st_MsgBoxHeader:=["GripLoad_CTRL!! Optional Argument Error","GripLoad_CTRL!! Argument fehlt","???"];
    st_MsgBoxLine3:=["'Normal_Run' optional argument","'Normal_Run' optionale Argument","???"];
    st_MsgBoxLine4:=["must be configured.","konfiguriert werden muss.","???"];
    n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
    Stop;
  ENDWHILE
CASE ERR_NORUNUNIT:
	
	st_MsgBoxHeader:=["No contact with IO unit ","Kein Kontakt zu EA Einheit ","???"];
	st_MsgBoxLine3:=["Check Wire break ","Überprüfe Drahtbruch ","???"];
	st_MsgBoxLine4:=["Check other error messages in the log","Überprüfe andere Fehlermeldungen im Log","???"];
	
	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
		n_MsgBoxPLC_Error:=154;
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	
	st_GrpBoxLine1:=st_ArgGrpName;
	st_GrpBoxLine2:=" ";
	MsgBox \diBreakSignal:=SYS_di_ErrReset\Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2\ErrorToPLC;
	
	TEST n_MsgBoxAnswer
		CASE 0:
			RETRY;
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST
	!
CASE ERR_ALIASIO_DEF,ERR_ALIASIO_TYPE:
	st_MsgBoxHeader:=["Configuration Error "+st_ArgGrpName,"Fehler Konfiguration "+st_ArgGrpName,"???"];
	st_MsgBoxLine3:=["IO signal is missing or incorrectly defined","IO Signal ist nicht vorhanden oder Falsch definiert","???"];
	st_MsgBoxLine4:=["Check Configuration","Überprüfe Konfiguration","???"];
	!
	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF
	!
	st_MsgBoxHeader:=["Configuration Error GrpBase / IOcfg","Fehler Konfiguration GrpBase / IOcfg","???"];
	st_GrpBoxLine1:="st_PLC_di_NoPart = "+st_VarAliasDi;
	st_GrpBoxLine2:=st_VarAliasDi;
	!
	MsgBox \Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2;
	TEST n_MsgBoxAnswer
	CASE 1:
		Stop;
	CASE 5:
		RETURN;
	ENDTEST
ENDTEST
ENDPROC !(GripLoad_CTRL)
!640

!*****************************************************************************************


FUNC bool GrpPartRead(grp_part Part)
!****************************************
!* Procedure to get Part Control Status * 
!****************************************

VAR string st_ArgPartName;
VAR string st_GrpBoxLine1;
VAR string st_GrpBoxLine2;

st_ArgPartName:=ArgName(Part);
st_VarAliasDi:=Part.PartCtrlInput;
AliasIO st_VarAliasDi, diGrp;
!
IF diGrp =1 THEN
	RETURN TRUE;
ELSE
	RETURN FALSE;
ENDIF
!
ERROR
!** Error Handler **
st_MsgBoxElogLine4:="Grp_Base/GrpPartRead";
!
IF ERRNO=ERR_ALIASIO_DEF THEN
	st_MsgBoxHeader:=["Configuration Error "+st_ArgPartName,"Fehler Konfiguration "+st_ArgPartName,"???"+st_ArgPartName];
	st_MsgBoxLine3:=["IO signal is missing or incorrectly defined","IO Signal ist nicht vorhanden oder Falsch geschrieben","???"];
	st_MsgBoxLine4:=["Check Configuration","Überprüfe Konfiguration","???"];
	!
	IF TaskRunMec( ) THEN
		st_MsgBoxbutton1:=["OK","Ok","???"];
	ELSE
		st_MsgBoxbutton5:=["Cancel","Abbruch","???"];
	ENDIF 	
	!
	st_GrpBoxLine1:="Datentyp grp_part / string PartCtrlInput = "+st_VarAliasDi;
	st_GrpBoxLine2:=st_VarAliasDi;
	MsgBox \Line1:=st_GrpBoxLine1\Line2:=st_GrpBoxLine2;
	
	TEST n_MsgBoxAnswer
	CASE 1:
		Stop;
	CASE 5:
		RAISE;
	ENDTEST
ENDIF
!
ENDFUNC !(GrpPartPlcUpd)


!*******************************************************************************


FUNC bool PartOnHdl(num HdlNumber)
!****************************************
!* Funktion Testet ob eine Bauteilkontrolle belegt ist je nach HandlingsNr. * 
!****************************************

VAR grp_part GrpPartTemp;
 
IF HdlNumber=0 RETURN FALSE;
!
FOR i FROM 1 TO n_MaxPp DO
	b_DatExists:=TRUE;
	IF i > 9 THEN
		GetDataVal st_PpNameA + "0" + ValToStr(HdlNumber) + st_PpNameB + ValToStr(i)+ st_PpNameC{n_GrpLang},GrpPartTemp;
	ELSE
		GetDataVal st_PpNameA + "0" + ValToStr(HdlNumber) + st_PpNameB +"0"+ ValToStr(i)+ st_PpNameC{n_GrpLang},GrpPartTemp;
	ENDIF
	!
	IF b_DatExists THEN
		AliasIO GrpPartTemp.PartCtrlInput, diGrp;
	
		IF diGrp =1 THEN
			RETURN TRUE;
		ENDIF
	ENDIF
ENDFOR
!
RETURN FALSE;
!
ERROR
!** Error Handler **
SkipWarn;
IF ERRNO=ERR_SYM_ACCESS THEN
	b_DatExists:=FALSE;
	TRYNEXT;
ENDIF
ENDFUNC !(PartOnHdl)


!*******************************************************************************


FUNC num n_HdlOnRobot(num Robot)
!****************************************
!* Funktion Rückgabe Handling Nr. am Robot * 
!****************************************
VAR num nHdl;

FOR i FROM 1 TO n_MaxHdl DO
	!640
	nHdl:=i;
	!IF b_HdlOnRob{Robot,nHdl}=TRUE AND IOUnitState ("GR0"+NumToStr(nHdl,0)+"_AF1") = IOUNIT_RUNNING RETURN nHdl;
	IF b_HdlOnRob{Robot,nHdl}=TRUE AND IOUnitState ("GR"+NumToStrAddZero(nHdl)+"_AF1") = IOUNIT_RUNNING RETURN nHdl;
	!640
ENDFOR
RETURN 0;
ERROR
!** Error Handler **
IF ERRNO=ERR_NAME_INVALID THEN
	!640
	st_GrpLine1:=["There was an Configuration error within","Konfigurationsfehler ","???"];
	st_GrpLine2:=["the user definable module 'GrpData'.","im Modul 'GrpData'.","???"];
	st_GrpLine3:=["Hdl Number and UNIT","Hdl Nummer und UNIT","???"];
	st_GrpLine4:=["_AF1 are not available.","_AF1 nicht vorhanden","???"];
	ErrWrite "Gripper Setup", st_GrpLine1{n_Sp} \RL2:=st_GrpLine2{n_Sp}\RL3:=st_GrpLine3{n_Sp}\RL4:="GR"+NumToStrAddZero(nHdl)+st_GrpLine4{n_Sp};
	!640
	TRYNEXT;
ENDIF
ENDFUNC !(n_HdlOnRobot)


!*******************************************************************************

!*******************************************************************************


FUNC string NumToStrAddZero(num Value)
 !****************************************
 !* Funktion Rückgabe Zahl in Text wenn Zahl kleiner 10 wird eine 0 vor der Zahl eingefügt * 
 !****************************************
 VAR string st_Return;
 
 IF Value>-1 AND Value<10 THEN
   st_Return:=NumToStr(Value,0);
   st_Return:="0"+st_Return;
 ELSEIF Value>-10 AND Value<0 THEN
   st_Return:=NumToStr(Abs(Value),0);
   st_Return:="-0"+st_Return;
 ELSE
   st_Return:=NumToStr(Value,0);
 ENDIF
   !	
 RETURN st_Return;
ERROR
 !** Error Handler **
 IF ERRNO=ERR_NAME_INVALID THEN
    TRYNEXT;
 ENDIF
ENDFUNC !(NumToStrAddZero)


!*******************************************************************************

PROC PowerOn2(\switch dummy)
!***************************
!* PowerOn startup Routine * 
!***************************
! Applikationskennung 
st_Appl_Name:="Gripp Ware     ";
st_Appl_Key:=["1 = Actuator, 2 = PP->PLC, 3 = Setup","1 = Stellglied, 2 = BTK->SPS , 3 = Setup","???"];
!----------------------------------
IF st_VarAliasDi <> stEmpty THEN
	AliasIO st_VarAliasDi, diGrp;
ENDIF
IF st_VarAliasDo <> stEmpty THEN
	AliasIO st_VarAliasDo, doGrp;
ENDIF
 %"PowerOn2_GrpV1"%;
 %"PowerOn2_GrpV2"%;
 %"PowerOn2_GrpV3"%;
 %"PowerOn2_GrpV4"%;
 %"PowerOn2_GrpSpec1"%;
 %"PowerOn2_GrpSpec2"%;
 %"PowerOn2_GrpSpec3"%;
 %"PowerOn2_GrpSpec4"%;
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO=ERR_REFUNKPRC TRYNEXT;
ENDPROC !(PowerOn2)


!*******************************************************************************


PROC Stop2(\switch dummy)
!************************************************
!* Routine call following Stop and SKStop Event * 
!************************************************
%"Stop2_GrpV1"%;
%"Stop2_GrpV2"%;
%"Stop2_GrpV3"%;
%"Stop2_GrpV4"%;
%"Stop2_GrpSpec1"%;
%"Stop2_GrpSpec2"%;
%"Stop2_GrpSpec3"%;
%"Stop2_GrpSpec4"%;
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO=ERR_REFUNKPRC TRYNEXT;
ENDPROC !(Stop2)


!*******************************************************************************


PROC QStop2(\switch dummy)
!**************************************
!* Routine call following QStop Event * 
!**************************************
%"QStop2_GrpV1"%;
%"QStop2_GrpV2"%;
%"QStop2_GrpV3"%;
%"QStop2_GrpV4"%;
%"QStop2_GrpSpec1"%;
%"QStop2_GrpSpec2"%;
%"QStop2_GrpSpec3"%;
%"QStop2_GrpSpec4"%;
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO=ERR_REFUNKPRC TRYNEXT;
ENDPROC !(QStop2)


!*******************************************************************************


PROC Start2(\switch dummy)
!**************************************************
!* Routine call following Start and Restart Event * 
!**************************************************
Reset PLC_do_GRActError;
%"Start2_GrpV1"%;
%"Start2_GrpV2"%;
%"Start2_GrpV3"%;
%"Start2_GrpV4"%;
%"Start2_GrpSpec1"%;
%"Start2_GrpSpec2"%;
%"Start2_GrpSpec3"%;
%"Start2_GrpSpec4"%;
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO=ERR_REFUNKPRC TRYNEXT;
ENDPROC !(Start2)

!*******************************************************************************


PROC Restart2(\switch dummy)
!****************************************
!* Routine call following Restart Event * 
!****************************************

IF PPMovedInManMode() THEN
	Reset PLC_do_GRActError;
	ResetPPMoved;
ENDIF
!
IF st_VarAliasDi <> stEmpty THEN
 	AliasIO st_VarAliasDi, diGrp;
ENDIF

IF st_VarAliasDo <> stEmpty THEN
 	AliasIO st_VarAliasDo, doGrp;
ENDIF
%"Restart2_GrpV1"%;
%"Restart2_GrpV2"%;
%"Restart2_GrpV3"%;
%"Restart2_GrpV4"%;
%"Restart2_GrpSpec1"%;
%"Restart2_GrpSpec2"%;
%"Restart2_GrpSpec3"%;
%"Restart2_GrpSpec4"%;
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO=ERR_REFUNKPRC TRYNEXT;
ENDPROC !(Restart2)


!*******************************************************************************

PROC InitAppl2(\switch dummy)
!*******************************************
!* Routine call following Main Start Event * 
!*******************************************
VAR num taskno;
VAR string taskname;

taskname := GetTaskName(\MecTaskNo:=taskno);
GrpPartPlcUpd n_HdlOnRobot(taskno);
%"InitAppl2_GrpV1"%;
%"InitAppl2_GrpV2"%;
%"InitAppl2_GrpV3"%;
%"InitAppl2_GrpV4"%;
%"InitAppl2_GrpSpec1"%;
%"InitAppl2_GrpSpec2"%;
%"InitAppl2_GrpSpec3"%;
%"InitAppl2_GrpSpec4"%;
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO=ERR_REFUNKPRC TRYNEXT;
ENDPROC !(InitAppl2)

ENDMODULE
