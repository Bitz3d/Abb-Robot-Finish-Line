MODULE ComBase_LU(SYSMODULE,NOSTEPIN) 
!**********************************************************************
!* Dieses Module definiert  generellen Ablauf / Kommunikation zur SPS *
!* This module defines the general process / communication with PLC   *
!*                                                                    *
!*                Variablen und Einstellungen fuer die SPS            *
!*                   Variables and settings for PLC                   *
!**********************************************************************
! TypID Nummer fuer alle Applikationen
RECORD TypId
  num TypId_num;
ENDRECORD
!Module Version Number
CONST string st_Version_ComBase:="10.3.6c Test ComBase_LU";
 !Update 13th Apr 2015

! Automatische Einstellung der Sprache / Auto Setting for the language
! Abfrage des FlexPendant / request the FlexPendant
! 1=English, 2=Deutsch, 3=???
PERS num n_Sp:=1;
!
! Merker fuer die Applikationen, wird mit PowerOn neu gelesen / Marker for the applications is read when PowerOn
PERS string st_Appl_Info{30,3}:=[["2","Gripp Ware     ","1 = Actuator, 2 = PP->PLC, 3 = Setup"],["24","INOS Best Fit  ","1 = , 2 = , 3 = Setup"],["","",""],["","",""],["","",""],
	["","",""],["","",""],["","",""],["","",""],["","",""],["","",""],["","",""],["","",""],
	["","",""],["","",""],["","",""],["","",""],["","",""],["","",""],["","",""],["","",""],
	["","",""],["","",""],["","",""],["","",""],["","",""],["","",""],["","",""],["","",""],["","",""]];
VAR string st_Appl_Name:="";
VAR string st_Appl_Key{3}:=["","",""];
PERS num n_ApplMax:=2;
PERS num n_Fk4ApplAktiv:=0;
PERS num n_Fk4ApplNum:=0;
PERS bool b_PwOnEnd:=TRUE;
PERS num n_SMPins{4}:=[5553,0,0,0];
TASK PERS bool b_Start_present{30}:=[TRUE,FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,
								TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE];
PERS bool b_ReStart_present{30}:=[TRUE,FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,
								  TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE];
PERS bool b_Stop_present{30}:=[TRUE,FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,
							   TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE];
PERS bool b_Reset_present{30}:=[TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,
								TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE];
PERS bool b_StartUser_present:=TRUE;
PERS bool b_ReStartUser_present:=TRUE;
PERS bool b_StopUser_present:=TRUE;
PERS bool b_ResetUser_present:=TRUE;
PERS bool b_PPMoved:=FALSE;
VAR bool b_PPMoved_mem:=FALSE;

VAR num n_Appl_count;
VAR bool b_UserEv;
!
! Variablen zum Dialog / Varaiables for Dialog
VAR string st_UiHeader{3};
VAR string st_UiHeader_2{3};
VAR string st_UiMsgLines{5};
VAR string st_UiMsgLine1{3};
VAR string st_UiMsgLine2{3};
VAR string st_UiMsgLine3{3};
VAR string st_UiMsgLine4{3};
VAR string st_UiMsgLine5{3};
VAR listitem li_UiMsgList{5};
VAR string st_UiMsgButtons{5};
VAR string st_UiMsgButtons1{3};
VAR string st_UiMsgButtons2{3};
VAR string st_UiMsgButtons3{3};
VAR string st_UiMsgButtons4{3};
VAR string st_UiMsgButtons5{3};
VAR string st_Dummy{3};
VAR string st_Dummy2{3};
VAR btnres br_UiAnswer;
!----------------------------------------------------
!Predefined Const for TypID
!
CONST TypId Id_00:=[0];
CONST TypId Id_01:=[1];
CONST TypId Id_02:=[2];
CONST TypId Id_03:=[3];
CONST TypId Id_04:=[4];
CONST TypId Id_05:=[5];
CONST TypId Id_06:=[6];
CONST TypId Id_07:=[7];
CONST TypId Id_08:=[8];
CONST TypId Id_09:=[9];
CONST TypId Id_10:=[10];
CONST TypId Id_11:=[11];
CONST TypId Id_12:=[12];
CONST TypId Id_13:=[13];
CONST TypId Id_14:=[14];
CONST TypId Id_15:=[15];
!----------------------------------------------------
! Variablen und Einstellungen der MsgBox die von den Appl gemeinsam genutzt werden /
! Variables and settings of the MsgBox that are shared by all Applications
VAR string st_MsgBoxHeader{3};
VAR string st_MsgBoxLine3{3};
VAR string st_MsgBoxLine4{3};
VAR string st_MsgBoxLine5{3};
VAR string st_MsgBoxElogLine4;
VAR string st_MsgBoxbutton1{3};
VAR string st_MsgBoxbutton2{3};
VAR string st_MsgBoxbutton3{3};
VAR string st_MsgBoxbutton4{3};
VAR string st_MsgBoxbutton5{3};
VAR string st_MsgBoxSignal;
VAR string st_MsgBoxSignalValue;
VAR string st_MsgBoxGeraeteName{3};
VAR num n_MsgBoxApplError;
VAR num n_MsgBoxPLC_Error;
VAR num n_MsgBoxGeraeteNr;
VAR num n_MsgBoxAnswer;
VAR num n_Step;
!----------------------------------------------------
! Variablen und Einstellungen der MsgBoxEventStart die von den Appl gemeinsam genutzt werden /
! Variables and settings of the MsgBoxEventStart that are shared by all Applications
VAR string st_MsgBoxEvHeader{3};
VAR string st_MsgBoxEvLine3{3};
VAR string st_MsgBoxEvLine4{3};
VAR string st_MsgBoxEvLine5{3};
VAR string st_MsgBoxEvElogLine4;
VAR string st_MsgBoxEvbutton1{3};
VAR string st_MsgBoxEvbutton2{3};
VAR string st_MsgBoxEvbutton3{3};
VAR string st_MsgBoxEvbutton4{3};
VAR string st_MsgBoxEVbutton5{3};
VAR string st_MsgBoxEvSignal;
VAR string st_MsgBoxEvSignalValue;
VAR string st_MsgBoxEvGeraeteName{3};
VAR num n_MsgBoxEvApplError;
VAR num n_MsgBoxEvPLC_Error;
VAR num n_MsgBoxEvGeraeteNr;
VAR num n_MsgBoxEvAnswer;
VAR num n_StepEv;
!----------------------------------------------------
! Kalibrierposition jpCalibA1_A6 Achsen1-6 auf 0 Grad / Calibration position
CONST jointtarget jpCalibA1_A6:=[ [ 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0]];
PERS jointtarget jpTemp:=[ [ 92.8961, 38.0687, 0, 0, 2, 1.67904E-07],[9E+09, 9E+09, 9E+09, 9E+09, 9E+09, 9E+09]];
!
VAR num n_HomeSelect;
VAR num n_PGNNumber;
PERS num n_PGNNumber_Mem:=1;!Last Program number memory

VAR num n_Temp;
VAR bool b_Temp;
VAR num n_JobFinNum;
VAR num n_JobReqNum;
VAR bool b_JobF_w;
VAR bool b_JobR_w;


!----------------------------------------------------
! Tool fuer Position jpSM1SyncSwitch / Tool information for jpSM1SyncSwitchpos position
TASK PERS tooldata t_SMSync:= [TRUE, [[0.04, -0.03, 66.92], [0.991445, 0, 0, 0.130526]],[26.5, [-58.6, 41.7, -18.4],[1, 0, 0, 0], 0, 0, 0.141]];
!
!**********************************************************
!Copy SM Files to HOME directory                         *
!**********************************************************
CONST string stSMCalInternal:="INTERNAL:/OPTIONS/PSC/psc_calib_";
CONST string stSMCalHome:="HOME:/SafetyBCK/psc_calib_";
CONST string stSMInternal:="INTERNAL:/OPTIONS/PSC/psc_user_";
CONST string stSMHome:="HOME:/SafetyBCK/psc_user_";
CONST string stSMBck:="/hd0a/BACKUP/";
CONST string stSMBckFile:="/HOME/SafetyBCK/psc_user_";
CONST string stSMBckCal:="/HOME/SafetyBCK/psc_calib_";

VAR string stCon_Int_Dir;  !Controller internal directory
VAR string stCon_Home_Dir; !Controller internal Home directory
VAR string sthd0a_Home_Dir;!Flash card internal Home directory

! Filesize of an empty SM user_config
CONST num nSMFilesize:=230;
!----------------------------------------------------
! Home Var 
TASK PERS tooldata t_Home:= [TRUE, [[26.5774, 98.0613, 502.695], [0.608761, 0, 0, -0.793353]],[311.4, [-15.6, -0.4, 261.4],[1, 0, 0, 0], 130.469, 118.237, 123.004]];
TASK PERS wobjdata wobj_home:=[FALSE, TRUE, "", [[603,2050.01,-515], [0,0,0,1]], [[0,0,0], [1,0,0,0]]];
VAR speeddata sp_SpeedHome;
VAR listitem listHome{5};
!----------------------------------------------------
! Bezeichner fuer die Home, bleibt einsprachig / Identifier for the home, remains monolingual
CONST listitem listHomeConst{5} := [ ["","Home 1 "], ["","Home 2 "],["","Home 3 "],["","Home 4 "] ,["","Home 5 "]  ];
!----------------------------------------------------
! Home Posabweichung Fein 2 Grad fuer Weltzone Home Ueberwachung / Home position in position tolerance
CONST jointtarget delta_HomePosFine := [ [ 2, 2, 2, 2, 2, 2],[5, 5, 5, 5, 5, 5]];
!----------------------------------------------------
! Volumen-Daten Weltzone Home Ueberwachung / Volume of data world-zone Home Surveillance
VAR shapedata sh_HomePos1;
VAR shapedata sh_HomePos2;
VAR shapedata sh_HomePos3;
VAR shapedata sh_HomePos4;
VAR shapedata sh_HomePos5;
!----------------------------------------------------
! Weltzonen Home Ueberwachung / World Home Surveillance Zones
VAR wzstationary wz_HomePos1:=[0];
VAR wzstationary wz_HomePos2:=[0];
VAR wzstationary wz_HomePos3:=[0];
VAR wzstationary wz_HomePos4:=[0];
VAR wzstationary wz_HomePos5:=[0];
!----------------------------------------------------
! Kugel durchmesser Weltzonen Ueberwachung / Ball diameter world zones Surveillance
CONST num n_Ball:=50;
!----------------------------------------------------
! Merker fuer Kolisionsueberwachung / Marker for Collision control
PERS bool b_CollZoneOccupied{63}:=[FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE];
PERS num n_Coll{5}:=[2,0,0,0,0];
PERS num n_CollClZ:=1;
PERS bool b_CollClearAct:=FALSE;
!----------------------------------------------------
! Merker fuer PP wurde versetzt
VAR bool b_CheckPP;
!----------------------------------------------------
! Fehlerausgabe Status / Error Status
VAR bool b_OK;
VAR bool b_TimeOut;
!----------------------------------------------------
! Merker fuer Produktions loop / Marker for production loops
VAR bool b_AutoOff;
! Betriebsstundenzaehler / operating hours counters
VAR string st_op_cnt:="";
PERS num n_op_h_counter:=5881;
VAR string st_Abs; 
!----------------------------------------------------
VAR Bool b_MainProg_Started ;!A main program as been started 
PERS Bool b_PowerOn_exe_OK:=TRUE ;!Power on event has been executed
PERS Bool b_TbCom_Started:=TRUE ;!Background TB Com started
PERS bool b_Ignore_NoAppl_Chk:=FALSE ;!Ignore No APpplication check in StartCOM
PERS num n_ModeOP_Mem:=1 ;!Keyswitch mode operation memory
VAR Bool b_PathColDetectOn:=FALSE ;!Motor supervision on 
VAR num n_ManSyncCMD:=0;! ManSyncPos Command
!----------------------------------------------------
!Variables to Check if this robot absolute accuracy compitable
PERS String st_RobotType:="ROB1_7600_2.55_500" ;!Robot type
PERS Bool b_Robot_ABS_Type ;!Robot is absolute accurate 
VAR Bool b_ABS_Acc_Enable:=TRUE ;!Application ignore Absolute accuracy message 
!----------------------------------------------------

!MsgBox di Break Control
PERS String st_MsgboxBrk_SignalName ;!Message box break Signal name to TB_Com
PERS String st_MsgboxBrk_ReturnName ;!Message box break Return Signal name from TB_Com
PERS Dnum dn_MsgboxBrk_ReqValue ;!Message box break required value to TB_Com
PERS Bool b_Invert_Control ;!Message box break Inverse Control Output to TB_Com

!Variables for monitoring Safety Gate and Manual teach mode keyswitch
PERS Bool b_SafetyGate_Was_Opened ;!Safety Gate was opened
PERS Bool b_ManMode_Was_Selected ;!Manual mode was selected
PERS Num n_SafetyGate_Req_Time;! Time the safety gate must be opened before timeout
PERS Num n_SafetyGate_Opened_Time;! Time the safety gate has been opened

!Variables for Log system
PERS String s_LOG_TX_Data ;!Message to be entered into log max 50 char
PERS String s_LOG_TX_Cat  ;!Message Category into log max 4 char

!Variables for Bit level Group Input and Output control
VAR num  n_LastGroupOutput:=0;
VAR num  n_LastGroupInput:=0;

!Robot number used identify the robot used for this task mainly used for Multimove
CONST Num n_RobotNr:=1;

!Memorise plc Error code
PERS Num n_PLC_ErrCode_Mem:=-4;
!----------------------------------------------------


!Variables for Indirect_WOBJ
PERS num n_DefWob_jDiff_Ges{3}:=[2.09808E-05,0.264905,0.433745];
PERS num n_DefWobj_Diff_Z{3}:=[2.09808E-05,-0.00128365,0.00133324];
PERS num n_DefWobj_Diff_Y{3}:=[0,0.264893,-0.417847];
PERS num n_DefWobj_Diff_X{3}:=[0,-0.0022583,-0.116348];
PERS wobjdata wobj_DefWobj_car0:=[FALSE,TRUE,"",[[-1.55826,939.221,447.268],[0.707962,0.0617476,0.0581078,-0.701142]],[[0,0,0],[1,0,0,0]]];
PERS tooldata t_DefWobj_Act_tool:=[TRUE,[[0,0,0],[1,0,0,0]],[0.001,[0,0,0.001],[1,0,0,0],0,0,0]];
PERS wobjdata wobj_DefWobj_ACT_wobj:=[FALSE,TRUE,"",[[0,0,0],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];
PERS string s_DefWobj_Tool_Name:="tool0";
PERS string s_DefWobj_Wobj_Name:="wobj0";
PERS num n_DefWobj_px:=2734.52;
PERS num n_DefWobj_py:=-250;
PERS num n_DefWobj_pz:=40.459;
PERS robtarget rt_DefWobj_user_p{3}:=[[[271.15,-1260.46,24.4443],[0.539391,-0.00995541,0.0179942,0.841804],[-1,-1,0,1],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]],[[275.724,-1760.69,26.8719],[0.539275,-0.00995293,0.0180075,0.841877],[-1,-1,0,1],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]],[[-224.132,-1764.6,23.8962],[0.539218,-0.00994843,0.0180428,0.841914],[-2,-2,0,1],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]]];
PERS robtarget rt_DefWobj_mess_p{3}:=[[[2242.11,250,-46.365],[1,0,0,0],[-1,-1,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]],[[2734.52,250,40.459],[1,0,0,0],[-1,-1,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]],[[2734.52,-250,40.459],[1,0,0,0],[-1,-1,-1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]]];


!----------------------------------------------------

PROC InitAutoMode()
!******************************************************
!*                                                    *
!* Prozedur fuer das Starten des Roboters in Automatik*
!*   Procedure for starting the robot in automatic!   *
!*                                                    *
!******************************************************
!
! Bewegungsueberwachung einschalten / Activate motion supervision
MotionSup \On;

!Reset Msgbox signals 
SetGO PLC_go_ErrCode, 0;
Reset PLC_do_MsgToPLC;
Reset PLC_do_ErrorToPLC;
Reset PLC_do_StopToPLC;
Reset VB_do_TaskBrake;
n_PLC_ErrCode_Mem:=-1;

! abfrage ob Betriebsart Hand / Check operation mode
WHILE OpMode()= OP_AUTO DO
	st_UiHeader:=["Com, Waiting for Robot in Teach Mode ","Com, Warte auf Hand-Betrieb","???"];    
	st_UiMsgLine1:=["  Please switch the mode selection ","  Bitte Programm Main in der Betriebsart ","???"];
	st_UiMsgLine2:=["  to Teach/Manual Mode.","  Hand starten.","???"];
	UIMsgBox\Header:=st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}
	\Buttons:=btnOK\Icon:=iconWarning;
	!
	IF OpMode()= OP_AUTO Stop;
ENDWHILE

IF b_PowerOn_exe_OK=FALSE PowerOnCom ;

! Abfrage ob die AbsAcc ein ist
ReadCfgData "/MOC/ROBOT/ROB_1","use_robot_calib",st_Abs; 

IF st_Abs="r1_uncalib" AND b_Robot_ABS_Type THEN
	st_UiHeader:=["Com, No Absolute Accuracy","Com, Keine Absolutgenauigkeit","???"];   
	st_UiMsgLine1:=["Warning! The robot absolute accuracy is turned Off.","Achtung bei diesem Roboter ist die Absolutgenauigkeit = Off","???"];
	st_UiMsgLine2:=["Absolute accuracy must be enabled","Ohne aktive Absolutgenauigkeit ist es nicht erlaubt","???"];
	st_UiMsgLine3:=["and without it, there is a high risk ","den Roboter zu programmieren oder Programme abzufahren,","???"];
	st_UiMsgLine4:=["of a collision.","es besteht Kollisionsgefahr!","???"];
	st_UiMsgLine5:=["Please ensure it is enabled!","Bitte schalten Sie die Absolutgenauigkeit wieder ein!","???"];
    st_UiMsgButtons5:=["Ignore","ignorieren","???"];
    st_UiMsgButtons:=["","","","",st_UiMsgButtons5{n_Sp}];
    st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},st_UiMsgLine5{n_Sp}]; 
    br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconError);
ENDIF

! Abfrage ob der Roboter synchron ist / check because synced Robot
IF DOutput(SM1_do_Synced) = 0 THEN
	br_UiAnswer:=0;
	st_UiHeader:=["Com, SafeMove not Synchronised!","Com, SafeMove nicht synchron!","???"];    
	st_UiMsgLine1:=["Warning! SafeMove(safety control) is not activated","Achtung, SafeMove(Sicherheitssteuerung) ist nicht aktiv!","???"];
	st_UiMsgLine2:=["Automatic operation without *SoftSync* is not possible!","Automatikbetrieb ist mit der Option *SoftSync* nicht moeglich!","???"];
	st_UiMsgLine3:=["Please synchronise the robot (SafeMove).","Bitte den Roboter (SafeMove) erst manuell synchronisieren lassen.","???"];
	st_UiMsgLine4:=["","","???"];
	st_UiMsgLine5:=["Press> Ignore to continue to operate without SoftSync.","Mit ignorieren geht es im Ablauf (ohne SoftSync) weiter.","???"];
	st_UiMsgButtons5:=["Ignore","ignorieren","???"];
	st_UiMsgButtons:=["","","","",st_UiMsgButtons5{n_Sp}];
	st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},st_UiMsgLine5{n_Sp}]; 
	!
	br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}
	\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconWarning);
ENDIF

! Simulierte Signale Abfragen
IF DOutput(VB_do_Simulated_IO)= 1 AND RobOS() = TRUE  THEN
	WHILE DOutput(VB_do_Simulated_IO)= 1 DO
 		st_UiHeader:=["Com, Caution simulated signals!","Com, Achtung Simulierte Signale!","???"];    
 		st_UiMsgLine1:=["There are some signals that are simulated which is not allowed in ","Das Simulieren von Signalen ist im Automatik nicht erlaubt!","???"];
 		st_UiMsgLine2:=["automatic mode!  To continue please","Um fortzufahren bitte die Simulation aller","???"];
 		st_UiMsgLine3:=["select the I/O menu then turn off the simulation/s.","Signale im Ein-Ausgangs Fenster ausschalten.","???"];
 		UIMsgBox\Header:=st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}\MsgLine3:=st_UiMsgLine3{n_Sp}
 						\Buttons:=btnOk\Icon:=iconWarning;
		!
		IF DOutput(VB_do_Simulated_IO)= 1 Stop;
	ENDWHILE
ENDIF	

!Jog supervision enable
WriteCfgData "/MOC/MOTION_SUP/rob1","jog_col_detect_on", TRUE; 

!Check motor supervision enabled
ReadCfgData "/MOC/MOTION_SUP/rob1","path_col_detect_on",b_PathColDetectOn; 

IF b_PathColDetectOn=FALSE THEN
	st_UiHeader:=["Com, Motor Supervision","Com, Motor Ueberwachung","???"];   
	st_UiMsgLine1:=["The robot path supervision is","Die Roboter Pfad Ueberwachung ist","???"];
	st_UiMsgLine2:=["turned off and should be turned on.","ausgeschalten und solle angeschalten sein.","???"];
	st_UiMsgLine3:=["","","???"];
	st_UiMsgLine4:=["","","???"];
	st_UiMsgLine5:=["Please select option.","Option waehlen bitte.","???"];
    st_UiMsgButtons4:=["Turn On","anschalten","???"];
    st_UiMsgButtons5:=["Ignore","ignorieren","???"];
    st_UiMsgButtons:=["","","",st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
    st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},st_UiMsgLine5{n_Sp}]; 
    br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconWarning);
    
    IF br_UiAnswer=4 WriteCfgData "/MOC/MOTION_SUP/rob1","path_col_detect_on", TRUE; 
ENDIF

! meldet an PLC das Programmzeiger im Main ist / Inform PLC main program is selected 
b_CheckPP:=TRUE;
Set SYS_do_MainStarted;
VelSet 100,5000;

! zum anfahren der Homeposition
! abfrage ob mehr als eine HomePos / Check number of homes configured 
FOR i FROM 1 TO 5 DO  
  IF b_HomeInUse{i}=TRUE Incr n_Temp;
ENDFOR

! auslesen der Beschreibung der benutzten Home / Read the home descriptions
IF n_Temp>1 THEN      
 	Abfrg2:
	FOR i FROM 1 TO 5 DO  
		IF b_HomeInUse{i} THEN
			! vorgabe der Home von der SPS / specification of the Home of the PLC
			IF b_PLCNeedHome(i)= TRUE THEN
				st_UiMsgLine1:=["PLC> ","SPS> ","???"];
				listHome{i}.text:=st_UiMsgLine1{n_Sp};  
			ELSE
				listHome{i}.text:="        ";
			ENDIF
			listHome{i}.text:=listHome{i}.text+listHomeConst{i}.text+st_Home_label{i};
		ELSE
			listHome{i}.text:="";
		ENDIF 
	ENDFOR
	
	! Anzeigen der HomePos / Generate Home positions message
  	st_UiHeader:=["Com, The Robot is ","Com, Der Roboter steht auf ","???"];
	    
	IF n_RobInHomeDO()> 0 THEN
    	st_UiHeader_2:=["at Home number "+ValToStr(n_RobInHomeDO()),"Home "+ValToStr(n_RobInHomeDO()),"???"+ValToStr(n_RobInHomeDO())];          
	ELSE
    	st_UiHeader_2:=["not in any Home.","keiner Home.","???"];    
	ENDIF
	
	st_UiMsgButtons1:=["Refresh Display","Ansicht aktualisieren","???"];
	st_UiMsgButtons4:=["Ok","Ok","???"];
	st_UiMsgButtons5:=["Abort","Abbruch","???"];
	st_UiMsgButtons:=[st_UiMsgButtons1{n_Sp},"","",st_UiMsgButtons4{n_Sp},""];
	
	n_HomeSelect := UIListView(\Result:=br_UiAnswer\Header:=st_UiHeader{n_Sp}+st_UiHeader_2{n_Sp},listHome
      \BtnArray:=st_UiMsgButtons\Icon:=iconInfo\DefaultIndex:=n_RobInHomeDO());
	
	IF br_UiAnswer = 1 GOTO Abfrg2;
	IF br_UiAnswer = 5 THEN
  	TPErase;
  	TPShow TP_LATEST;
  	EXIT ;
   ENDIF
ELSE !n_temp>1
	! es gibt nur eine Home / There is only one Home
	n_HomeSelect:=1;
ENDIF !n_temp>1

!----------------------------------------------------
! Ueberprueft ob die Homeposition programmiert wurde / Checks whether the home position has been programmed
br_UiAnswer:=0;
b_Temp:=FALSE;
IF n_HomeSelect=1 AND jpHome1.robax <> jpCalibA1_A6.robax AND b_HomeAkt{n_HomeSelect}=TRUE b_Temp:=TRUE;
IF n_HomeSelect=2 AND jpHome2.robax <> jpCalibA1_A6.robax AND b_HomeAkt{n_HomeSelect}=TRUE b_Temp:=TRUE;
IF n_HomeSelect=3 AND jpHome3.robax <> jpCalibA1_A6.robax AND b_HomeAkt{n_HomeSelect}=TRUE b_Temp:=TRUE;
IF n_HomeSelect=4 AND jpHome4.robax <> jpCalibA1_A6.robax AND b_HomeAkt{n_HomeSelect}=TRUE b_Temp:=TRUE;
IF n_HomeSelect=5 AND jpHome5.robax <> jpCalibA1_A6.robax AND b_HomeAkt{n_HomeSelect}=TRUE b_Temp:=TRUE;

IF b_Temp=FALSE THEN
	st_UiHeader:=["Com, Home Configuration Error","Com, Fehlerhafte Home_","Com,???"];
	IF b_HomeAkt{n_HomeSelect}=FALSE THEN
		st_UiMsgLine1:=["The Home position selected has not been activated","Die ausgewaehlte Home ist nicht aktiv","???"];
		st_UiMsgLine2:=["therefore, the Home output will not be sent to the PLC.","der Ausgang wird nicht zur SPS gesetzt.","???"];
		st_UiMsgLine3:=["Please select 'HomeSetup' to configure.","Bitte ueber das HomeSetup die Home aktivieren.","???"];
	ELSE
		st_UiMsgLine1:=["The Home position selected either not programmed","Die ausgewaehlte Home ist nicht programmiert","???"];
		st_UiMsgLine2:=["or the robot is in the calibration position!","oder entspricht der Nullstellung!","???"];
		st_UiMsgLine3:=["Please select 'Setup' to configure.","Bitte die Position ueber das HomeSetup anpassen.","???"];
	ENDIF
	
	st_UiMsgButtons3:=["Home Setup","Home Setup","???"];
	st_UiMsgButtons5:=["Abort","Abbruch","???"];
	st_UiMsgButtons:=["","",st_UiMsgButtons3{n_Sp},"",st_UiMsgButtons5{n_Sp}];
	st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},"",""]; 
	
	br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}+ValToStr(n_HomeSelect)
		\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconWarning);
	 
	IF br_UiAnswer = 5 THEN
		TPErase;
		TPShow TP_LATEST;
		EXIT;
	ENDIF 
	
	IF br_UiAnswer = 3 Homesetup;
	EXIT;
ENDIF

! Abfrage wegen Tool 0 / check because of tool zero
IF CTool()=tool0 THEN
  	br_UiAnswer:=0;
  	st_UiHeader:=["Com, Tool Load check","Com, Tool Ueberpruefung","???"];    
  	st_UiMsgLine1:=["Attention!! the active tool is tool0.","Achtung das aktive Tool ist - tool0 - !!! ","???"];
  	st_UiMsgLine2:=["The robot cannot move with tool0 because","Der Roboter kann vermutlicht wegen falschen  ","???"];
  	st_UiMsgLine3:=["it has the incorrect payload configured.","Gewichtsdaten nicht bewegt werden, ","???"];
  	st_UiMsgLine4:=["Using the Jogging Window, please change to the","bitte waehle im Bewegen-Fenster das richtige Tool aus,","???"];
  	st_UiMsgLine5:=["correct tool then select 'Ok' button.","bevor es mit Ok weiter geht.","???"];
  	st_UiMsgButtons1:=["","","???"];
  	st_UiMsgButtons2:=["","","???"];
  	st_UiMsgButtons3:=["","","???"];
  	st_UiMsgButtons4:=["Ok","Ok","???"];
  	st_UiMsgButtons5:=["","","???"];
  	st_UiMsgButtons:=[st_UiMsgButtons1{n_Sp},st_UiMsgButtons2{n_Sp},st_UiMsgButtons3{n_Sp},st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
  	st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},st_UiMsgLine5{n_Sp}]; 
  	!
  	br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}
  	\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconWarning);
ENDIF

! Bestaetigung und Geschwindigkeitsauswahl / Confirmation and speed selection
sp_SpeedHome:=v100;
IF b_RobInHomeDO(n_HomeSelect)= FALSE THEN
  	br_UiAnswer:=0;
  	st_UiHeader:=["Com, Move Robot to Homepos ","Com, Bewege Roboter zur Home ","Com,???"];    
  	st_UiMsgLine3:=["     Attention!","    Achtung!","???"];
  	st_UiMsgLine4:=["     The Robot will move -> ","    Roboter faehrt mit Ok -> ","???"];
  	st_UiMsgLine5:=["     directly to the Home ","    direkt zur Home ","???"];
  	st_UiMsgButtons1:=["Fast (v250)","SCHNELL (v250)","???"];
  	st_UiMsgButtons2:=["Slow (v100)","LANGSAM (v100)","???"];
  	st_UiMsgButtons3:=["","","???"];
  	st_UiMsgButtons4:=["Move Home","Ok","???"];
  	st_UiMsgButtons5:=["Abort","Abbruch","???"];
  	st_UiMsgButtons:=[st_UiMsgButtons1{n_Sp},st_UiMsgButtons2{n_Sp},st_UiMsgButtons3{n_Sp},st_UiMsgButtons4{n_Sp},""];
  	st_Dummy:=st_UiMsgButtons2;
  	Abfrg1:
  	st_UiMsgLines:=[" "," ",st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp}+st_Dummy{n_Sp},st_UiMsgLine5{n_Sp}+ValToStr(n_HomeSelect)]; 
	
  	br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}+ValToStr(n_HomeSelect)
  			\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconWarning);
		 
	TEST br_UiAnswer 
		CASE 1:
		! schnell/fAST
		st_Dummy:=st_UiMsgButtons1;
		sp_SpeedHome:=v200;
		GOTO Abfrg1;
	CASE 2:
		! langsam/sLOW
		st_Dummy:=st_UiMsgButtons2;
		sp_SpeedHome:=v100;
		GOTO Abfrg1;
	CASE 4:
		! OK/ok
	CASE 5:
		! Abbruch / Abort
		TPErase;
		TPShow TP_LATEST;
			EXIT;
	ENDTEST
	 
	! Prozedur zum Initialisieren von Ein-, Ausgaengen, Variabelen fuer den User / Procedure to initialize inputs, outputs, variables for the user
	InitBeforHome n_HomeSelect;
	! Homefahrt 
	t_Home := CTool();    	
	wobj_home := CWobj();    	
	 
	TEST n_HomeSelect
	CASE 1:
		MoveAbsJ jpHome1\NoEOffs, sp_SpeedHome, fine, t_Home\WObj:=wobj_home;
	CASE 2:
		MoveAbsJ jpHome2\NoEOffs, sp_SpeedHome, fine, t_Home\WObj:=wobj_home;      
	CASE 3:
		MoveAbsJ jpHome3\NoEOffs, sp_SpeedHome, fine, t_Home\WObj:=wobj_home;      
	CASE 4:
		MoveAbsJ jpHome4\NoEOffs, sp_SpeedHome, fine, t_Home\WObj:=wobj_home;      
	CASE 5:
		MoveAbsJ jpHome5\NoEOffs, sp_SpeedHome, fine, t_Home\WObj:=wobj_home;
	ENDTEST
ELSE !n_HomeSelect
	! Roboter steht schon auf Home x
	! Prozedur zum Initialisieren von Ein-, Ausgaengen, Variabelen fuer den User /
	! Robots already standing at home x 
	! Procedure to initialize inputs, outputs, variables for the user
 	InitBeforHome n_HomeSelect;
ENDIF !n_HomeSelect

! check ob Home x Ausgang = 1
IF b_RobInHomeDO(n_HomeSelect)= FALSE THEN
  	br_UiAnswer:=0;
  	st_UiHeader:=["Com, Error Output SYS_do_Home_"+ValToStr(n_HomeSelect)+" = 0","Com, Fehler: Ausgang SYS_do_Home_"+ValToStr(n_HomeSelect)+" = 0","Com,???"];    
  	st_UiMsgLine3:=[" Attention Output from Home "+ValToStr(n_HomeSelect)+" does not =1.","Achtung der Ausgang fuer die Home " +ValToStr(n_HomeSelect)+" wurde nicht gesetzt!","???"];
  	st_UiMsgLine4:=[" The HomePos is not valid therefore, the program will stop.","Die Grundstellung ist nicht gueltig, der Ablauf wird abgebrochen.","???"];
  	st_UiMsgLine5:=[" Please ReCheck the Home"+ValToStr(n_HomeSelect)+" using the HomeSetup option.","Bitte im HomeSetup die Grundstellung Home"+ValToStr(n_HomeSelect)+"  berichtigen. ","???"];
  	st_UiMsgButtons1:=["","","???"];
  	st_UiMsgButtons2:=["","","???"];
  	st_UiMsgButtons3:=["Home Setup","Home Setup","???"];
  	st_UiMsgButtons4:=["Ok","Ok","???"];
  	st_UiMsgButtons5:=["","","???"];
  	st_UiMsgButtons:=[st_UiMsgButtons1{n_Sp},st_UiMsgButtons2{n_Sp},st_UiMsgButtons3{n_Sp},st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
  	st_UiMsgLines:=[" "," ",st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},st_UiMsgLine5{n_Sp}]; 
  	!
  	br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconError);
  	! Fehler /Error
    IF br_UiAnswer = 3 Homesetup;
  	TPErase;
  	TPShow TP_LATEST;
 	EXIT;
ENDIF

InitInHome n_HomeSelect;     

! Prozedur zum Initialisieren von Ein-, Ausgaengen, Variabelen fuer den User /
! Procedure to initialize user inputs, outputs and variables
InitMain;
InitProduktion;

WHILE OpMode()<>OP_AUTO DO
	! Aufforderung fuer Automaikbetrieb
	br_UiAnswer:=0;
	st_UiHeader:=["Com, Automatic Mode","Com, Automatik Extern Betrieb","Com,???"];    
	st_UiMsgLine2:=["Please turn the mode selection Switch ","Den Schluesselschalter auf Automatik stellen ","???"];
	st_UiMsgLine3:=["to the Automatic Mode External position.","um in die Betriebsart Automatik Extern ","???"];
	st_UiMsgLine4:=[" ","zu wechseln.","???"];
	st_UiMsgButtons5:=["Abort","Abbruch","???"];
	st_UiMsgButtons:=["","","","",""];
	st_UiMsgLines:=[" ",st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},""]; 

	br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}
		\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconInfo\DOBreak:=SYS_do_Auto);	
	!
	IF br_UiAnswer = resCancel THEN
		TPErase;
		TPShow TP_LATEST;
		EXIT;
	ENDIF 
ENDWHILE

! Schleife fuer den AutoEX Betrieb\Loop for the operational AutoEX
WHILE b_AutoOff=FALSE DO
	b_AutoOff:=FALSE;
	InitProduktion;
	! Betriebsstundenzaehler lesen / operating hours counters read
	st_op_cnt:=GetServiceInfo(ROB_ID \DutyTimeCnt);
	b_Temp:=StrToVal(st_op_cnt, n_op_h_counter);
	
	WHILE SYS_di_ProgNumValid=1 DO
		st_MsgBoxHeader:=["Com, Error Prog Number Valid ","Com, Fehler Signal Prognum. gueltig!","???"];
		st_MsgBoxLine4:=["The Error is in the PLC","Fehlerbehebung an der SPS","???"];
		st_MsgBoxbutton4:=["Ok","Ok","???"];
		st_MsgBoxSignal:="SYS_di_ProgNumValid";
		st_MsgBoxGeraeteName:=["PLC I/O","SPS E/A","???"];
		n_MsgBoxGeraeteNr:=0;
		st_MsgBoxSignalValue:="0";
		n_MsgBoxApplError:=3;
		n_MsgBoxPLC_Error:=33;
		st_MsgBoxElogLine4:="ComBase/InitAutoMode";
		MsgBox\diBreakSignal:=SYS_di_ErrReset\ErrorToPLC;
	ENDWHILE
	
	! Betriebsstundenzaehler setzen zur SPS/ operating hours counters set to PLC
	IF b_Temp = TRUE SetGO PLC_go_WeldPoint_Num, n_op_h_counter;
	! anfrage Prognum. / Send program number request   
	Set SYS_do_ProgNumReq;  

	IF RobOS()  THEN
		st_UiHeader:=["          Com, Program Number","Com, Warte auf gueltige Programmnummer...","Com,???"];
		st_UiMsgLine1:=["         ******************************************","        ******************************************","???"];
		st_UiMsgLine2:=["         *     Waiting for the Program Number     *","        *      Warten auf die Programmnummer     *","???"];
		st_UiMsgLine3:=["         *              from the PLC.         V3.6*","        *               von der SPS.         V3.6*","???"];
		st_UiMsgLine4:=["         ******************************************","        ******************************************","???"];
		! Meldung an SPS, warte auf programmnummer / Waiting PLC Number
		 Reset PLC_do_ErrorToPLC;
		SetGO PLC_go_ErrCode, 32;
		Set PLC_do_MsgToPLC;
  		UIMsgBox\Header:=st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}
				\MsgLine3:=st_UiMsgLine3{n_Sp}\MsgLine4:=st_UiMsgLine4{n_Sp}\Buttons:=btnNone\Icon:=iconInfo
				\DIBreak:=SYS_di_ProgNumValid;
		! zuweisung der Prognum / Allocation of program number
		n_PGNNumber:=GInput(SYS_gi_ProgNumber);
		SetGO PLC_go_ErrCode, 0;
 		Reset PLC_do_MsgToPLC;
 		Reset PLC_do_ErrorToPLC;
	ELSE
		! manuelle Prognr nur fuer RobotStudio / Manual PGNR robot studio
  		st_UiHeader:=[" VirtualProgram Number","Programmnummer Virtual","???"];    
 		st_UiMsgLine1:=["Program Number?","Programmnummer? 1-63","???"];
		n_PGNNumber := UINumEntry(\Header:=st_UiHeader{n_Sp}\Message:=st_UiMsgLine1{n_Sp}\Icon:=iconInfo
		\InitValue:=1\MinValue:=1\MaxValue:=63\AsInteger);
	ENDIF
	! Abfrage ob die AbsAcc ein ist
	ReadCfgData "/MOC/ROBOT/ROB_1","use_robot_calib",st_Abs; 
	
	IF st_Abs="r1_uncalib" AND b_Robot_ABS_Type THEN
		st_UiHeader:=["Com, AbsAcc error","Com, Fehler Absolutgenauigkeit","???"];   
		st_UiMsgLine1:=["Warning! The robot absolute accuracy is turned Off.","Achtung bei diesem Roboter ist die AbsAcc = Off","???"];
		st_UiMsgLine2:=["Absolute accuracy must be enabled","Ohne aktive Absolutgenauigkeit ist es nicht erlaubt","???"];
		st_UiMsgLine3:=["and without it, there is a high risk","den Roboter zu programmieren oder Programme abzufahren","???"];
		st_UiMsgLine4:=["of a collision.","es besteht Kollisionsgefahr!","???"];
		st_UiMsgLine5:=["Please ensure it is enabled!","Bitte schalten Sie die Absolutgenauigkeit wieder ein!","???"];
		UIMsgBox\Header:=st_UiHeader{n_Sp}, st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}\MsgLine3:=st_UiMsgLine3{n_Sp}
						\MsgLine4:=st_UiMsgLine4{n_Sp}\MsgLine5:=st_UiMsgLine5{n_Sp}\Buttons:=btnOK\Icon:=iconWarning;
	ENDIF

	n_PGNNumber_Mem:=n_PGNNumber;
	
	Reset SYS_do_ProgNumReq;
	SetGO PLC_go_WeldPoint_Num,0; 
	! aufruf des Programms / Call program number
	Set SYS_do_ApplRun;
	%"Program_"+NumToStr(n_PGNNumber,0)%;    
	Reset SYS_do_ApplRun;
ENDWHILE

ERROR
!** Error Handler**
! Fehlerbehandlung von nicht vorhandenen ProgNr. / None existant program number
SkipWarn;
IF ERRNO = ERR_REFUNKPRC THEN
    st_MsgBoxHeader:=["Com, Incorrect Program Number Call ","Com, Falsche Programm Nr. von der SPS!","???"];   
    st_Dummy:=["The Routine called Program_"+ValToStr (n_PGNNumber),"Keine Routine Program_"+ValToStr (n_PGNNumber),"???"];
    st_Dummy2:=["was requested but is not programmed!!","im System vorhanden !","???"];
    st_MsgBoxbutton4:=["OK","Ok","???"];
    n_MsgBoxApplError:=0;
    n_MsgBoxPLC_Error:=31;
    st_MsgBoxElogLine4:="ComBase/InitAutoMode";
    MsgBox\diBreakSignal:=SYS_di_ErrReset\Line1:=st_Dummy{n_Sp}\Line2:=st_Dummy2{n_Sp}\ErrorToPLC;
  	TRYNEXT;
ENDIF
SkipWarn;
IF ERRNO = ERR_TP_DOBREAK TRYNEXT;
IF ERRNO = ERR_TP_DIBREAK TRYNEXT;
ENDPROC !(InitAutoMode)

!*******************************************************************************

PROC InitMain()
!**********************
!* Procedure InitMain *
!*   Intialise Main   *
!**********************
! Prozedur zum Initialisieren von Ein-, Ausgaengen, Variabelen / Procedure to initialize inputs, outputs, variables
! Procedur wird 1x im Main aufgerufen / First procedure called from main
 VAR bool b_ComDummy:=FALSE;
 VAR num n_ComDummy:=0;
! 
 Reset SYS_do_ProgNumReq;
 Reset SYS_do_ApplRun;
 SetGO PLC_go_ErrCode, 0;
 Reset PLC_do_MsgToPLC;
 Reset PLC_do_ErrorToPLC;
 Reset PLC_do_StopToPLC;
 Reset PLC_do_CollZoneClear;
 Reset PLC_do_CollZoneReq;
 SetGO PLC_go_CollZone, 0;
 
 CollSafetyInit;
 b_AutoOff:=FALSE;
 n_JobReqNum:=0;
 n_JobFinNum:=0;
 b_JobF_w:=FALSE;
 b_JobR_w:=FALSE;
 !
 Reset PLC_do_Job01_Ready;
 Reset PLC_do_Job02_Ready;
 Reset PLC_do_Job03_Ready;
 Reset PLC_do_Job04_Ready;
 Reset PLC_do_Job05_Ready;
 Reset PLC_do_Job06_Ready;
 Reset PLC_do_Job07_Ready;
 Reset PLC_do_Job08_Ready;
 Reset PLC_do_Job09_Ready;
 Reset PLC_do_Job10_Ready;
 Reset PLC_do_Job11_Ready;
 Reset PLC_do_Job12_Ready;
 Reset PLC_do_Job13_Ready;
 Reset PLC_do_Job14_Ready;
 Reset PLC_do_Job15_Ready;
 Reset PLC_do_Job16_Ready;
 Reset PLC_do_Job17_Ready;
 Reset PLC_do_Job18_Ready;
 Reset PLC_do_Job19_Ready;
 Reset PLC_do_Job20_Ready;
 Reset PLC_do_Job21_Ready;
 Reset PLC_do_Job22_Ready;
 Reset PLC_do_Job23_Ready;
 Reset PLC_do_Job24_Ready;
 Reset PLC_do_Job25_Ready;
 Reset PLC_do_Job26_Ready;
 Reset PLC_do_Job27_Ready;
 Reset PLC_do_Job28_Ready;
 Reset PLC_do_Job29_Ready;
 Reset PLC_do_Job30_Ready;
 Reset PLC_do_Job31_Ready;
 Reset PLC_do_Job32_Ready;
 !
 Reset PLC_do_Job01_Started;
 Reset PLC_do_Job02_Started;
 Reset PLC_do_Job03_Started;
 Reset PLC_do_Job04_Started;
 Reset PLC_do_Job05_Started;
 Reset PLC_do_Job06_Started;
 Reset PLC_do_Job07_Started;
 Reset PLC_do_Job08_Started;
 Reset PLC_do_Job09_Started;
 Reset PLC_do_Job10_Started;
 Reset PLC_do_Job11_Started;
 Reset PLC_do_Job12_Started;
 Reset PLC_do_Job13_Started;
 Reset PLC_do_Job14_Started;
 Reset PLC_do_Job15_Started;
 Reset PLC_do_Job16_Started;
 Reset PLC_do_Job17_Started;
 Reset PLC_do_Job18_Started;
 Reset PLC_do_Job19_Started;
 Reset PLC_do_Job20_Started;
 Reset PLC_do_Job21_Started;
 Reset PLC_do_Job22_Started;
 Reset PLC_do_Job23_Started;
 Reset PLC_do_Job24_Started;
 Reset PLC_do_Job25_Started;
 Reset PLC_do_Job26_Started;
 Reset PLC_do_Job27_Started;
 Reset PLC_do_Job28_Started;
 Reset PLC_do_Job29_Started;
 Reset PLC_do_Job30_Started;
 Reset PLC_do_Job31_Started;
 Reset PLC_do_Job32_Started;
 !
 Reset PLC_do_Typbit_01;
 Reset PLC_do_Typbit_02;
 Reset PLC_do_Typbit_03;
 Reset PLC_do_Typbit_04;
 Reset PLC_do_Typbit_05;
 Reset PLC_do_Typbit_06;
 Reset PLC_do_Typbit_07;
 Reset PLC_do_Typbit_08;
 Reset PLC_do_Typbit_09;
 Reset PLC_do_Typbit_10;
 Reset PLC_do_Typbit_11;
 Reset PLC_do_Typbit_12;
 Reset PLC_do_Typbit_13;
 Reset PLC_do_Typbit_14;
 Reset PLC_do_Typbit_15;
 Reset PLC_do_Typbit_16;
 Reset PLC_do_Typbit_17;
 Reset PLC_do_Typbit_18;
 Reset PLC_do_Typbit_19;
 Reset PLC_do_Typbit_20;
 Reset PLC_do_Typbit_21;
 Reset PLC_do_Typbit_22;
 Reset PLC_do_Typbit_23;
 Reset PLC_do_Typbit_24;
 Reset PLC_do_Typbit_25;
 Reset PLC_do_Typbit_26;
 Reset PLC_do_Typbit_27;
 Reset PLC_do_Typbit_28;
 Reset PLC_do_Typbit_29;
 Reset PLC_do_Typbit_30;
 Reset PLC_do_Typbit_31;
 Reset PLC_do_Typbit_32;
 
 Reset PLC_do_ServicePos;
 Reset PLC_do_Process_Complete;
 Reset PLC_do_WeldCount;
 
 !Set output as this robot does not use this output
 IF st_RobotType="ROB1_6620LX_1.90_150" Set SM1_do_Stopped;
 
 ! aufruf der einzelnen Init Appl / calling the individual Init Appl
 IF n_ApplMax >0 AND n_ApplMax< 31 THEN
   FOR I FROM 1 TO n_ApplMax DO
     IF st_Appl_Info{I,1}="" GOTO END_InitAppl;
     b_ComDummy:=StrToVal(st_Appl_Info{I,1},n_ComDummy);
     %"InitAppl"+NumToStr(n_ComDummy,0)%;
   ENDFOR
 ENDIF
 END_InitAppl:
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO=ERR_REFUNKPRC TRYNEXT;
ENDPROC !(InitMain)

!*******************************************************************************

PROC JobRequest()
!*************************************************************
!* Befehl Jobanfrage an die SPS / Command Job request to PLC *
!* Trap-Routine                                              *
!*************************************************************
VAR signaldo PLC_JobStarted;
VAR string st_alias2;
CONST string st_C:="PLC_do_Job";
CONST string st_D:="_Started";
!
IF n_JobReqNum>0 THEN
	! Signalnamen erzeugen / signalname to procreate
	IF n_JobReqNum <10 THEN
		st_alias2 :=st_C+"0"+NumToStr(n_JobReqNum,0)+st_D;
	ELSE
		st_alias2 :=st_C+NumToStr(n_JobReqNum,0)+st_D;
	ENDIF
	AliasIO st_alias2, PLC_JobStarted;
	!
  	Set PLC_JobStarted;
ELSE
	! Fehler Jobnum = 0
	ErrWrite \W, "PLC, Trap JobRequest error", "JobNum = 0" ;
ENDIF
n_JobReqNum:=0;
b_JobR_w:=FALSE;
ENDPROC !(JobRequest)

!*******************************************************************************

PROC MoveJ_JobRequest (num Job,  robtarget ToPoint,  speeddata Speed,  zonedata Zone,  PERS tooldata Tool  \PERS wobjdata Wobj)
!*************************************************
!*   Command to call the  job request routine    *
!* synchronous from a joint type motion movement *
!*************************************************
VAR signaldi PLC_JobEnable;
VAR string st_alias;
CONST string st_A:="PLC_di_Job";
CONST string st_B:="_Enable";
! Wert check 1-32
CheckValue Job, 1, 32, 0, "Job Number";
! Signalnamen erzeugen / signalname to procreate
IF Job <10 THEN
	st_alias :=st_A+"0"+NumToStr(Job,0)+st_B;
ELSE
	st_alias :=st_A+NumToStr(Job,0)+st_B;
ENDIF
AliasIO st_alias, PLC_JobEnable;
!
! Programmablaufart pruefen / runmode check
IF (RunMode() = RUN_CONT_CYCLE) AND (PLC_JobEnable=1) AND (Zone <> fine) AND (b_JobR_w = FALSE)THEN 
	b_JobR_w:= TRUE;
	n_JobReqNum:=Job;
	! Aufruf von MoveXSync
	MoveJSync ToPoint,Speed,Zone,Tool\WObj?Wobj,"JobRequest";
ELSE
	! Fahre Punkt an
	MoveJ ToPoint,Speed,fine,Tool\WObj?Wobj;
	
	WHILE PLC_JobEnable=0 DO
      	st_UiHeader:=["Com,Waiting for Job Req ","Com, Warte auf Jobfreigabe ","???"];    
    	st_UiHeader_2:=[" from the PLC"," von der SPS","???"];
    	st_UiMsgLine1:=["Waiting for Signal ","Warte auf Signal ","???"];
    	st_UiMsgLine2:=["","","???"];
    	UIMsgBox\Header:=st_UiHeader{n_Sp}+ValToStr(Job)+st_UiHeader_2{n_Sp},st_UiMsgLine1{n_Sp}+st_alias+" = 1"\MsgLine2:=st_UiMsgLine2{n_Sp}
      			\Buttons:=btnNone\Icon:=iconInfo\DIBreak:=PLC_JobEnable;        
	ENDWHILE
	
	! pruefen ob bereits eine Anfrage laeuft
	WaitUntil b_JobR_w = FALSE \PollRate:=0.01;
	!***********************************
	!* Waiting for MoveSync to trigger *
	!***********************************
	
	n_JobReqNum:=Job;
	JobRequest;
ENDIF	
!    
BACKWARD
!
MoveJ ToPoint,Speed,fine,Tool\WObj?Wobj;
ERROR
!** Error Handler**
	SkipWarn;
 	IF ERRNO = ERR_TP_DIBREAK TRYNEXT;
ENDPROC !(MoveJ_JobRequest)

!*******************************************************************************

PROC MoveL_JobRequest (num Job,  robtarget ToPoint,  speeddata Speed,  zonedata Zone,  PERS tooldata Tool  \PERS wobjdata Wobj)
!*************************************************
!*   Command to call the  job request routine    *
!* synchronous from a joint type motion movement *
!*************************************************
VAR signaldi PLC_JobEnable;
VAR string st_alias;
CONST string st_A:="PLC_di_Job";
CONST string st_B:="_Enable";
! Wert check 1-32
CheckValue Job, 1, 32, 0, "Job Number";
! Signalnamen erzeugen / signalname to procreate
IF Job <10 THEN
	st_alias :=st_A+"0"+NumToStr(Job,0)+st_B;
ELSE
	st_alias :=st_A+NumToStr(Job,0)+st_B;
ENDIF
AliasIO st_alias, PLC_JobEnable;
!
! Programmablaufart pruefen / runmode check
IF (RunMode() = RUN_CONT_CYCLE) AND (PLC_JobEnable=1) AND (Zone <> fine) AND (b_JobR_w = FALSE)THEN 
	b_JobR_w:= TRUE;
	n_JobReqNum:=Job;
	! Aufruf von MoveXSync
	MoveLSync ToPoint,Speed,Zone,Tool\WObj?Wobj,"JobRequest";
ELSE
	! Fahre Punkt an
	MoveL ToPoint,Speed,fine,Tool\WObj?Wobj;
	
    WHILE PLC_JobEnable=0 DO
      	st_UiHeader:=["Com,Waiting Job Req ","Com, Warte auf Jobfreigabe ","???"];    
    	st_UiHeader_2:=[" from the PLC"," von der SPS","???"];
    	st_UiMsgLine1:=["Waiting for Signal ","Warte auf Signal ","???"];
    	st_UiMsgLine2:=["","","???"];
    	UIMsgBox\Header:=st_UiHeader{n_Sp}+ValToStr(Job)+st_UiHeader_2{n_Sp},st_UiMsgLine1{n_Sp}+st_alias+" = 1"\MsgLine2:=st_UiMsgLine2{n_Sp}
      			\Buttons:=btnNone\Icon:=iconInfo\DIBreak:=PLC_JobEnable;
	ENDWHILE

	! pruefen ob bereits eine Anfrage laeuft
	WaitUntil b_JobR_w = FALSE \PollRate:=0.01;
	!***********************************
	!* Waiting for MoveSync to trigger *
	!***********************************
	
	n_JobReqNum:=Job;
	JobRequest;
ENDIF	
!    
BACKWARD
!
MoveL ToPoint,Speed,fine,Tool\WObj?Wobj;
ERROR
!** Error Handler**
	SkipWarn;
 	IF ERRNO = ERR_TP_DIBREAK TRYNEXT;
ENDPROC !(MoveL_JobRequest)

!*******************************************************************************

PROC Job_Request (num Job \switch InAdvance )
!*************************************************
!*   Command to call the  job request routine    *
!*          without motion movement              *
!*************************************************
VAR signaldi PLC_JobEnable;
VAR string st_alias;
CONST string st_A:="PLC_di_Job";
CONST string st_B:="_Enable";
VAR errnum err_var;

! Wert check 1-32
CheckValue Job, 1, 32, 0, "Job Number";
! Signalnamen erzeugen / signalname to procreate

IF Job <10 THEN
	st_alias :=st_A+"0"+NumToStr(Job,0)+st_B;
ELSE
	st_alias :=st_A+NumToStr(Job,0)+st_B;
ENDIF

AliasIO st_alias, PLC_JobEnable;

if Present (InAdvance)<>TRUE THEN
    WaitRob\InPos;
    !*****************************
    !* Waiting Robot in position *
    !*****************************
ENDIF

WHILE PLC_JobEnable=0 DO
    st_UiHeader:=["Com,Waiting Job Req ","Com, Warte auf Jobfreigabe ","???"];    
    st_UiHeader_2:=[" from the PLC"," von der SPS","???"];
    st_UiMsgLine1:=["Waiting for Signal ","Warte auf Signal ","???"];
    st_UiMsgLine2:=["","","???"];
    UIMsgBox\Header:=st_UiHeader{n_Sp}+ValToStr(Job)+st_UiHeader_2{n_Sp},st_UiMsgLine1{n_Sp}+st_alias+" = 1"\MsgLine2:=st_UiMsgLine2{n_Sp}
    		\Buttons:=btnNone\Icon:=iconInfo\DIBreak:=PLC_JobEnable;
ENDWHILE

n_JobReqNum:=Job;
JobRequest;
   
BACKWARD

ERROR
!** Error Handler**
	SkipWarn;
 	IF ERRNO = ERR_TP_DIBREAK TRYNEXT;
ENDPROC !(MoveJ_JobRequest)

!*******************************************************************************

PROC Job_Finished (num Job)
!*************************************************
!*   Command to call the  job finished routine   *
!*           without  motion movement            *
!*************************************************

CheckValue Job, 1, 32, 0, "Job Number";

WaitRob\InPos;
!*****************************
!* Waiting Robot in position *
!*****************************

! Ausgang setzen
n_JobFinNum:=Job;
JobFinished;  

ENDPROC !(Job_Finished)

!*******************************************************************************

PROC JobFinished()
!***********************************************
!* Job Endemeldung an die SPS 1-32 TrapRoutine *
!*  Job finished communication routine to PLC  *
!***********************************************
VAR signaldo PLC_JobStarted;
VAR signaldo PLC_JobReady;
VAR string st_alias;
VAR string st_alias2;
CONST string st_A:="PLC_do_Job";
CONST string st_B:="_Started";
CONST string st_C:="_Ready";
!
IF n_JobFinNum>0 THEN
	! Signalnamen zusammensetzen
	IF n_JobFinNum <10 THEN
  		st_alias :=st_A+"0"+NumToStr(n_JobFinNum ,0)+st_B;
  		st_alias2 :=st_A+"0"+NumToStr(n_JobFinNum ,0)+st_C;
	ELSE
  		st_alias :=st_A+NumToStr(n_JobFinNum ,0)+st_B;
  		st_alias2 :=st_A+NumToStr(n_JobFinNum ,0)+st_C;
	ENDIF
    
	! Aliaszuweisen
	AliasIO st_alias, PLC_JobStarted;
	AliasIO st_alias2, PLC_JobReady;
    
	! Ausgang setzen
	Reset PLC_JobStarted;
	Set PLC_JobReady;
ELSE
  ! Fehler Jobnum = 0
  ErrWrite \W, "PLC, Trap JobFinished error", "JobNum = 0" ;
ENDIF

n_JobFinNum:=0;
b_JobF_w:=FALSE;
ENDPROC !(JobFinished)

!*******************************************************************************

PROC MoveJ_JobFinished (num Job,  robtarget ToPoint,  speeddata Speed,  zonedata Zone,  PERS tooldata Tool  \PERS wobjdata Wobj)
!*************************************************
!*   Command to call the  job finished routine   *
!* synchronous from a joint type motion movement *
!*************************************************
!
CheckValue Job, 1, 32, 0, "Job Number";
!
! Programmablaufart pruefen / runmode check
IF (RunMode() = RUN_CONT_CYCLE) AND (Zone <> fine) AND (b_JobF_w = FALSE)THEN 
	b_JobF_w:= TRUE;
	n_JobFinNum:=Job;
	! Aufruf von MoveXSync
	MoveJSync ToPoint,Speed,Zone,Tool\WObj?Wobj,"JobFinished";
ELSE
	! Fahre Punkt an
	MoveJ ToPoint,Speed,fine,Tool\WObj?Wobj;
	! pruefen ob bereits eine Anfrage laeuft
	WaitUntil b_JobF_w = FALSE \PollRate:=0.01;
	! Ausgang setzen
	n_JobFinNum:=Job;
	JobFinished;
ENDIF	
!    
BACKWARD
!
MoveJ ToPoint,Speed,fine,Tool\WObj?Wobj;
!
ENDPROC !(MoveJ_JobFinished)

!*******************************************************************************

PROC MoveL_JobFinished (num Job, robtarget ToPoint, speeddata Speed, zonedata Zone,  PERS tooldata Tool \PERS wobjdata Wobj)
!**************************************************
!* Command to call the  job finished routine      *
!* synchronous from a Linear type motion movement *
!**************************************************
!
CheckValue Job, 1, 32, 0, "Job Number";
!
! Programmablaufart pruefen / runmode check
IF (RunMode() = RUN_CONT_CYCLE) AND (Zone <> fine) AND (b_JobF_w = FALSE)THEN 
	b_JobF_w:= TRUE;
	n_JobFinNum:=Job;
	! Aufruf von MoveXSync
	MoveLSync ToPoint,Speed,Zone,Tool\WObj?Wobj,"JobFinished";
ELSE
	! Fahre Punkt an
	MoveL ToPoint,Speed,fine,Tool\WObj?Wobj;
	! pruefen ob bereits eine Anfrage laeuft
	WaitUntil b_JobF_w = FALSE \PollRate:=0.01;
	! Ausgang setzen
	n_JobFinNum:=Job;
	JobFinished;
ENDIF	
!    
BACKWARD
!
MoveL ToPoint,Speed,fine,Tool\WObj?Wobj;
!
ENDPROC !(MoveL_JobFinished)

!*******************************************************************************

PROC MoveJ_ProcessComplete (robtarget ToPoint, speeddata Speed, zonedata Zone,  PERS tooldata Tool \PERS wobjdata Wobj)
!*************************************************
!* Command to call the  rocess complete routine  *
!* synchronous from a joint type motion movement *
!*************************************************

! Programmablaufart pruefen / runmode check
IF (RunMode() = RUN_CONT_CYCLE) AND (Zone <> fine) THEN 
	MoveJSync ToPoint,Speed,Zone,Tool\WObj?Wobj,"ProcessComplete";
ELSE
	MoveJ ToPoint,Speed,fine,Tool\WObj?Wobj;
    ProcessComplete;
ENDIF	
    
BACKWARD

MoveJ ToPoint,Speed,fine,Tool\WObj?Wobj;

ENDPROC !(MoveJ_ProcessComplete)

!*******************************************************************************

PROC ProcessComplete(\SWITCH  Inpos)
!***************************************************
!*  Process complete communication routine to PLC  *
!***************************************************

IF Present(Inpos) Waittime\InPos,0;

PulseDO\High\PLength:=2.0,PLC_do_Process_Complete;

ENDPROC !(ProcessComplete)

!*******************************************************************************

PROC CollSafetyInit()
!*************************************
!* Intialise Robot collision Control *
!*************************************
  VAR bool b_TimeOut;
  !
  n_CollClZ:=1;
  WaitTime \Inpos, 0.01;
  Reset PLC_do_CollZoneClear;
  Reset PLC_do_CollZoneReq;
  SetGO PLC_go_CollZone, 0;
  ! zum testen mit RobotStudio
  IF NOT RobOS()THEN
    FOR i FROM 1 TO 63 DO  
    b_CollZoneOccupied{i}:=FALSE;
  ENDFOR
  RETURN;
  ENDIF ! zum testen mit RobotStudio
  WaitGI PLC_gi_CollZone, 0\MaxTime:=3;
  !********************************************************
  !* Waiting for PLC to set Collision zone number to zero *
  !********************************************************
  !
  WHILE GInput(PLC_gi_CollZone)>0 DO
		st_MsgBoxHeader:=["Com, CollSafetyInit","Com, CollSafetyInit","???"];
		st_MsgBoxLine3:=["Waiting for PLC to send collision zone Nr=0.","Rueckmeldung der Kollisionszone ","???"];
		st_MsgBoxLine4:=["","ist nicht Null","???"];
		st_MsgBoxLine5:=["Check the state at the PLC.","Ueberpruefe den Status an der SPS","???"];
		st_MsgBoxGeraeteName:=["CollSafetyInit","CollSafetyInit","???"];
		n_MsgBoxGeraeteNr:=1;
		st_MsgBoxSignal:="PLC_gi_CollZone";
		st_MsgBoxSignalValue:="0";
		n_MsgBoxApplError:=1;
		n_MsgBoxPLC_Error:=52;
		st_MsgBoxElogLine4:="ComBase/CollSafetyInit";
		MsgBox \diBreakSignal:=SYS_di_ErrReset\ErrorToPLC;
  ENDWHILE
  !
  SetGO PLC_go_CollZone, 63;
  WaitGI PLC_gi_CollZone, 63\MaxTime:=3;
  !****************************************************** 
  !* Waiting for PLC to set Collision zone number to 63 *
  !******************************************************

  WHILE GInput(PLC_gi_CollZone)<>63 DO
		st_MsgBoxHeader:=["Com, CollSafetyInit","Com, CollSafetyInit","???"];
		st_MsgBoxLine3:=["Waiting for the PLC to send collision zone Nr=63.","Rueckmeldung der Kollisionsschutzzone ","???"];
		st_MsgBoxLine4:=["","ist nicht 63","???"];
		st_MsgBoxLine5:=["Check the state at the PLC.","Ueberpruefe den Status an der SPS","???"];
		st_MsgBoxGeraeteName:=["CollSafetyInit","CollSafetyInit","???"];
		n_MsgBoxGeraeteNr:=1;
		st_MsgBoxSignal:="PLC_gi_CollZone";
		st_MsgBoxSignalValue:="63";
		n_MsgBoxApplError:=2;
		n_MsgBoxPLC_Error:=53;
		st_MsgBoxElogLine4:="ComBase/CollSafetyInit";
		MsgBox \diBreakSignal:=SYS_di_ErrReset\ErrorToPLC;
  ENDWHILE
  !
  Set PLC_do_CollZoneClear;
  !
  WaitDI PLC_di_CollZoneRel,1\MaxTime:=3\TimeFlag:=b_TimeOut;
  !******************************************************
  !* Waiting for Collsion zone release signal from PLC  *
  !******************************************************
  WHILE PLC_di_CollZoneRel=0 DO
		st_MsgBoxHeader:=["Com, CollSafetyInit","Com, CollSafetyInit","???"];
		st_MsgBoxLine3:=["Waiting for Collison Zone release from the PLC.","Kollisionsschutz Strobe","???"];
		st_MsgBoxLine4:=["","ist nicht 1","???"];
		st_MsgBoxLine5:=["Check the state at the PLC.","Ueberpruefe den Status an der SPS","???"];
		st_MsgBoxGeraeteName:=["CollSafetyInit","CollSafetyInit","???"];
		n_MsgBoxGeraeteNr:=1;
		st_MsgBoxSignal:="PLC_di_CollZoneRel";
		st_MsgBoxSignalValue:="1";
		n_MsgBoxApplError:=3;
		n_MsgBoxPLC_Error:=54;
		st_MsgBoxElogLine4:="ComBase/CollSafetyInit";
		MsgBox \diBreakSignal:=SYS_di_ErrReset\ErrorToPLC;
  ENDWHILE
  Reset PLC_do_CollZoneClear;
  !
  SetGO PLC_go_CollZone, 0;
  !
  WaitDI PLC_di_CollZoneRel,0\MaxTime:=3\TimeFlag:=b_TimeOut;
  !***************************************************************
  !* Waiting for Collsion zone release signal from PLC to be off *
  !***************************************************************
  WHILE PLC_di_CollZoneRel=1 DO
		st_MsgBoxHeader:=["Com, CollSafetyInit","Com, CollSafetyInit","???"];
		st_MsgBoxLine3:=["Waiting for collison zone release from PLC to be off.","Kollisionsschutz Strobe","???"];
		st_MsgBoxLine4:=["","ist nicht 0","???"];
		st_MsgBoxLine5:=["Check the state at the PLC.","Ueberpruefe den Status an der SPS","???"];
		st_MsgBoxGeraeteName:=["CollSafetyInit","CollSafetyInit","???"];
		n_MsgBoxGeraeteNr:=1;
		st_MsgBoxSignal:="PLC_di_CollZoneRel";
		st_MsgBoxSignalValue:="0";
		n_MsgBoxApplError:=4;
		n_MsgBoxPLC_Error:=55;
		st_MsgBoxElogLine4:="ComBase/CollSafetyInit";
		MsgBox \diBreakSignal:=SYS_di_ErrReset\ErrorToPLC;
  ENDWHILE
  !
  FOR i FROM 1 TO 63 DO  
    b_CollZoneOccupied{i}:=FALSE;
  ENDFOR
  !
  b_CollClearAct:=FALSE;
  !
ERROR
!** Error Handler**
SkipWarn;
IF ERRNO = ERR_WAIT_MAXTIME TRYNEXT; 
ENDPROC !(CollSafetyInit)

!*******************************************************************************

PROC CollSafetyRequest(num Coll,String Coll_Descr)
 !*************************************************************
 !* Befehl Anforderung einer Kollisionszone                   *
 !* uebergebene Parameter: num Coll Nummer der Kollisionszone *
 !* Command Collision Zone request Control                    *
 !*************************************************************
 VAR btnres br_UiAnswer;
 VAR bool b_TimeOut;
 VAR errnum errno1;
 VAR Dnum dn_Coll ;
 
 !Convert Collision zone type num to Dnum
 dn_Coll:=NumToDnum(Coll);
 
 !ueberpruefung ob schon Angefragt / Check if collision zone already requested
 
 IF b_CollZoneOccupied{Coll}=TRUE THEN
  	st_MsgBoxHeader:=["Com, CollSafetyRequest Error!","Com, Kollisionsschutzanfrage Fehler!","???"];
	IF OpMode()= OP_MAN_PROG THEN
 		st_UiMsgLine1:=["","","???"];
 		st_UiMsgLine2:=["The ","Fehlerhafte Anfrage fuer ","???"];
		st_UiMsgLine3:=["has already been requested before.","Bereich ist bereits Angefragt! ","???"];
		st_UiMsgLine4:=[" ","ueberpruefe auf eine doppelte Anfrage","???"];
		st_UiMsgLine5:=["Please select 'OK' to continue.","Achtung: Anfragen wird abgebrochen!","???"];
	
		UIMsgBox\Header:=st_MsgBoxHeader{n_Sp},st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}+"CollZone= "+NumToStr(Coll,0)
			\MsgLine3:=st_UiMsgLine3{n_Sp}\MsgLine4:=st_UiMsgLine4{n_Sp}\MsgLine5:=st_UiMsgLine5{n_Sp}
			\Buttons:=btnOK\Icon:=iconWarning\Result:=br_UiAnswer;
  	ELSE
     	WHILE b_CollZoneOccupied{Coll}=TRUE DO 
     		st_Dummy:=["CollZone= ","CollZone= ","???"];
     		st_Dummy2:=["has been already requested.","bereits angefragt !","???"];
     		st_MsgBoxLine3:=["Incorrect request, only allowed in manual mode.","Fehlerhafte Anfrage kann nur im Handbetrieb und","???"];
			st_MsgBoxLine4:=["Reset the program pointer and","mit neu setzen des Prog.-Zeigers abgebrochen werden.","???"];
			st_MsgBoxLine5:=["check program!","Programmablauf ueberpuefen!!!","???"];
			st_MsgBoxbutton4:=["Ok","Ok","???"];
     		n_MsgBoxApplError:=5;
     		n_MsgBoxPLC_Error:=50;
     		st_MsgBoxElogLine4:="ComBase/CollSafetyRequest";
    
			MsgBox\diBreakSignal:=SYS_di_ErrReset\Line1:=st_Dummy{n_Sp}+NumToStr(Coll,0)\Line2:=st_Dummy2{n_Sp}\ErrorToPLC;		
     	ENDWHILE
   	ENDIF
 ENDIF !b_CollZoneOccupied{Coll}
 
 !Warten bis vorherige Bearbeitung erledigt\Wait until done prior processing
 
WaitUntil b_CollClearAct=FALSE\MaxTime:=3\TimeFlag:=b_TimeOut;
!****************************************************
!* Waiting for previous collision clear to complete * 
!****************************************************

 WHILE b_CollClearAct=TRUE DO
	st_UiHeader:=["Com, CollZoneClearError","Com, CollZoneClearError","???"];    
	st_UiMsgLine2:=["MoveXCollReq: Wait b_CollClearAct=FALSE","MoveXCollReq: Warte auf b_CollClearAct=FALSE","???"];
	st_UiMsgLine3:=["The previous clear function has not been finished yet","Das vorherige Freigeben der Zone ist noch nicht abgeschlossen!","???"];
	UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}\MsgLine3:=st_UiMsgLine3{n_Sp}
		\Buttons:=btnNone\Icon:=iconWarning\MaxTime:=1.5\BreakFlag:=errno1;
 ENDWHILE
 
 CollSafetyComFin;

WHILE  PLC_gi_CollZone<>Coll  OR PLC_di_CollZoneFree<>1 DO
     SetGO PLC_go_CollZone, Coll;
     
    IF b_ColOption Set PLC_do_CollZoneReq;

     WaitGI PLC_gi_CollZone, Coll\MaxTime:=3;
     !******************************************************
     !*  Waiting for PLC to confirm Collision Zone number  *
     !******************************************************

    !Ensure user string is capped below 41 characters
    IF StrLen(Coll_Descr)>40  Coll_Descr := StrPart(Coll_Descr,1,40);

    IF StrLen(Coll_Descr)>6 THEN
    	st_UiMsgLine4:=["with robots " + Coll_Descr,"mit Robotern" + Coll_Descr,"???"];
    ELSEIF StrLen(Coll_Descr)>2 THEN
    	st_UiMsgLine4:=["with robot " + Coll_Descr,"mit Roboter" + Coll_Descr,"???"];
    ELSE
    	st_UiMsgLine4:=["","","???"];
    ENDIF
     
     WHILE GInput(PLC_gi_CollZone)<>Coll DO
    	MsgBoxBreak "PLC_gi_CollZone",dn_Coll;
    	
    	st_UiHeader:=["Com, CollSafetyRequest","Com, Kollisionsschutzanfrage","???"];
    	st_UiMsgLine1:=["Waiting for PLC_gi_CollZone = ","Warte auf PLC_gi_CollZone = ","???"];
    	st_UiMsgLine2:=["","","???"];
    	st_UiMsgLine3:=["Waiting for collison zone Nr=","Warte auf angefragte Kollisionszone Nr=","???"];
    	
    	UIMsgBox\Header:=st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp}+NumToStr(Coll,0)\MsgLine2:=st_UiMsgLine2{n_Sp}
    		\MsgLine3:=st_UiMsgLine3{n_Sp}+NumToStr(Coll,0)\MsgLine4:=st_UiMsgLine4{n_Sp}\Buttons:=btnNone\Icon:=iconInfo\diBreak:=VB_di_MsgBoxBrk1\BreakFlag:=errno1;
     ENDWHILE
     
    Set PLC_do_CollZoneReq;
 
     WaitDI PLC_di_CollZoneFree,1\MaxTime:=3\TimeFlag:=b_TimeOut;
     !**************************************************
     !* Waiting for Collsion zone Free signal from PLC *
     !**************************************************
     
     WHILE PLC_di_CollZoneFree=0 DO
    	st_UiHeader:=["Com, CollSafetyRequest","Com, Kollisionsschutzanfrage","???"];
    	st_UiMsgLine1:=["Waiting for collision zone free signal from PLC. PLC_di_CollZoneFree=1","Warte auf  PLC_di_CollZoneFree=1","???"];
    	st_UiMsgLine2:=["","","???"];
    	st_UiMsgLine3:=["The collision zone requested = ","fuer die angefragte Kollisionszone = ","???"];
    	UIMsgBox\Header:=st_UiHeader{n_Sp},MsgLine1:=st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}\MsgLine3:=st_UiMsgLine3{n_Sp}+NumToStr(Coll,0)
    		\MsgLine4:=st_UiMsgLine4{n_Sp}\Buttons:=btnNone\Icon:=iconInfo\DIBreak:=PLC_di_CollZoneFree\BreakFlag:=errno1;
    ENDWHILE
ENDWHILE

b_CollZoneOccupied{Coll}:=TRUE;
 
 Reset PLC_do_CollZoneReq;
 SetGO PLC_go_CollZone, 0;

IF b_ColOption <>TRUE THEN
     WaitDI PLC_di_CollZoneFree,0\MaxTime:=3\TimeFlag:=b_TimeOut;
     !************************************************************
     !* Waiting for Collsion zone Free signal from PLC to be off *
     !************************************************************
     
     WHILE PLC_di_CollZoneFree=1 DO
     	MsgBoxBreak "PLC_di_CollZoneFree",0;
     
    	st_UiHeader:=["Com, CollSafetyRequest","Com, Kollisionsschutzanfrage","???"];
    	st_UiMsgLine2:=["Waiting for Collision zone free signal to be off. PLC_di_CollZoneFree=0","Warte auf PLC_di_CollZoneFree=0","???"];
    	UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}
    		\Buttons:=btnNone\Icon:=iconInfo\diBreak:=VB_di_MsgBoxBrk1\BreakFlag:=errno1;
     ENDWHILE 
ENDIF

 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO = ERR_WAIT_MAXTIME TRYNEXT;
 IF ERRNO = ERR_TP_DOBREAK TRYNEXT;
 IF ERRNO = ERR_TP_DIBREAK TRYNEXT;
ENDPROC !(CollSafetyRequest)

!*******************************************************************************

PROC MoveJ_CollReq(  num Coll,  \num Coll_B  \num Coll_C  \num Coll_D  \num Coll_E,  robtarget ToPoint,  speeddata Speed,  zonedata Zone,  PERS tooldata Tool  \PERS wobjdata Wobj\String Coll_Desc\String Coll_Desc_B\String Coll_Desc_C\String Coll_Desc_D\String Coll_Desc_E\switch Conc)
 !***********************************************************************
 !*              Collision zone request with a MoveJ                    *
 !***********************************************************************
 !
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
 
  IF Present (Conc) THEN
    MoveJ\Conc, ToPoint,Speed,Zone,Tool\WObj?Wobj;
 ELSE
    MoveJ ToPoint,Speed,Zone,Tool\WObj?Wobj;
 ENDIF
 
 IF Present(Coll_Desc) THEN
 	CollSafetyRequest Coll,Coll_Desc;
 ELSE
 	CollSafetyRequest Coll,"";
 ENDIF

 IF Present(Coll_Desc_B) THEN
 	IF Present(Coll_B) CollSafetyRequest Coll_B,Coll_Desc_B;
 ELSE
 	IF Present(Coll_B) CollSafetyRequest Coll_B,"";
 ENDIF

 IF Present(Coll_Desc_C) THEN
 	IF Present(Coll_C) CollSafetyRequest Coll_C,Coll_Desc_C;
 ELSE
 	IF Present(Coll_C) CollSafetyRequest Coll_C,"";
 ENDIF

IF Present(Coll_Desc_D) THEN
 	IF Present(Coll_D) CollSafetyRequest Coll_D,Coll_Desc_D;
ELSE
 	IF Present(Coll_D) CollSafetyRequest Coll_D,"";
ENDIF

IF Present(Coll_Desc_E) THEN
	IF Present(Coll_E) CollSafetyRequest Coll_E,Coll_Desc_E;
ELSE
	IF Present(Coll_E) CollSafetyRequest Coll_E,""; 
ENDIF
 
BACKWARD
 !
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
 !
 MoveJ ToPoint,Speed,fine,Tool\WObj?Wobj;
 !
 FOR i FROM 1 TO 5 DO  
   n_Coll{i}:=0;
 ENDFOR
 !
 n_CollClZ:=1;
 n_Coll{1}:=Coll;
 !
 IF Present(Coll_B) THEN
   Incr n_CollClZ;
   n_Coll{2}:=Coll_B;
 ENDIF
 !
 IF Present(Coll_C) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_C;
   ELSE  
     n_Coll{3}:=Coll_C;
   ENDIF
 ENDIF
 ! 
 IF Present(Coll_D) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_D;
   ELSE
     IF n_Coll{3}=0 THEN  
        n_Coll{3}:=Coll_D;
     ELSE
        n_Coll{4}:=Coll_D;
     ENDIF 
   ENDIF
 ENDIF 
 !
 IF Present(Coll_E) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_E;
   ELSE
     IF n_Coll{3}=0 THEN  
       n_Coll{3}:=Coll_E;
     ELSE
       IF n_Coll{4}=0 THEN
         n_Coll{4}:=Coll_E;
       ELSE
         n_Coll{5}:=Coll_E;
       ENDIF 
     ENDIF 
   ENDIF
 ENDIF
 !
 CollSafetyClear;
 !
ENDPROC !(MoveJ_CollReq)

!*******************************************************************************

PROC MoveL_CollReq(  num Coll,  \num Coll_B  \num Coll_C  \num Coll_D  \num Coll_E,  robtarget ToPoint,  speeddata Speed,  zonedata Zone,  PERS tooldata Tool  \PERS wobjdata Wobj\String Coll_Desc\String Coll_Desc_B\String Coll_Desc_C\String Coll_Desc_D\String Coll_Desc_E\switch Conc)
 !*********************************************************
 !*                  Befehl MoveL_CollClr                 *
 !*  Command MoveL with Triggering of CollSafety Request  *
 !*********************************************************
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
 
 IF Present (Conc) THEN
    MoveL\Conc, ToPoint,Speed,Zone,Tool\WObj?Wobj;
 ELSE
    MoveL ToPoint,Speed,Zone,Tool\WObj?Wobj;
 ENDIF
 
 IF Present(Coll_Desc) THEN
 	CollSafetyRequest Coll,Coll_Desc;
 ELSE
 	CollSafetyRequest Coll,"";
 ENDIF

 IF Present(Coll_Desc_B) THEN
 	IF Present(Coll_B) CollSafetyRequest Coll_B,Coll_Desc_B;
 ELSE
 	IF Present(Coll_B) CollSafetyRequest Coll_B,"";
 ENDIF

 IF Present(Coll_Desc_C) THEN
 	IF Present(Coll_C) CollSafetyRequest Coll_C,Coll_Desc_C;
 ELSE
 	IF Present(Coll_C) CollSafetyRequest Coll_C,"";
 ENDIF

IF Present(Coll_Desc_D) THEN
 	IF Present(Coll_D) CollSafetyRequest Coll_D,Coll_Desc_D;
ELSE
 	IF Present(Coll_D) CollSafetyRequest Coll_D,"";
ENDIF

IF Present(Coll_Desc_E) THEN
	IF Present(Coll_E) CollSafetyRequest Coll_E,Coll_Desc_E;
ELSE
	IF Present(Coll_E) CollSafetyRequest Coll_E,""; 
ENDIF
 
 BACKWARD
 !
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
 !
 MoveL ToPoint,Speed,fine,Tool\WObj?Wobj;
 !
 FOR i FROM 1 TO 5 DO  
   n_Coll{i}:=0;
 ENDFOR
 !
 n_CollClZ:=1;
 n_Coll{1}:=Coll;
 !
 IF Present(Coll_B) THEN
   Incr n_CollClZ;
   n_Coll{2}:=Coll_B;
 ENDIF
 !
 IF Present(Coll_C) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_C;
   ELSE  
     n_Coll{3}:=Coll_C;
   ENDIF
 ENDIF
 ! 
 IF Present(Coll_D) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_D;
   ELSE
     IF n_Coll{3}=0 THEN  
       n_Coll{3}:=Coll_D;
     ELSE
       n_Coll{4}:=Coll_D;
     ENDIF 
   ENDIF
 ENDIF 
 !
 IF Present(Coll_E) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_E;
   ELSE
     IF n_Coll{3}=0 THEN  
       n_Coll{3}:=Coll_E;
     ELSE
       IF n_Coll{4}=0 THEN
         n_Coll{4}:=Coll_E;
       ELSE
         n_Coll{5}:=Coll_E;
       ENDIF 
     ENDIF 
   ENDIF
 ENDIF
 !
 CollSafetyClear;
 !
ENDPROC !(MoveL_CollReq)

!*******************************************************************************

PROC Coll_Request(  num Coll,  \num Coll_B  \num Coll_C  \num Coll_D  \num Coll_E,String Coll_Desc\String Coll_Desc_B\String Coll_Desc_C\String Coll_Desc_D\String Coll_Desc_E)
 !***********************************************************************
 !*          Collision zone request without motion points               *
 !***********************************************************************
 
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
  
 IF Present(Coll_Desc) THEN
 	CollSafetyRequest Coll,Coll_Desc;
 ELSE
 	CollSafetyRequest Coll,"";
 ENDIF

 IF Present(Coll_Desc_B) THEN
 	IF Present(Coll_B) CollSafetyRequest Coll_B,Coll_Desc_B;
 ELSE
 	IF Present(Coll_B) CollSafetyRequest Coll_B,"";
 ENDIF

 IF Present(Coll_Desc_C) THEN
 	IF Present(Coll_C) CollSafetyRequest Coll_C,Coll_Desc_C;
 ELSE
 	IF Present(Coll_C) CollSafetyRequest Coll_C,"";
 ENDIF

IF Present(Coll_Desc_D) THEN
 	IF Present(Coll_D) CollSafetyRequest Coll_D,Coll_Desc_D;
ELSE
 	IF Present(Coll_D) CollSafetyRequest Coll_D,"";
ENDIF

IF Present(Coll_Desc_E) THEN
	IF Present(Coll_E) CollSafetyRequest Coll_E,Coll_Desc_E;
ELSE
	IF Present(Coll_E) CollSafetyRequest Coll_E,""; 
ENDIF
 
BACKWARD
 
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
 
  FOR i FROM 1 TO 5 DO  
   n_Coll{i}:=0;
 ENDFOR
 
 n_CollClZ:=1;
 n_Coll{1}:=Coll;
 
 IF Present(Coll_B) THEN
   Incr n_CollClZ;
   n_Coll{2}:=Coll_B;
 ENDIF
 
 IF Present(Coll_C) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_C;
   ELSE  
     n_Coll{3}:=Coll_C;
   ENDIF
 ENDIF
  
 IF Present(Coll_D) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_D;
   ELSE
     IF n_Coll{3}=0 THEN  
        n_Coll{3}:=Coll_D;
     ELSE
        n_Coll{4}:=Coll_D;
     ENDIF 
   ENDIF
 ENDIF 
 
 IF Present(Coll_E) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_E;
   ELSE
     IF n_Coll{3}=0 THEN  
       n_Coll{3}:=Coll_E;
     ELSE
       IF n_Coll{4}=0 THEN
         n_Coll{4}:=Coll_E;
       ELSE
         n_Coll{5}:=Coll_E;
       ENDIF 
     ENDIF 
   ENDIF
 ENDIF
 
 CollSafetyClear;
 
ENDPROC !(Coll_Request)

!*******************************************************************************

PROC CollSafetyComFin()
 !*************************************************************
 !*  Prozedur Kollisions Kommunikation mit SPS abgearbeitet   *
 !*            uebergebene Parameter: keine                   *
 !*            Collision Zone Control Complete                *
 !*************************************************************
 VAR bool b_TimeOut;
 VAR errnum errno1;  

 !Request beendet\Request completed
 WaitDO PLC_do_CollZoneReq,0\MaxTime:=3\TimeFlag:=b_TimeOut;
 !*************************************************************
 !* Waiting for Collsion zone Requset output to PLC to be off *
 !*************************************************************
 
 WHILE DOutput(PLC_do_CollZoneReq)=1 DO
 	MsgBoxBreak "PLC_do_CollZoneReq",0;

	st_UiHeader:=["Com, CollSafetyComFin","Com, CollSafetyComFin","???"];
	st_UiMsgLine2:=["Waiting for Collision Zone Request output to be off. PLC_do_CollZoneReq=0","Warte auf PLC_do_CollZoneReq=0","???"];
	UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}
		\Buttons:=btnNone\Icon:=iconInfo\DIBreak:=VB_di_MsgBoxBrk1\BreakFlag:=errno1;	
 ENDWHILE
 
 WaitDI PLC_di_CollZoneFree,0\MaxTime:=3\TimeFlag:=b_TimeOut;
 !************************************************************
 !* Waiting for Collsion zone Free signal from PLC to be off *
 !************************************************************
 
 WHILE PLC_di_CollZoneFree=1 DO
 	MsgBoxBreak "PLC_di_CollZoneFree",0;
	
	st_UiHeader:=["Com, CollSafetyComFin","Com, CollSafetyComFin","???"];
	st_UiMsgLine2:=["Waiting for collision zone free from PLC to be off. PLC_di_CollZoneFree=0","Warte auf PLC_di_CollZoneFree=0","???"];
	UIMsgBox\Header:=st_UiHeader{n_Sp}, ""\MsgLine2:=st_UiMsgLine2{n_Sp}\Buttons:=btnNone\Icon:=iconInfo\DIBreak:=VB_di_MsgBoxBrk1\BreakFlag:=errno1;
 ENDWHILE
 
 !Clear beendet / Clear finished
 WaitDO PLC_do_CollZoneClear,0\MaxTime:=3\TimeFlag:=b_TimeOut;
 !*************************************************************
 !* Waiting for Collsion zone Clear signal from PLC to be off *
 !*************************************************************
 
 WHILE DOutput(PLC_do_CollZoneClear)=1 DO
 	MsgBoxBreak "PLC_do_CollZoneClear",0;

	st_UiHeader:=["Com, CollSafetyComFin","Com, CollSafetyComFin","???"];
	st_UiMsgLine2:=["Waiting for collision zone clear from PLC to be off. PLC_do_CollZoneClear=0","Warte auf PLC_do_CollZoneClear=0","???"];
	UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}
		\Buttons:=btnNone\Icon:=iconInfo\MaxTime:=1\DIBreak:=VB_di_MsgBoxBrk1\BreakFlag:=errno1;
 ENDWHILE
 
 WaitDI PLC_di_CollZoneRel,0\MaxTime:=3\TimeFlag:=b_TimeOut;
 !***************************************************************
 !* Waiting for Collsion zone Release signal from PLC to be off *
 !***************************************************************
 
 WHILE PLC_di_CollZoneRel=1 DO
 	MsgBoxBreak "PLC_di_CollZoneRel",0;

	st_UiHeader:=["Com, CollSafetyComFin","Com, CollSafetyComFin","???"];
	st_UiMsgLine2:=["Waiting for collision zone release from PLC to be off. PLC_di_CollZoneRel=0","Warte auf PLC_di_CollZoneRel=0","???"];
	UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}
		\Buttons:=btnNone\Icon:=iconInfo\MaxTime:=1\DIBreak:=VB_di_MsgBoxBrk1\BreakFlag:=errno1;
 ENDWHILE
 
 WaitGI PLC_gi_CollZone, 0\MaxTime:=3;
 !********************************************************
 !* Waiting for PLC to set Collision zone number to zero *
 !********************************************************

 WHILE GInput(PLC_gi_CollZone)>0 DO
 	MsgBoxBreak "PLC_gi_CollZone",0;
	
	st_UiHeader:=["Com, CollSafetyComFin","Com, CollSafetyComFin","???"];
	st_UiMsgLine2:=["Waiting for PLC to send collision zone zero. PLC_gi_CollZone=0","Warte auf PLC_gi_CollZone=0","???"];
	UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}\Buttons:=btnNone\Icon:=iconInfo\diBreak:=VB_di_MsgBoxBrk1\BreakFlag:=errno1;
 ENDWHILE
 !
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO = ERR_WAIT_MAXTIME TRYNEXT;
 IF ERRNO = ERR_TP_DIBREAK TRYNEXT;
 
ENDPROC !(CollSafetyComFin)

!*******************************************************************************

PROC CollClearAll()
  !****************************************
  !* Init Zonen / Init zone               *
  !* alle Zonen loeschen / clear all zone *
  !****************************************
  WaitRob \InPos;
  CollSafetyInit;
ENDPROC !(CollClearAll)

!*******************************************************************************

PROC CollSafetyClear()
 !*************************************************************
 !*          Prozedur Freigabe einer Kollisionszone           *
 !*            uebergebene Parameter: keine                   *
 !*            Collision Zone Control Clear                   *
 !*************************************************************
 VAR bool b_TimeOut;
 VAR errnum errno1;  

CollSafetyComFin;

 FOR i FROM 1 TO n_CollClZ DO  
    !Kein abloeschen wenn nicht angefordert

    WaitDI PLC_di_CollZoneRel,0\MaxTime:=3\TimeFlag:=b_TimeOut;
    !***************************************************************
    !* Waiting for Collsion zone release signal from PLC to be off *
    !***************************************************************

    WHILE PLC_di_CollZoneRel=1 DO
    	st_UiHeader:=["Com, CollSafetyClear","Com, CollSafetyClear","???"];
    	st_UiMsgLine2:=["Waiting for collision zone release from PLC to be off. PLC_di_CollZoneRel = 0","Warte auf PLC_di_CollZoneRel = 0","???"];
    	UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}\Buttons:=btnNone\Icon:=iconInfo\MaxTime:=1\BreakFlag:=errno1;
    ENDWHILE

    IF b_CollZoneOccupied{n_Coll{i}}=TRUE THEN
        WHILE PLC_gi_CollZone<> n_Coll{i} OR PLC_di_CollZoneRel<>1 DO

            SetGO PLC_go_CollZone, n_Coll{i};

            IF b_ColOption Set PLC_do_CollZoneClear;

            WaitGI PLC_gi_CollZone, n_Coll{i}\MaxTime:=3;
            !******************************************************
            !*  Waiting for PLC to confirm Collision Zone number  *
            !******************************************************

            WHILE GInput(PLC_gi_CollZone)<>n_Coll{i} DO
                st_UiHeader:=["Com, CollSafetyClear","Com, CollSafetyClear","???"];
                st_UiMsgLine2:=["Waiting for PLC to echo back collision zone number. PLC_gi_CollZone = ","Warte auf PLC_gi_CollZone = ","???"];
                UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}+NumToStr(n_Coll{i},0)\Buttons:=btnNone\Icon:=iconInfo\MaxTime:=1\BreakFlag:=errno1;
            ENDWHILE
     
            Set PLC_do_CollZoneClear;
     
            WaitDI PLC_di_CollZoneRel,1\MaxTime:=3\TimeFlag:=b_TimeOut;
            !******************************************************
            !* Waiting for Collsion zone release signal from PLC  *
            !******************************************************

            WHILE PLC_di_CollZoneRel=0 DO
                st_UiHeader:=["Com, CollSafetyClear","Com, CollSafetyClear","???"];
                st_UiMsgLine2:=["Waiting for collison zone release from PLC. PLC_di_CollZoneRel = 1","Warte auf PLC_di_CollZoneRel = 1","???"];
                UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}\Buttons:=btnNone\Icon:=iconInfo\MaxTime:=1\BreakFlag:=errno1;
            ENDWHILE
        ENDWHILE

        b_CollZoneOccupied{n_Coll{i}}:=FALSE;

    ENDIF    

    Reset PLC_do_CollZoneClear;
    SetGO PLC_go_CollZone, 0;

    IF b_ColOption <>TRUE THEN
         WaitDI PLC_di_CollZoneRel,0\MaxTime:=3\TimeFlag:=b_TimeOut;
         !***************************************************************
         !* Waiting for Collsion zone release signal from PLC to be off *
         !***************************************************************
         
         WHILE PLC_di_CollZoneRel=1 DO
        	st_UiHeader:=["Com, CollSafetyClear","Com, CollSafetyClear","???"];
        	st_UiMsgLine2:=["Waiting for collision zone release from PLC to be off. PLC_di_CollZoneRel = 0","Warte auf PLC_di_CollZoneRel = 0","???"];
        	UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}\Buttons:=btnNone\Icon:=iconInfo\MaxTime:=1\BreakFlag:=errno1;
         ENDWHILE
    ENDIF
 ENDFOR

 b_CollClearAct:=FALSE;
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO = ERR_WAIT_MAXTIME TRYNEXT;
ENDPROC !(CollSafetyClear)
!*******************************************************************************

PROC Coll_Clear(num Coll  \num Coll_B  \num Coll_C  \num Coll_D  \num Coll_E)
 !***************************
 !*    Befehl MoveJ_CollClr *
 !*   without motion points *
 !***************************
 
 VAR btnres br_UiAnswer;
 VAR bool b_TimeOut;
 VAR errnum errno1;  
 
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
 
 !Warten bis vorherige Bearbeitung erledigt
 
 WaitUntil b_CollClearAct=FALSE\MaxTime:=3\TimeFlag:=b_TimeOut;
 !*************************************************************
 !*   Waiting for acknowledge that the Collsion was released  *
 !*************************************************************
 
 IF b_CollClearAct=TRUE THEN
   IF OpMode()= OP_MAN_PROG THEN
     st_UiHeader:=["Com, CollZoneClearError","Com, CollZoneClearError","???"];    
     st_UiMsgLine1:=["Warning","Achtung","???"];
     st_UiMsgLine2:=["","","???"];
     st_UiMsgLine3:=["The clear collision zone routine was interrupted!","Die Funktion loesche Kollisionsschutz wurde abgebrochen","???"];
     st_UiMsgLine4:=["Please confirm in Manual Mode! ","Betaetigen in Handbetrieb","???"];
	UIMsgBox\Header:=st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}
  		\MsgLine3:=st_UiMsgLine3{n_Sp}\MsgLine4:=st_UiMsgLine4{n_Sp}
	 	\Buttons:=btnOK\Icon:=iconError;	  
     b_CollClearAct:=FALSE;
     TPErase;
     TPShow TP_LATEST;
   ELSE
     WHILE b_CollClearAct=TRUE DO
		st_UiHeader:=["Com, CollZoneClearError","Com, CollZoneClearError","???"];    
		st_UiMsgLine2:=["Coll_Clear: Wait b_CollClearAct=FALSE","Coll_Clear: Warte auf b_CollClearAct=FALSE","???"];
		st_UiMsgLine3:=["The clear function has not been finished yet","Das Freigeben der Zone ist noch nicht abgeschlossen!","???"];
		UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}\MsgLine3:=st_UiMsgLine3{n_Sp}
			\Buttons:=btnNone\Icon:=iconWarning\MaxTime:=1\BreakFlag:=errno1;
     ENDWHILE
   ENDIF   
 ENDIF 
 
 !In bearbeitung
 b_CollClearAct:=TRUE;
 
 !Init Zonen / Init zone
 FOR i FROM 1 TO 5 DO  
   n_Coll{i}:=0;
 ENDFOR
 
 !Einlesen der Zonen / Reading the Zone
 n_CollClZ:=1;
 n_Coll{1}:=Coll;

IF Present(Coll_B) THEN
    Incr n_CollClZ;
    n_Coll{2}:=Coll_B;
ENDIF

IF Present(Coll_C) THEN
    Incr n_CollClZ;
    IF n_Coll{2}=0 THEN
        n_Coll{2}:=Coll_C;
    ELSE
        n_Coll{3}:=Coll_C;
    ENDIF
ENDIF

IF Present(Coll_D) THEN
    Incr n_CollClZ;
    IF n_Coll{2}=0 THEN
        n_Coll{2}:=Coll_D;
    ELSE
        IF n_Coll{3}=0 THEN
            n_Coll{3}:=Coll_D;
        ELSE
            n_Coll{4}:=Coll_D;
        ENDIF
    ENDIF
ENDIF

IF Present(Coll_E) THEN
    Incr n_CollClZ;
    IF n_Coll{2}=0 THEN
        n_Coll{2}:=Coll_E;
    ELSE
        IF n_Coll{3}=0 THEN
            n_Coll{3}:=Coll_E;
        ELSE
            IF n_Coll{4}=0 THEN
                n_Coll{4}:=Coll_E;
            ELSE
                n_Coll{5}:=Coll_E;
            ENDIF
        ENDIF
    ENDIF
ENDIF
  
 !Wenn nicht besetzt / When not occupied
 FOR i FROM 1 TO n_CollClZ DO
   IF OpMode()= OP_AUTO THEN
     WHILE b_CollZoneOccupied{n_Coll{i}}=FALSE DO
		st_MsgBoxHeader:=["Com, MoveLCollClr","Com, Kollisionsschutzfreigabe","Com,???"];
		st_Dummy:=["CollZone= "+NumToStr(n_Coll{i},0),"CollZone= "+NumToStr(n_Coll{i},0),"???"];
		st_Dummy2:=["is not already requested!","war nicht angefragt!","???"];
		st_MsgBoxbutton4:=["Ok","Ok","???"];
		st_MsgBoxbutton5:=["","","???"];
		n_MsgBoxApplError:=0;
		n_MsgBoxPLC_Error:=51;
		st_MsgBoxElogLine4:="ComBase/MoveLCollClr";
		MsgBox\diBreakSignal:=SYS_di_ErrReset\Line1:=st_Dummy{n_Sp}\Line2:=st_Dummy2{n_Sp}\ErrorToPLC;
     ENDWHILE
   ELSE  
     IF b_CollZoneOccupied{n_Coll{i}}=FALSE THEN
       st_UiHeader:=["Com, MoveLCollClr","Com, Kollisionsschutzfreigabe","???"];    
		st_UiMsgLine1:=["Clear Error","Freigabefehler!","???"];
		st_UiMsgLine2:=["is not already requested!","Bereich war nicht angefragt!","???"];
		st_UiMsgLine3:=["Please check the collisions zones already","ueberpruefe den Status der Kollisionszone","???"];
		st_UiMsgLine4:=["requested and confirm their status. ","Bestaetige den Zustand !","???"];
		UIMsgBox\Header:=st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}
  		\MsgLine3:=st_UiMsgLine3{n_Sp}\MsgLine4:=st_UiMsgLine4{n_Sp}
	 	\Buttons:=btnOK\Icon:=iconWarning;	  
     ENDIF
   ENDIF
 ENDFOR
 
WaitRob\InPos;
!*****************************
!* Waiting Robot in position *
!*****************************
  
CollSafetyClear;
   
BACKWARD
 
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
 
 CollSafetyRequest Coll,"";
 IF Present(Coll_B) CollSafetyRequest Coll_B,"";
 IF Present(Coll_C) CollSafetyRequest Coll_C,"";
 IF Present(Coll_D) CollSafetyRequest Coll_D,"";
 IF Present(Coll_E) CollSafetyRequest Coll_E,"";
 
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO = ERR_WAIT_MAXTIME TRYNEXT;
ENDPROC !(Coll_Clear)

!*******************************************************************************

PROC MoveJ_CollClr(  num Coll  \num Coll_B  \num Coll_C  \num Coll_D  \num Coll_E,  robtarget ToPoint,  speeddata Speed,  zonedata Zone,  PERS tooldata Tool  \PERS wobjdata Wobj)
 !*********************************************************
 !*                  Befehl MoveJ_CollClr                 *
 !*   Command MoveJ with Triggering of CollSafety Clear   *
 !*********************************************************
 VAR btnres br_UiAnswer;
 VAR bool b_TimeOut;
 VAR errnum errno1;  
 !
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
 !
 !Warten bis vorherige Bearbeitung erledigt
 !
 WaitUntil b_CollClearAct=FALSE\MaxTime:=3\TimeFlag:=b_TimeOut;
 !*************************************************************
 !*   Waiting for acknowledge that the Collsion was released  *
 !*************************************************************
 IF b_CollClearAct=TRUE THEN
   IF OpMode()= OP_MAN_PROG THEN
     st_UiHeader:=["Com, CollZoneClearError","Com, CollZoneClearError","???"];    
     st_UiMsgLine1:=["Warning","Achtung","???"];
     st_UiMsgLine2:=["","","???"];
     st_UiMsgLine3:=["The clear collision zone routine was interrupted!","Die Funktion loesche Kollisionsschutz wurde abgebrochen","???"];
     st_UiMsgLine4:=["Please confirm in Manual Mode! ","Betaetigen in Handbetrieb","???"];
	UIMsgBox\Header:=st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}
  		\MsgLine3:=st_UiMsgLine3{n_Sp}\MsgLine4:=st_UiMsgLine4{n_Sp}
	 	\Buttons:=btnOK\Icon:=iconError;	  
     b_CollClearAct:=FALSE;
     TPErase;
     TPShow TP_LATEST;
   ELSE
     WHILE b_CollClearAct=TRUE DO
		st_UiHeader:=["Com, CollZoneClearError","Com, CollZoneClearError","???"];    
		st_UiMsgLine2:=["MoveJCollClr: Wait b_CollClearAct=FALSE","MoveJCollClr: Warte auf b_CollClearAct=FALSE","???"];
		st_UiMsgLine3:=["The clear function has not been finished yet","Das Freigeben der Zone ist noch nicht abgeschlossen!","???"];
		UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}\MsgLine3:=st_UiMsgLine3{n_Sp}
			\Buttons:=btnNone\Icon:=iconWarning\MaxTime:=1\BreakFlag:=errno1;
     ENDWHILE
   ENDIF   
 ENDIF 
 !
 !In bearbeitung
 b_CollClearAct:=TRUE;
 !
 !Init Zonen / Init zone
 !
 FOR i FROM 1 TO 5 DO  
   n_Coll{i}:=0;
 ENDFOR
 !
 !Einlesen der Zonen / Reading the Zone
 !
 n_CollClZ:=1;
 n_Coll{1}:=Coll;
 !
 IF Present(Coll_B) THEN
   Incr n_CollClZ;
   n_Coll{2}:=Coll_B;
 ENDIF
 !
 IF Present(Coll_C) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_C;
   ELSE  
     n_Coll{3}:=Coll_C;
   ENDIF
 ENDIF
 ! 
 IF Present(Coll_D) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_D;
   ELSE
     IF n_Coll{3}=0 THEN  
       n_Coll{3}:=Coll_D;
     ELSE
       n_Coll{4}:=Coll_D;
     ENDIF 
   ENDIF
 ENDIF 
 !
 IF Present(Coll_E) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_E;
   ELSE
     IF n_Coll{3}=0 THEN  
       n_Coll{3}:=Coll_E;
     ELSE
       IF n_Coll{4}=0 THEN
         n_Coll{4}:=Coll_E;
       ELSE
         n_Coll{5}:=Coll_E;
       ENDIF 
     ENDIF 
   ENDIF
 ENDIF
 ! 
 !Wenn nicht besetzt / When not occupied
 !
 FOR i FROM 1 TO n_CollClZ DO
   IF OpMode()= OP_AUTO THEN
     WHILE b_CollZoneOccupied{n_Coll{i}}=FALSE DO
		st_MsgBoxHeader:=["Com, MoveLCollClr","Com, Kollisionsschutzfreigabe","Com,???"];
		st_Dummy:=["CollZone= "+NumToStr(n_Coll{i},0),"CollZone= "+NumToStr(n_Coll{i},0),"???"];
		st_Dummy2:=["is not already requested!","war nicht angefragt!","???"];
		st_MsgBoxbutton4:=["Ok","Ok","???"];
		st_MsgBoxbutton5:=["","","???"];
		n_MsgBoxApplError:=0;
		n_MsgBoxPLC_Error:=51;
		st_MsgBoxElogLine4:="ComBase/MoveLCollClr";
		MsgBox\diBreakSignal:=SYS_di_ErrReset\Line1:=st_Dummy{n_Sp}\Line2:=st_Dummy2{n_Sp}\ErrorToPLC;
     ENDWHILE
   ELSE  
     IF b_CollZoneOccupied{n_Coll{i}}=FALSE THEN
       st_UiHeader:=["Com, MoveLCollClr","Com, Kollisionsschutzfreigabe","???"];    
		st_UiMsgLine1:=["Clear Error","Freigabefehler!","???"];
		st_UiMsgLine2:=["is not already requested!","Bereich war nicht angefragt!","???"];
		st_UiMsgLine3:=["Please check the collisions zones already","ueberpruefe den Status der Kollisionszone","???"];
		st_UiMsgLine4:=["requested and confirm their status. ","Bestaetige den Zustand !","???"];
		UIMsgBox\Header:=st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}
  		\MsgLine3:=st_UiMsgLine3{n_Sp}\MsgLine4:=st_UiMsgLine4{n_Sp}
	 	\Buttons:=btnOK\Icon:=iconWarning;	  
     ENDIF
   ENDIF
 ENDFOR
 
 IF RunMode() = RUN_CONT_CYCLE THEN
   MoveJSync ToPoint,Speed, Zone,Tool\WObj?Wobj, "CollSafetyClear";
 ELSE
   MoveJ ToPoint,Speed,fine,Tool\WObj?Wobj;
   CollSafetyClear;
 ENDIF
 !    
BACKWARD
 !
 MoveJ ToPoint,Speed,fine,Tool\WObj?Wobj;
 !
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
 !
 CollSafetyRequest Coll,"";
 IF Present(Coll_B) CollSafetyRequest Coll_B,"";
 IF Present(Coll_C) CollSafetyRequest Coll_C,"";
 IF Present(Coll_D) CollSafetyRequest Coll_D,"";
 IF Present(Coll_E) CollSafetyRequest Coll_E,"";
 !
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO = ERR_WAIT_MAXTIME TRYNEXT;
ENDPROC !(MoveJ_CollClr)

!*******************************************************************************

PROC MoveL_CollClr( num Coll \num Coll_B  \num Coll_C  \num Coll_D  \num Coll_E, robtarget ToPoint, speeddata Speed, zonedata Zone, PERS tooldata Tool \PERS wobjdata Wobj)
 !*************************************************************
 !*               Procedure MoveLCollClr                      *
 !*     Modified MoveL with Triggering of CollSafety Clear    *
 !*************************************************************
 VAR btnres br_UiAnswer;
 VAR bool b_TimeOut;
 VAR errnum errno1;  
 !
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
 !
 !Warten bis vorherige Bearbeitung erledigt
 !
 WaitUntil b_CollClearAct=FALSE\MaxTime:=3\TimeFlag:=b_TimeOut;
 !*************************************************************
 !*   Waiting for acknowledge that the Collsion was released  *
 !*************************************************************
 IF b_CollClearAct=TRUE THEN
   IF OpMode()= OP_MAN_PROG THEN
	st_UiHeader:=["Com, CollZoneClearError","Com, CollZoneClearError","???"];    
	st_UiMsgLine1:=["Warning","Achtung","???"];
	st_UiMsgLine2:=["","","???"];
	st_UiMsgLine3:=["The clear collision zone routine was interrupted!","Die Funktion loesche Kollisionsschutz wurde abgebrochen","???"];
	st_UiMsgLine4:=["Please confirm in Manual Mode! ","Bestaetige in Handbetrieb","???"];
	UIMsgBox\Header:=st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}
  		\MsgLine3:=st_UiMsgLine3{n_Sp}\MsgLine4:=st_UiMsgLine4{n_Sp}
	 	\Buttons:=btnOK\Icon:=iconError;	  
     	b_CollClearAct:=FALSE;
   ELSE
	WHILE b_CollClearAct=TRUE DO
	st_UiHeader:=["Com, CollZoneClearError","Com, CollZoneClearError","???"];    
	st_UiMsgLine2:=["MoveLCollClr: Wait b_CollClearAct=FALSE","MoveLCollClr: Warte auf b_CollClearAct=FALSE","???"];
	st_UiMsgLine3:=["The clear function has not been finished yet","Das Freigeben der Zone ist noch nicht abgeschlossen!","???"];
	UIMsgBox\Header:=st_UiHeader{n_Sp},""\MsgLine2:=st_UiMsgLine2{n_Sp}\MsgLine3:=st_UiMsgLine3{n_Sp}
		\Buttons:=btnNone\Icon:=iconWarning\MaxTime:=1\BreakFlag:=errno1;
     ENDWHILE
   ENDIF   
 ENDIF 
 !
 !In bearbeitung
 b_CollClearAct:=TRUE;
 !
 !Init Zonen / Init zone
 !
 FOR i FROM 1 TO 5 DO  
   n_Coll{i}:=0;
 ENDFOR
 !
 !Einlesen der Zonen / Reading the Zone
 !
 n_CollClZ:=1;
 n_Coll{1}:=Coll;
 !
 IF Present(Coll_B) THEN
   Incr n_CollClZ;
   n_Coll{2}:=Coll_B;
 ENDIF
 !
 IF Present(Coll_C) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_C;
   ELSE  
     n_Coll{3}:=Coll_C;
   ENDIF
 ENDIF
 ! 
 IF Present(Coll_D) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_D;
   ELSE
     IF n_Coll{3}=0 THEN  
       n_Coll{3}:=Coll_D;
     ELSE
       n_Coll{4}:=Coll_D;
     ENDIF 
   ENDIF
 ENDIF 
 !
 IF Present(Coll_E) THEN
   Incr n_CollClZ;
   IF n_Coll{2}=0 THEN
     n_Coll{2}:=Coll_E;
   ELSE
     IF n_Coll{3}=0 THEN  
       n_Coll{3}:=Coll_E;
     ELSE
       IF n_Coll{4}=0 THEN
         n_Coll{4}:=Coll_E;
       ELSE
         n_Coll{5}:=Coll_E;
       ENDIF 
     ENDIF 
   ENDIF
 ENDIF
 ! 
 !Wenn nicht besetzt / When not occupied
 !
 FOR i FROM 1 TO n_CollClZ DO
   IF OpMode()= OP_AUTO THEN
     WHILE b_CollZoneOccupied{n_Coll{i}}=FALSE DO
		st_MsgBoxHeader:=["Com, MoveLCollClr","Com, Kollisionsschutzfreigabe","Com,???"];
   	st_Dummy:=["CollZone= "+NumToStr(n_Coll{i},0),"CollZone= "+NumToStr(n_Coll{i},0),"???"];
   	st_Dummy2:=["is not already requested!","war nicht angefragt!","???"];
   	st_MsgBoxbutton4:=["Ok","Ok","???"];
   	st_MsgBoxbutton5:=["","","???"];
   	n_MsgBoxApplError:=0;
   	n_MsgBoxPLC_Error:=51;
   	st_MsgBoxElogLine4:="ComBase/MoveLCollClr";
   	MsgBox\diBreakSignal:=SYS_di_ErrReset\Line1:=st_Dummy{n_Sp}\Line2:=st_Dummy2{n_Sp}\ErrorToPLC;
	!
     ENDWHILE
   ELSE  
     IF b_CollZoneOccupied{n_Coll{i}}=FALSE THEN
       st_UiHeader:=["Com, MoveLCollClr","Com, Kollisionsschutzfreigabe","???"];    
			st_UiMsgLine1:=["Clear Error","Freigabefehler!","???"];
			st_UiMsgLine2:=["is not already requested!","Bereich war nicht angefragt!","???"];
			st_UiMsgLine3:=["Please check the collisions zones already","ueberpruefe den Status der Kollisionszone","???"];
			st_UiMsgLine4:=["requested and confirm their status. ","Bestaetige den Zustand !","???"];
			UIMsgBox\Header:=st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}
  			\MsgLine3:=st_UiMsgLine3{n_Sp}\MsgLine4:=st_UiMsgLine4{n_Sp}\Buttons:=btnOK\Icon:=iconWarning;	  
     ENDIF
   ENDIF
 ENDFOR
 !
 IF RunMode() = RUN_CONT_CYCLE THEN
   MoveLSync ToPoint,Speed, Zone,Tool\WObj?Wobj, "CollSafetyClear";
 ELSE
   MoveL ToPoint,Speed,fine,Tool\WObj?Wobj;
   CollSafetyClear;
 ENDIF
 !    
 BACKWARD
 !
 MoveL ToPoint,Speed,fine,Tool\WObj?Wobj;
 !
 CheckValue Coll, 1, 62, 0, "Coll Number";
 IF Present(Coll_B) CheckValue Coll_B, 1, 62, 0, "Coll Number";
 IF Present(Coll_C) CheckValue Coll_C, 1, 62, 0, "Coll Number";
 IF Present(Coll_D) CheckValue Coll_D, 1, 62, 0, "Coll Number";
 IF Present(Coll_E) CheckValue Coll_E, 1, 62, 0, "Coll Number";
 !
 CollSafetyRequest Coll,"";
 IF Present(Coll_B) CollSafetyRequest Coll_B,"";
 IF Present(Coll_C) CollSafetyRequest Coll_C,"";
 IF Present(Coll_D) CollSafetyRequest Coll_D,"";
 IF Present(Coll_E) CollSafetyRequest Coll_E,"";
 !
 ERROR
 !** Error Handler**
 SkipWarn;
 IF ERRNO = ERR_WAIT_MAXTIME TRYNEXT;
ENDPROC !(MoveL_CollClr)

!*******************************************************************************

PROC HomeSetup()
 !***********************************************************************
 !* Prozedur zum Programmieren und Parametrieren der Homepositionen 1-5 *
 !*     Procedure for programming and setup the home positions 1-5      *
 !***********************************************************************
 ! Gewaehlte Homeposition / Selected home position
 VAR num n_HomeSelect;
 ! richtigstellen der Homereihenfolge falls erste home deaktiviert / Set default home configuration
 IF b_HomeInUse{1}=FALSE b_HomeInUse:=[TRUE,FALSE,FALSE,FALSE,FALSE];
 WHILE TRUE DO
  TPErase;
  rerun1:
	! Home Liste wird Initialisiert / Create list of homes
  FOR i FROM 1 TO 5 DO  
		IF b_HomeInUse{i} THEN
			listHome{i}.text:=listHomeConst{i}.text+st_Home_label{i};
		ELSE
			listHome{i}.text:="";
		ENDIF
  ENDFOR
  !
  ! Waehle Home Nummer
  st_UiHeader:=["Setup Home.","Setup Home, Waehle eine Homepos aus.","???"];    
  st_UiMsgButtons3:=["Please select the Home you want to change.","Anzahl der Home aendern","???"];
  st_UiMsgButtons4:=["OK","Ok","???"];
  st_UiMsgButtons5:=["Finished","Beenden","???"];
  st_UiMsgButtons:=["","",st_UiMsgButtons3{n_Sp},st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
	n_HomeSelect := UIListView(\Result:=br_UiAnswer\Header:=st_UiHeader{n_Sp},listHome
 	  \BtnArray:=st_UiMsgButtons\Icon:=iconInfo\DefaultIndex:=1);
  IF br_UiAnswer = 5 THEN
  	TPErase;
  	TPShow TP_LATEST;
    RETURN;
  ENDIF
  IF br_UiAnswer = 3 THEN
		! Anzahl der verwendeten Homes\Number of used homes
		st_UiHeader:=["Enter number of homes used","Anzahl der verwendeten Home Positonen","???"];    
		st_UiMsgLine1:=["   count 1-5","   Anzahl 1-5","???"];
		n_Temp := UINumEntry(\Header:=st_UiHeader{n_Sp}\Message:=st_UiMsgLine1{n_Sp}\Icon:=iconInfo
			\InitValue:=1\MinValue:=1\MaxValue:=5\AsInteger);
		!
		TEST n_Temp
			CASE 1:
				b_HomeInUse:=[TRUE,FALSE,FALSE,FALSE,FALSE];
				b_HomeAkt:=[TRUE,FALSE,FALSE,FALSE,FALSE];
			CASE 2:
				b_HomeInUse:=[TRUE,TRUE,FALSE,FALSE,FALSE];
				b_HomeAkt:=[TRUE,TRUE,FALSE,FALSE,FALSE];
			CASE 3:
				b_HomeInUse:=[TRUE,TRUE,TRUE,FALSE,FALSE];
				b_HomeAkt:=[TRUE,TRUE,TRUE,FALSE,FALSE];
			CASE 4:
				b_HomeInUse:=[TRUE,TRUE,TRUE,TRUE,FALSE];
				b_HomeAkt:=[TRUE,TRUE,TRUE,TRUE,FALSE];
      CASE 5:
      	b_HomeInUse:=[TRUE,TRUE,TRUE,TRUE,TRUE];
      	b_HomeAkt:=[TRUE,TRUE,TRUE,TRUE,TRUE];
     ENDTEST		
     GOTO rerun1;
	ENDIF
  !
  rerun2:
  ! was soll geaendert werden / what should be changed
  n_Temp :=0;
  st_UiHeader:=["Setup homepos edit Home_","Setup Home, bearbeite Home_","???"];
  st_UiMsgLine1:=["Modify the position Home_","aendere die Position der Home_","???"];
  st_UiMsgLine2:=["Modify the description for Home_","aendere die Beschreibung fuer die Home_","???"];
  st_UiMsgLine3:=["Activate the output for Home_","Aktiviere den Ausgang fuer die Home_","???"];
  st_UiMsgButtons3:=["Return","Zurueck","???"];
  st_UiMsgButtons4:=["OK","OK","???"];
  st_UiMsgButtons5:=["Finished","Beenden","???"];
  st_UiMsgButtons:=["","",st_UiMsgButtons3{n_Sp},st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
  li_UiMsgList:=[["",st_UiMsgLine1{n_Sp}+NumToStr(n_HomeSelect,0)],["",st_UiMsgLine2{n_Sp}+NumToStr(n_HomeSelect,0)]
  	,["",st_UiMsgLine3{n_Sp}+NumToStr(n_HomeSelect,0)],["",""],["",""]]; 
  n_Temp := UIListView(\Result:=br_UiAnswer\Header:=st_UiHeader{n_Sp}+NumToStr(n_HomeSelect,0),li_UiMsgList
  		\BtnArray:=st_UiMsgButtons\Icon:=iconInfo\DefaultIndex:=1);
	IF br_UiAnswer = 5 THEN
		TPErase;
		TPShow TP_LATEST;
		RETURN;
	ENDIF
	! zurueck zur auswahl / back to selection
	IF br_UiAnswer=3 GOTO rerun1;
	! auswahl aendere Pos / Select home to change
	IF n_Temp=1 THEN
		br_UiAnswer:=0;
		st_UiHeader:=["Setup homepos edit Home_","Setup Home, neue Pos fuer Home_","???"];
		st_UiMsgLine1:=["Make the current Position the new Home_"+NumToStr(n_HomeSelect,0)+" positon!","Die aktuell Position wird als Home_"+NumToStr(n_HomeSelect,0)+" gespeichert!","???"];
		st_UiMsgButtons3:=["Return","Zurueck","???"];
		st_UiMsgButtons4:=["   Save    Position?","Position speichern!","???"];
		st_UiMsgButtons5:=["Finished","Beenden","???"];
		st_UiMsgButtons:=["","",st_UiMsgButtons3{n_Sp},st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
		br_UiAnswer:= UIMessageBox (\Header:=st_UiHeader{n_Sp}+NumToStr(n_HomeSelect,0)
			\Message:=st_UiMsgLine1{n_Sp}\BtnArray:=st_UiMsgButtons\Icon:=iconWarning);
		IF br_UiAnswer = 5 THEN
			TPErase;
			TPShow TP_LATEST;
			RETURN;
		ENDIF
		! Pos fuer die jeweilige Home zuweisen / Pos assign for each Home
		IF br_UiAnswer = 4 THEN	  
			t_Home := CTool();
			t_home.robhold:=TRUE;
		TEST n_HomeSelect
			CASE 1:
				jpHome1 := CJointT();
				robjOHome1:=jpHome1.robax;
				extjOHome1:=jpHome1.extax;
			CASE 2:
				jpHome2 := CJointT();
				robjOHome2:=jpHome2.robax;
				extjOHome2:=jpHome2.extax;
			CASE 3:
				jpHome3 := CJointT();
				robjOHome3:=jpHome3.robax;
				extjOHome3:=jpHome3.extax;
			CASE 4:
				jpHome4 := CJointT();
				robjOHome4:=jpHome4.robax;
				extjOHome4:=jpHome4.extax;
			CASE 5:
				jpHome5 := CJointT();
				robjOHome5:=jpHome5.robax;
				extjOHome5:=jpHome5.extax;
			ENDTEST
			! ungueltig setzen / error set   
			b_HomeAkt{n_HomeSelect}:=FALSE;
		GOTO rerun2;
	ENDIF
 ENDIF
 ! ruecksprung ins aenderungsmenue / jump back into the change of menu
 IF br_UiAnswer = 3 GOTO rerun2;
 ! auswahl aendere beschreibung / selection change description
 IF n_Temp=2 THEN
 	st_UiHeader:=["Setup homepos edit Home_","Setup Home, Beschreibung fuer Home_","???"];
	st_UiMsgLine1:=["Please enter the new description","Bitte eine Beschreibung fuer die HomePos eingeben.","???"];
	st_Home_label{n_HomeSelect} := UIAlphaEntry(\Header:=st_UiHeader{n_Sp}+NumToStr(n_HomeSelect,0),
	  \Message:=st_UiMsgLine1{n_Sp}\Icon:=iconInfo\InitString:= st_Home_label{n_HomeSelect});
	GOTO rerun2;
 ENDIF
 ! auswahl aktiviere Ausgang / Output enable selection
 IF n_Temp=3 THEN
	br_UiAnswer:=0;
	st_UiHeader:=["Setup homepos edit Home_","Setup Home, Ausgang fuer Home_","???"];
	st_UiMsgLine1:=["In order to activate the Home output, you must Warm Start the controller.","Der Ausgang fuer die Home wird durch einen Warmstart aktiviert!","???"];
	st_UiMsgButtons1:=["Warmstart!","Warmstart!","???"];
	st_UiMsgButtons3:=["Return","Zurueck","???"];
	st_UiMsgButtons5:=["Finished","Beenden","???"];
	st_UiMsgButtons:=[st_UiMsgButtons1{n_Sp},"",st_UiMsgButtons3{n_Sp},"",st_UiMsgButtons5{n_Sp}];
	br_UiAnswer:= UIMessageBox (\Header:=st_UiHeader{n_Sp}+NumToStr(n_HomeSelect,0)
	\Message:=st_UiMsgLine1{n_Sp}\BtnArray:=st_UiMsgButtons\Icon:=iconWarning);
	IF br_UiAnswer = 5 THEN
		TPErase;
		TPShow TP_LATEST;
		RETURN;
		ENDIF
		IF br_UiAnswer = 3 GOTO rerun2;
		IF br_UiAnswer = 1 WarmStart;
	ENDIF
 ENDWHILE
ENDPROC !(HomeSetup)

!*******************************************************************************

PROC SyncPosSetup()
 !******************************
 !*     Sync Switch Setup      *
 !******************************
 br_UiAnswer:=0;
 st_UiHeader:=["Setup SyncPos","Setup Synchron Position","???"];
 st_UiMsgLine1:=["Please note only use when the robot is at the ","Achtung  nur wenn der Roboter den Synchronschalter belegt","???"];
 st_UiMsgLine2:=["synchronous switch or on the soft-synchronous ","oder auf der Soft-Synchronposition steht","???"];
 st_UiMsgLine3:=["position. Otherwise, press> 'Abort'!","diese Position speichern. Ansonsten den Vorgang abbrechen!","???"];
 st_UiMsgButtons4:=["Save Position!","Position speichern!","???"];
 st_UiMsgButtons5:=["Abort","Abbruch","???"];
 st_UiMsgButtons:=["","","",st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
 st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},"",""]; 
 br_UiAnswer:= UIMessageBox (\Header:=st_UiHeader{n_Sp}
		\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconWarning);
 IF br_UiAnswer = 5 THEN
	TPErase;
	TPShow TP_LATEST;
	RETURN;
 ENDIF
 ! Pos zuweisen
 IF br_UiAnswer = 4 THEN	  
	t_SMSync := CTool();
	t_SMSync.robhold:=TRUE;
	jpSM1SyncSwitch := CJointT(\TaskRef:=T_ROB1Id);
	robjOSM1SyncSwitch:=jpSM1SyncSwitch.robax;
	extjOSM1SyncSwitch:=jpSM1SyncSwitch.extax;
 ENDIF
 TPErase;
 TPShow TP_LATEST;
ENDPROC !(SynchPosSetup)

!*******************************************************************************

FUNC num n_RobInHomeDO()
 !*****************************************************************************************
 !* Funktion Ueberprueft die Home Ausgaenge des Roboters und gibt entsprechend 1-5 zurueck *
 !*        Function to return the number in which home the robot is at (1-5)              *
 !*****************************************************************************************
 !
 IF DOutput(SYS_do_Home_1)=1 THEN
   RETURN 1;
 ELSEIF DOutput(SYS_do_Home_2)=1 THEN
   RETURN 2;
 ELSEIF DOutput(SYS_do_Home_3)=1 THEN
   RETURN 3;
 ELSEIF DOutput(SYS_do_Home_4)=1 THEN
   RETURN 4;
 ELSEIF DOutput(SYS_do_Home_5)=1 THEN
   RETURN 5;
 ELSE
   RETURN 0;
 ENDIF
ENDFUNC !(n_RobInHomeDO)

!*******************************************************************************

FUNC bool b_PLCNeedHome(num n_H)
 !***********************************************************
 !* Function to check which home the PLC requires the robot *
 !***********************************************************
 !
 TEST n_H
 	CASE 1:
		IF DInput(PLC_di_Home_1)=1 RETURN TRUE;
 		RETURN FALSE;
  CASE 2:
 		IF DInput(PLC_di_Home_2)=1 RETURN TRUE;
  	RETURN FALSE;
  CASE 3:
  	IF DInput(PLC_di_Home_3)=1 RETURN TRUE;
  	RETURN FALSE;
  CASE 4:
  	IF DInput(PLC_di_Home_4)=1 RETURN TRUE;
  	RETURN FALSE;
  CASE 5:
  	IF DInput(PLC_di_Home_5)=1 RETURN TRUE;
  	RETURN FALSE;
  DEFAULT :
    	RETURN FALSE;
 ENDTEST
ENDFUNC !(b_PLCNeedHome)

!*******************************************************************************

PROC CheckValue(num Value,num MinValue,num MaxValue,num Dec,string Header)
 !**************************************************************************************************
 !*            Prozedur Ueberprueft ob ein Wert innerhalb eines Bereiches liegt                    *
 !* uebergebene Parameter: num Value,num MinValue,num MaxValue,num Dec,string Header (fuer meldung) *
 !*                         Check values are within certain paramaters                             *
 !**************************************************************************************************
 WHILE Value<MinValue OR Value>MaxValue DO
  st_UiHeader:=["Value Error ","Falscher Wert von ","???"];   
  st_UiMsgLine1:=["The value is outside the Min or Max range.","Wert ist ausserhalb des gueltigen Bereichs","???"];
  st_UiMsgLine2:=["Min Value= ","Minnimal Wert= ","???"];
  st_UiMsgLine3:=["Max Value= ","Maximal  Wert= ","???"];
  st_UiMsgLine4:=["The Programmed Value=","Programmierter Wert= ","???"];
  UIMsgBox\Header:=st_UiHeader{n_Sp}+Header, st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}+NumToStr(MinValue,Dec)
 		 \MsgLine3:=st_UiMsgLine3{n_Sp}+NumToStr(MaxValue,Dec) \MsgLine4:=st_UiMsgLine4{n_Sp}+NumToStr(Value,Dec)
  		\Buttons:=btnOK\Icon:=iconWarning;
	Stop ;
	ENDWHILE
ENDPROC !(CheckValue)

!*******************************************************************************

PROC PowerOnCom()
 !***************************************************
 !* Abfrage der Appl im System nach einem Warmstart *
 !*        Check system after a warm start          *
 !***************************************************
 !Appl-Feld wird geloescht / Applications-deleted box
 VAR bool b_ComDummy:=FALSE;
 VAR bool b_timeout;
 VAR num n_ComDummy:=0;
 VAR NUM n_error_offset_x:=0 ;
 VAR NUM n_error_offset_y:=0 ;
 VAR NUM n_error_offset_z:=0 ;
 VAR bool b_ABS_Acc_Enable_MEM:=TRUE;
 VAR string st_CFG_RobotType;

 b_PwOnEnd:=FALSE;
 Reset VB_do_TaskBrake;
 FOR I FROM 1 TO 30 DO
	b_Start_present{I}:=TRUE;
	b_ReStart_present{I}:=TRUE;
	b_Stop_present{I}:=TRUE;
	b_Reset_present{I}:=TRUE;
 ENDFOR
 b_StartUser_present:=TRUE;
 b_ReStartUser_present:=TRUE;
 b_StopUser_present:=TRUE;
 b_ResetUser_present:=TRUE;
 ! Appl Info loeschen
 n_ApplMax:=0;
 n_Fk4ApplAktiv:=0;
 b_ABS_Acc_Enable:=TRUE;
 
 !Abfrage der einzelnen Appls / Check individual Applications
 n_ComDummy:=0;
 FOR I FROM 1 TO 30 DO
  b_ComDummy:=TRUE;
  st_Appl_Info{I,1}:="";
  st_Appl_Info{I,2}:="";
  st_Appl_Info{I,3}:="";
  ! aufruf der PowerOn jeder Appl und einlesen der Strings / calling the PowerOn Appl and read each of the strings
  n_Fk4ApplNum:=I;
  %"PowerON"+NumToStr(I,0)%;
  !
  IF b_ComDummy=TRUE THEN
    Incr n_ComDummy;
    st_Appl_Info{n_ComDummy,1}:=ValToStr(I);
    st_Appl_Info{n_ComDummy,2}:=st_Appl_Name;
    st_Appl_Info{n_ComDummy,3}:=st_Appl_Key{n_Sp};
 	  Incr n_ApplMax;
  ENDIF
 ENDFOR
 n_Fk4ApplNum:=0;
 
b_TbCom_Started:=FALSE ;

Waituntil b_TbCom_Started=TRUE\MaxTime:= 50\TimeFlag:= b_timeout;
!***************************
!* Waiting TB_Com to start *
!***************************

 b_PowerOn_exe_OK:=TRUE ;

 ! setzen der Homepos als Weltzonen / share of the world as Homepos Zones
 !
 IF b_HomeInUse{1}=TRUE THEN
    WZHomeJointDef \Inside, sh_HomePos1, jpHome1, delta_HomePosFine;
    WZDOSet \Stat,wz_HomePos1 \Inside, sh_HomePos1, SYS_do_Home_1,high;
    b_HomeAkt{1}:=TRUE;
 ENDIF
 !
 IF b_HomeInUse{2}=TRUE THEN
     WZHomeJointDef \Inside, sh_HomePos2, jpHome2, delta_HomePosFine;
     WZDOSet \Stat,wz_HomePos2 \Inside, sh_HomePos2, SYS_do_Home_2,high;
     b_HomeAkt{2}:=TRUE;
 ENDIF
 !
 IF b_HomeInUse{3}=TRUE THEN
     WZHomeJointDef \Inside, sh_HomePos3, jpHome3, delta_HomePosFine;
     WZDOSet \Stat,wz_HomePos3 \Inside, sh_HomePos3, SYS_do_Home_3,high;
     b_HomeAkt{3}:=TRUE;
 ENDIF
 !
 IF b_HomeInUse{4}=TRUE THEN
     WZHomeJointDef \Inside, sh_HomePos4, jpHome4, delta_HomePosFine;
     WZDOSet \Stat,wz_HomePos4 \Inside, sh_HomePos4, SYS_do_Home_4,high;
     b_HomeAkt{4}:=TRUE;
 ENDIF
 !
 IF b_HomeInUse{5}=TRUE THEN
     WZHomeJointDef \Inside, sh_HomePos5, jpHome5, delta_HomePosFine;
     WZDOSet \Stat,wz_HomePos5 \Inside, sh_HomePos5, SYS_do_Home_5,high;
     b_HomeAkt{5}:=TRUE;
 ENDIF
 !
 ! Poweron fuer Anwender wenn noetig / Poweron for users if necessary
 %"PowerOnUser"%;
 !---------------
 ! Copy SM_Files and Backup files
 SM1_CopyCfg;
 CopyCfg;

b_PwOnEnd:=TRUE;
b_ABS_Acc_Enable_MEM:=b_ABS_Acc_Enable;

 !Get robot type
 ReadCfgData "/MOC/ROBOT/ROB_1","use_robot_type",st_CFG_RobotType;
 
 st_RobotType:=st_CFG_RobotType;
 
 !Set Absoulute accuracy flag
 TEST st_RobotType
 
 CASE "ROB1_6620LX_1.90_150":
 	b_Robot_ABS_Type:=FALSE;
 DEFAULT:
 	b_Robot_ABS_Type:=b_ABS_Acc_Enable_MEM; 
 ENDTEST
 
 !Set output as this robot does not use this output
 IF st_RobotType="ROB1_6620LX_1.90_150" Set SM1_do_Stopped;
 
 IF b_Robot_ABS_Type THEN
	! Abfrage ob die AbsAcc ein ist
	ReadCfgData "/MOC/ROBOT/ROB_1","use_robot_calib",st_Abs;
	
	IF st_Abs="r1_uncalib" THEN
		st_UiHeader:=["Com, Absolute Accuracy error","Com, Keine Absolutgenauigkeit","???"];   
		st_UiMsgLine1:=["Warning!! The robot absolute accuracy is turned Off.","Ohne Absolutgenauigkeit ist es nicht erlaubt den Roboter ","???"];
		st_UiMsgLine2:=["There is a risk of collisions!","zu bewegen, es besteht Kollisionsgefahr!","???"];
		st_UiMsgLine3:=["Please ensure it is enabled!","Bitte schalten Sie die Absolutgenauigkeit wieder ein!","???"];
		ErrWrite st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp} \RL2:=st_UiMsgLine2{n_Sp}\RL3:=st_UiMsgLine3{n_Sp};
	ELSE
		!Check absolute accurate data exist
		ReadCfgData "/MOC/ARM_CALIB/rob1_1", "error_offset_x", n_error_offset_x;
		ReadCfgData "/MOC/ARM_CALIB/Rob1_1", "error_offset_y", n_error_offset_y; 
		ReadCfgData "/MOC/ARM_CALIB/Rob1_1","error_offset_z",n_error_offset_z;
		
		IF n_error_offset_x=0 AND n_error_offset_y=0 AND n_error_offset_z=0 THEN
			st_UiHeader:=["Com, Absolute Accuracy error","Com, Keine Absolutgenauigkeit","???"];   
			st_UiMsgLine1:=["Warning!! The robot absolute accuracy is turned On but,","Warnung!! Der Roboter absolute Genauigkeit ist eingeschaltet,","???"];
			st_UiMsgLine2:=["the 'ARM/JOINT_CALIB' data in the 'MOC.cfg' file","aber die 'ARM/JOINT_CALIB' Daten in der 'MOC.cfg'","???"];
			st_UiMsgLine3:=["may not exist.","Datei kann nicht vorhanden","???"];
			st_UiMsgLine4:=["Please check.","Bitte berprfen.","???"];
			
			ErrWrite st_UiHeader{n_sp},st_UiMsgLine1{n_sp} \RL2:=st_UiMsgLine2{n_sp}\RL3:=st_UiMsgLine3{n_sp}\RL4:=st_UiMsgLine4{n_sp};
		ENDIF
	ENDIF
 ENDIF

 ERROR
 !** Error Handler**
 SkipWarn;
 
 TEST ERRNO
 CASE ERR_CFG_NOTFND:
   TRYNEXT;
  
 CASE ERR_REFUNKPRC:
   b_ComDummy:=FALSE;
   st_Appl_Name:="";
   st_Appl_Key:=["","",""];
   TRYNEXT;
 ENDTEST
ENDPROC !(PowerOnCom)

!*******************************************************************************

PROC StartCom()
 !****************************
 !* Aufruf der Startroutinen *
 !*     Start Routine        *
 !****************************
 VAR bool b_ComDummy:=FALSE;
 VAR num n_ComDummy:=0;
 ! ob Programmzeiger versetzt wurde / whether program pointer was moved
 IF PPMovedInManMode() ResetPPMoved;
 !
 IF b_CheckPP=FALSE THEN 
	Reset SYS_do_MainStarted;
	! loeschen von Fehlern wenn neustart / Clear errors after new start
	SetGO PLC_go_ErrCode, 0; 
	Reset PLC_do_MsgToPLC; 
	Reset PLC_do_ErrorToPLC;
	Reset PLC_do_StopToPLC;
	MsgBox_Clear;
	b_CollClearAct:= FALSE;
	n_JobReqNum:=0;
	n_JobFinNum:=0;
	b_JobF_w:=FALSE;
	b_JobR_w:=FALSE;
 ENDIF 
 
 ! aufruf der Eventroutinen der Appl / calling the routines in the events
 b_UserEv:=FALSE;
 IF n_ApplMax >0 AND n_ApplMax< 31 THEN
	FOR I FROM 1 TO n_ApplMax DO
		n_Appl_count:=I;
		IF (st_Appl_Info{I,1}="") OR (b_Start_present{I}=FALSE) GOTO END_Start;
		b_ComDummy:=StrToVal(st_Appl_Info{I,1},n_ComDummy);
		%"Start"+NumToStr(n_ComDummy,0)%;
	 	END_Start:
	ENDFOR
 ENDIF
 
 IF n_ModeOP_Mem<>OpMode() THEN
      b_Ignore_NoAppl_Chk:=FALSE ;
      n_ModeOP_Mem:=OpMode();
 ENDIF
 
 IF PLC_di_NoApplication=1 AND b_Ignore_NoAppl_Chk=FALSE THEN
    MsgBoxEv_Clear;
    st_MsgBoxEvHeader:=["Warning!! StartCom","Warnung!! StartCom","???"];
	st_Dummy:=["You are about to run with (PLC_di_NoApplication=1)","Du bist zum Laufen (PLC_di_NoApplication=1)","???"];
	st_MsgBoxEvLine3:=["no Application selected.","nein Anwendung ausgewaehlt.","???"];
    st_MsgBoxEvbutton4:=["Continue","OK","???"];
	
	IF OpMode()<>OP_Auto THEN
		st_MsgBoxEvLine5:=["Press>'Ignore' to stop message re-occuring.","Druecke> 'Ignorieren' um die Nachricht zu stoppen.","???"];
		st_MsgBoxEvbutton5:=["Ignore","Ignorieren","???"];
   ENDIF
    
    MsgBoxEv\line1:=""\Line2:=st_Dummy{n_Sp};
	
    IF n_MsgBoxEvAnswer=5 b_Ignore_NoAppl_Chk:=TRUE;
 ENDIF
 
 b_UserEv:=TRUE;
 IF b_StartUser_present = TRUE %"StartUser"%;
 !
 ERROR
 !** Error Handler**
 IF ERRNO=ERR_REFUNKPRC THEN
 	SkipWarn;
	IF b_UserEv=TRUE THEN
		b_StartUser_present:=FALSE;
	ELSE
		b_Start_present{n_Appl_count}:=FALSE;
 	ENDIF
	TRYNEXT;
 ENDIF
ENDPROC !(StartCom)

!*******************************************************************************

PROC StopCom()
 !***************************
 !* Aufruf der Stoproutinen *
 !*     Stop Routine        *
 !***************************
 VAR bool b_ComDummy:=FALSE;
 VAR num n_ComDummy:=0;
 ! ob Programmzeiger versetzt wurde / whether program pointer was moved
 IF b_CheckPP=FALSE   Reset SYS_do_MainStarted;
 ! aufruf der Eventroutinen der Appl / calling the routines in the events
 b_UserEv:=FALSE;
 IF n_ApplMax >0 AND n_ApplMax< 31 THEN
	FOR I FROM 1 TO n_ApplMax DO
		n_Appl_count:=I;
		IF (st_Appl_Info{I,1}="") OR (b_Stop_present{I}=FALSE) GOTO END_Stop;
		b_ComDummy:=StrToVal(st_Appl_Info{I,1},n_ComDummy);
		%"Stop"+NumToStr(n_ComDummy,0)%;
	 	END_Stop:
	 ENDFOR
 ENDIF
 b_UserEv:=TRUE;
 IF b_StopUser_present = TRUE %"StopUser"%;
 ERROR
 !** Error Handler**
 IF ERRNO=ERR_REFUNKPRC THEN
 	SkipWarn;
	IF b_UserEv=TRUE THEN
		b_StopUser_present:=FALSE;
	ELSE
		b_Stop_present{n_Appl_count}:=FALSE;
 	ENDIF
	TRYNEXT;
 ENDIF
ENDPROC !(StopCom)

!*******************************************************************************

PROC RestartCom()
 !******************************
 !* Aufruf der ReStartroutinen *
 !*     Re-Start Routine       *
 !******************************
 VAR bool b_ComDummy:=FALSE;
 VAR num n_ComDummy:=0;
 VAR errnum errno1;
 ! ob Programmzeiger versetzt wurde / whether program pointer was moved
 b_PPMoved:=FALSE;
 IF PPMovedInManMode() THEN
	b_PPMoved:=TRUE;
	! loeschen von Fehlern wenn start / Clear errors if Restart
	SetGO PLC_go_ErrCode, 0; 
	Reset PLC_do_MsgToPLC; 
	Reset PLC_do_ErrorToPLC;
	Reset PLC_do_StopToPLC;
	MsgBox_Clear;
	MsgBoxEv_Clear;
	b_CollClearAct:= FALSE;
	b_JobF_w:=FALSE;
	b_JobR_w:=FALSE;

     IF DOutput(SYS_do_MainStarted)=1 AND DOutput (SYS_do_ApplRun)=1 AND b_PPMoved_mem=FALSE THEN
         b_PPMoved_mem:=TRUE;
         Log_Message "STD","Program pointer moved in Manual mode";
     ENDIF

 ENDIF 
 
 IF OpMode()=OP_AUTO b_PPMoved_mem:=FALSE;
    
 IF b_CheckPP=FALSE   Reset SYS_do_MainStarted;
 ! aufruf der Eventroutinen der Appl / calling the routines in the events
 b_UserEv:=FALSE;
 IF n_ApplMax >0 AND n_ApplMax< 31 THEN
		FOR I FROM 1 TO n_ApplMax DO
			n_Appl_count:=I;
			IF (st_Appl_Info{I,1}="") OR (b_ReStart_present{I}=FALSE)  GOTO END_Restart;
			b_ComDummy:=StrToVal(st_Appl_Info{I,1},n_ComDummy);
			%"Restart"+NumToStr(n_ComDummy,0)%;
			END_Restart:
		ENDFOR
	ENDIF

 b_UserEv:=TRUE;
 IF b_ReStartUser_present = TRUE %"RestartUser"%;
 ! abfrage auf simulierte signale
 IF DOutput(VB_do_Simulated_IO)= 1 AND OpMode()= OP_AUTO  AND RobOs() = TRUE THEN
	! Meldung an SPS
	SetGO PLC_go_ErrCode, 34;
	Set PLC_do_MsgToPLC;
 	WHILE DOutput(VB_do_Simulated_IO)= 1 AND OpMode()= OP_AUTO DO
  		st_UiHeader:=["Com, Caution simulated signals!","Com, Achtung Simulierte Signale!","???"];    
  		st_UiMsgLine1:=["There are some signals that are simulated which is not allowed in","Das Simulieren von Signalen ist im Automatik nicht erlaubt!","???"];
  		st_UiMsgLine2:=["automatic mode!  Please switch to manual mode,","In die Betriebsart Hand wechseln und die","???"];
  		st_UiMsgLine3:=["select the I/O menu then turn off the simulation/s.","Simulation aller Signale im Ein-Ausgangs Fenster ausschalten.","???"];
  		UIMsgBox\Header:=st_UiHeader{n_Sp},st_UiMsgLine1{n_Sp}\MsgLine2:=st_UiMsgLine2{n_Sp}\MsgLine3:=st_UiMsgLine3{n_Sp}
  						\Buttons:=btnNone\Icon:=iconError\MaxTime:=1.5\BreakFlag:=errno1;
			!
	ENDWHILE
 	SetGO PLC_go_ErrCode, 0;
 	Reset PLC_do_MsgToPLC;
 ENDIF	
 ! check SafeMove function,at error to reduce speed
 IF DOutput(SM1_do_BrakeReq) =0 THEN
  	VelSet 100,5000;
 ELSE
  	VelSet 100,150;
		ErrWrite \W, "ComBase, SM1_do_BrakeReq =1", "Speed reduce to 150mm/s" ;
 ENDIF
 
 IF n_ModeOP_Mem<>OpMode() THEN
      b_Ignore_NoAppl_Chk:=FALSE ;
      n_ModeOP_Mem:=OpMode();
 ENDIF
  
ResetPPMoved;

 ERROR
 !** Error Handler**
 IF ERRNO=ERR_REFUNKPRC THEN
 	SkipWarn;
	IF b_UserEv=TRUE THEN
		b_ReStartUser_present:=FALSE;
	ELSE
		b_ReStart_present{n_Appl_count}:=FALSE;
 	ENDIF
	TRYNEXT;
 ENDIF
ENDPROC !(RestartCom)

!*******************************************************************************

PROC ResetCom()
 !****************************
 !* Aufruf der Resetroutinen *
 !*      Reset Routine       *
 !****************************
 VAR bool b_ComDummy:=FALSE;
 VAR num n_ComDummy:=0;
 ! aufruf der Eventroutinen der Appl / calling the routines in the events
 b_UserEv:=FALSE;
 IF n_ApplMax >0 AND n_ApplMax< 31 THEN
	FOR I FROM 1 TO n_ApplMax DO
		n_Appl_count:=I;
		IF (st_Appl_Info{I,1}="") OR (b_Reset_present{I}=FALSE) GOTO END_Reset;
		b_ComDummy:=StrToVal(st_Appl_Info{I,1},n_ComDummy);
		%"Reset"+NumToStr(n_ComDummy,0)%;
	 	END_Reset:
	ENDFOR
 ENDIF
 b_UserEv:=TRUE;
 IF b_ResetUser_present = TRUE %"ResetUser"%;
 ERROR
 !** Error Handler**
 IF ERRNO=ERR_REFUNKPRC THEN
 	SkipWarn;
	IF b_UserEv=TRUE THEN
		b_ResetUser_present:=FALSE;
	ELSE
		b_Reset_present{n_Appl_count}:=FALSE;
 	ENDIF
	TRYNEXT;
 ENDIF
ENDPROC !(ResetCom)

!*******************************************************************************

FUNC bool b_RobInHomeDO(num Home)
 !************************************************************************************
 !*                            Funktion b_RobInHomeDO                                * 
 !* Funktion Ueberprueft die Home Ausgaenge des Roboters und gibt FALSE/TRUE zurueck *
 !*     Function checks the robot exits the home and gives FALSE / TRUE back         *
 !************************************************************************************
  IF Home = 1 AND DOutput(SYS_do_Home_1)=1 THEN
    RETURN TRUE;
  ELSEIF Home = 2 AND DOutput(SYS_do_Home_2)=1 THEN
    RETURN TRUE;
  ELSEIF Home = 3 AND DOutput(SYS_do_Home_3)=1 THEN
    RETURN TRUE;
  ELSEIF Home = 4 AND DOutput(SYS_do_Home_4)=1 THEN
    RETURN TRUE;
  ELSEIF Home = 5 AND DOutput(SYS_do_Home_5)=1 THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  ENDIF
ENDFUNC !(b_RobInHomeDO)

!*******************************************************************************

PROC SM1_CopyCfg()
 !**********************************************
 !* Routine to copy savemove config cfg files  *
 !**********************************************

 VAR string stSMCalFileInt;
 VAR string stSMFileInt;
 VAR string stSMCalFileHome;
 VAR string stSMFileHome;
 VAR string stSMCalFileBck;
 VAR string stSMFileBck;
 VAR string stBckName;
 VAR num n_index;
 ! create folder  	
 MakeDir "HOME:/SafetyBCK";
 FOR i FROM 1 TO 4 DO
 	! Check all files
	stSMCalFileHome:= stSMCalHome+ ValToStr(i)+ ".xml";
  stSMCalFileInt:= stSMCalInternal+ ValToStr(i)+ ".xml";
  stSMFileHome:= stSMHome+ ValToStr(i)+ ".sxml";
  stSMFileInt:= stSMInternal+ ValToStr(i)+ ".sxml";
  ! If file has a config then safe to Home
	IF FileSize(stSMFileInt) > nSMFilesize THEN
	  	IF IsFile(stSMFileHome) THEN
	   		! delete existing file at Homefolder
	  		RemoveFile stSMFileHome;
	 	  ENDIF	
	    IF IsFile(stSMCalFileHome) THEN
	   		! delete existing file at Homefolder
	  		RemoveFile stSMCalFileHome;
	    ENDIF	
	    ! Copy actual config from System
	 		CopyFile stSMFileInt, stSMFileHome;
	 		CopyFile stSMCalFileInt, stSMCalFileHome;
			! Read Pin code
			WaitTime 0.2;
			IF IsFile(stSMFileHome) n_SMPins{i}:= GetPinCode(stSMFileHome);
	 ELSE
	 		! Read Backup name
			n_index:=0;
			ReadCfgData "/MMC/BACKUP_DEFAULT/backup_path//hd0a/BACKUP","backup_name",stBckName\ListNo:=n_index; 
			stSMFileBck:= stSMBck+ stBckName+ stSMBckFile+ ValToStr(i)+ ".sxml";
			stSMCalFileBck:= stSMBck+ stBckName+ stSMBckCal+ ValToStr(i)+ ".xml";
			! Check on exist config at Backupfolder and right Pin
			! it is for restoring SafeMove config
			IF  IsFile(stSMFileBck)THEN
				 IF (n_SMPins{i} = GetPinCode(stSMFileBck)) THEN
		  			! delete existing file and Copy actual config to System
			  		RemoveFile stSMFileInt;
	  				CopyFile stSMFileBck, stSMFileInt;
		  			ErrWrite \I, "Com, PowerON", "SafeMove, Configfile re-established";
			  		IF  IsFile(stSMCalFileBck)THEN
			  			RemoveFile stSMCalFileInt;
				  		CopyFile stSMCalFileBck, stSMCalFileInt;
					  	ErrWrite \I, "Com, PowerON", "SafeMove, Calfile re-established";
					  ENDIF
			 	 ENDIF
			ENDIF
		ENDIF	
 ENDFOR
 !
 ERROR
 !** Error Handler**
 IF ERRNO = ERR_FILEEXIST THEN
  	SkipWarn;
	!Do Nothing
 ELSEIF ERRNO = ERR_FILEACC THEN
  	SkipWarn;
	TRYNEXT;
 ENDIF
 IF ERRNO = ERR_CFG_NOTFND THEN
 	ErrWrite "ComBase /PowerOn", "Path to save SM-Data not correct!" \RL2:="Change the Path in SM1_CopyCfg";
 ENDIF
ENDPROC !(SM1_CopyCfg)

!*******************************************************************************

PROC CopyCfg()
 !************************************************
 !* Routine to copy config cfg files for backup  *
 !************************************************
 
 VAR string stBckName;
 VAR num n_index;
 
 ! create folder  	
 MakeDir "HOME:";
 
 !Get Backuip name
 ReadCfgData "/MMC/BACKUP_DEFAULT/backup_path//hd0a/BACKUP","backup_name",stBckName\ListNo:=n_index;
 
 !Create backup Directory name
  IF RobOS() THEN
     stCon_Int_Dir:="/hd0a/internal";
     stCon_Home_Dir:="/hd0a/"+stBckName+"/Home";
     sthd0a_Home_Dir:="/hd0a/Backup/"+stBckName+"/Home";
 ELSE
    stCon_Int_Dir:="INTERNAL:";
    stCon_Home_Dir:="HOME:";
    sthd0a_Home_Dir:="HOME:";
 ENDIF

 !Copy IPaddress file to internal home directory
 IF IsFile(stCon_Int_Dir + "/mc.cfg") THEN
     
   !Delete old file
    IF IsFile(stCon_Home_Dir + "/mc.cfg") RemoveFile stCon_Home_Dir + "/mc.cfg"; 
    
    CopyFile stCon_Int_Dir + "/mc.cfg",stCon_Home_Dir + "/mc.cfg";
 ELSEIF IsFile(sthd0a_Home_Dir + "/mc.cfg") THEN
    CopyFile sthd0a_Home_Dir + "/mc.cfg",stCon_Int_Dir + "/mc.cfg";
 ENDIF
 
 !Copy UAS files to internal home directory
 IF IsFile(stCon_Int_Dir + "/uas_groups.xml") THEN
     
   !Delete old file
    IF IsFile(stCon_Home_Dir + "/uas_groups.xml") RemoveFile stCon_Home_Dir + "/uas_groups.xml"; 
    
    CopyFile stCon_Int_Dir + "/uas_groups.xml",stCon_Home_Dir + "/uas_groups.xml";
 ELSEIF IsFile(sthd0a_Home_Dir + "/uas_groups.xml") THEN
    CopyFile sthd0a_Home_Dir + "/uas_groups.xml",stCon_Int_Dir + "/uas_groups.xml";
 ENDIF 
 
  IF IsFile(stCon_Int_Dir + "/uas_users.xml") THEN
     
   !Delete old file
    IF IsFile(stCon_Home_Dir + "/uas_users.xml") RemoveFile stCon_Home_Dir + "/uas_users.xml"; 
    
    CopyFile stCon_Int_Dir + "/uas_users.xml",stCon_Home_Dir + "/uas_users.xml";
 ELSEIF IsFile(sthd0a_Home_Dir + "/uas_users.xml") THEN
    CopyFile sthd0a_Home_Dir + "/uas_users.xml",stCon_Int_Dir + "/uas_users.xml";
 ENDIF 
 
 RETURN;
 
 ERROR
 !** Error Handler**

 TEST ERRNO
 CASE ERR_FILEEXIST:
  	SkipWarn;
	!Do Nothing
 CASE ERR_FILEACC:
  	SkipWarn;
	TRYNEXT;
 !Case ERR_CFG_NOTFND:
 !	ErrWrite "ComBase /PowerOn", "Path to save SM-Data not correct!" \RL2:="Change the Path in SM1_CopyCfg";
 ENDTEST

ENDPROC !(SM1_CopyCfg)

!*******************************************************************************

PROC SM1_SyncMove()
 !*******************************
 !* Check Save Move Sync Switch *
 !*******************************
 !
 MoveAbsJ jpSM1SyncSwitch, v500, fine, t_SMSync;
 WaitTime \InPos, 1; 
 n_Step:=1;
 WaitDI SM1_di_SyncSwitch ,1\MaxTime:=3;
 !*******************************
 !* Waiting for SyncSwith Input *
 !*******************************

 n_Step:=2;
 WaitDO SM1_do_Synced ,1\MaxTime:=3;
 !*******************************
 !*    Waiting for Sync Ouput   *
 !*******************************
 
 IF DOutput(SM1_do_Synced) =1 THEN
	VelSet 100,5000;
 ELSE
	VelSet 100,150;
 ENDIF
 ERROR
 SkipWarn;
 !** Error Handler**
 IF ERRNO=ERR_WAIT_MAXTIME THEN
  TEST n_Step
   	CASE 1:
			st_MsgBoxHeader:=["Waiting for Syncronisation Switch signal","Warte auf den Synchronschalter","???"];
			st_MsgBoxLine3:=["Please check the Safemove Sync Switch","ueberpruefe den Synchronschalter","???"];
			st_MsgBoxLine4:=["Please check the robot position or calibration.","ueberpruefe die Roboterposition/Kalibrierung","???"];
			st_MsgBoxLine5:=["","","???"];
			st_MsgBoxbutton4:=["Retry","Wiederhole","???"];
			st_MsgBoxbutton5:=["Abort","Abbruch","???"];
			st_MsgBoxGeraeteName:=["SafeMove","SafeMove","???"];
			n_MsgBoxGeraeteNr:=1;
			st_MsgBoxSignal:="SM1_di_SyncSwitch";
			st_MsgBoxSignalValue:="1";
			n_MsgBoxApplError:=0;
			!Fehler Nummer an die SPS\Error Number to the PLC
			n_MsgBoxPLC_Error:=41;
			st_MsgBoxElogLine4:="ComBase/SM1_SyncMove";
			MsgBox \diBreakSignal:=SYS_di_ErrReset;
			!
			TEST n_MsgBoxAnswer
				CASE 0:
					RETRY;
				CASE 4:
					RETRY;
				CASE 5:
					TRYNEXT;
			ENDTEST
   	CASE 2:
			st_MsgBoxHeader:=["Waiting for Safe Move Synchronised","Warte auf SafeMove Synchronisiert","???"];
			st_MsgBoxLine3:=["Please check the safe move configuration","ueberpruefe SafeMove konfiguration","???"];
			st_MsgBoxLine4:=["but, this is not possible in Automatic mode.","Automatikbetrieb ist bis zur Fehlerbehebung nicht moeglich","???"];
			st_MsgBoxLine5:=["","","???"];
			st_MsgBoxbutton5:=["Abort","Abbruch","???"];
			st_MsgBoxGeraeteName:=["SafeMove","SafeMove","???"];
			n_MsgBoxGeraeteNr:=1;
			st_MsgBoxSignal:="SM1_do_Synced";
			st_MsgBoxSignalValue:="1";
			n_MsgBoxApplError:=0;
			!Fehler Nummer an die SPS
			n_MsgBoxPLC_Error:=42;
			st_MsgBoxElogLine4:="ComBase/SM1_SyncMove";
			MsgBox \diBreakSignal:=SYS_di_ErrReset;
			!
			TEST n_MsgBoxAnswer
				CASE 0:
					TRYNEXT;
				CASE 5:
					TRYNEXT;
			ENDTEST
			DEFAULT:
			ErrWrite "n_Step Case Err"," ";
			!n_SW_WO_Step Case Err";
			Stop;
  	ENDTEST
 ENDIF
ENDPROC !(SM1_SyncMove)

!*******************************************************************************

PROC BrakeTest_CTRL()
 !*******************************
 !* Brake check control routine *
 !*******************************
 
 VAR num n_HomeMem;
 VAR signaldo alias_do;
 VAR string sTemp;
 VAR num n_FirstHome:=0;
 VAR jointtarget jpCurrentPos;
 
 WaitRob \InPos;
 
 !Determine which home the robot is at
 FOR i From 1 TO 5 DO
      sTemp:="SYS_do_Home_" + NumToStr(i,0);
         
      AliasIO sTemp, alias_do;
      
      IF DOutput(alias_do)=1 AND b_HomeAkt{i} AND n_FirstHome=0 THEN
          n_FirstHome:=i;
      ENDIF
 ENDFOR
  
 MsgBox_Clear;
  
 !Check if the robot is in a home
 IF n_FirstHome=0 THEN
   
     IF OpMode()=OP_AUTO THEN
         WHILE TRUE DO
            st_MsgBoxHeader:=["ComBase, Brake Test","ComBase, Bremsentest","???"];
            st_Dummy:=["Brake test operation in Automatic mode","Bremsentest in Automatikmodus","???"];
            st_Dummy2:=["but, the robot is not in any home position.","aber der Roboter ist nicht in einer Home-Position.","???"];
            
            st_MsgBoxLine4:=["Check why the robot is not in any home position.","Ueberpruefen warum Roboter nicht in einer Home-Pos ist","???"];
            st_MsgBoxLine5:=["Process cannot continue.","Prozess kann nicht weitergefuerht werden","???"];
            st_MsgBoxbutton5:=["OK","OK","???"];
 
            !Fehler Nummer an die SPS\Error number to the PLC
            n_MsgBoxPLC_Error:=109;
            st_MsgBoxElogLine4:="ComBase/BrakeTest_CTRL";
            MsgBox\Line1:=st_Dummy{n_Sp}\Line2:=st_Dummy2{n_Sp} \ErrorToPLC;
            
            Stop;
         ENDWHILE
     ELSE
        st_UiHeader:=["ComBase, Brake Test","ComBase Bremsentest, ","???"];
        st_UiMsgLine1:=["Brake test operation in Manual mode","Bremsentest in handmodus","???"];
        st_UiMsgLine2:=["but, the robot is not in any home position.","aber der Roboter ist nicht in einer Home-Position","???"];
        st_UiMsgLine5:=["Brake test will be carried out in the current position.","Bremsentest wird in der aktuellen Position ausgefuehrt","???"];
        st_UiMsgButtons5:=["OK","OK","???"];

		st_UiMsgButtons:=["","","","",st_UiMsgButtons5{n_Sp}];
		st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},"","",st_UiMsgLine5{n_Sp}]; 
		
		br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons \Icon:=iconError);
 
     	jpCurrentPos := CJointT();
        br_UiAnswer:=0;
        
		WHILE ABS(jpCurrentPos.extax.eax_a) <= 5 AND br_UiAnswer<>4 DO
		 	br_UiAnswer:=0;
			st_UiHeader:=["Com, Brake Test","Com, Bremsentest","???"];    
			st_UiMsgLine1:=["Warning! The Linear track axis 7 is near 0mm and may fail braketest.","Achtung, die Achse 7 ist nahe 0 mm der Bremsentest koennte fehlschlagen","???"];
            
			st_UiMsgLine3:=["Select 'Ignore' to start the Brake Test at current position.","Mit 'ignorieren' wird der Bremsentest in der aktuellen Position gestartet.","???"];
			st_UiMsgLine4:=["Select 'Jog' then please move the axis >5 mm then 'Play' to start test.","Mit 'Jog' Bitte die Achse min. >5 mm. bewegen, mit 'Play' Test starten","???"];
           
            st_UiMsgButtons4:=["Ignore","ignorieren","???"];
			st_UiMsgButtons5:=["Jog","Jog","???"];
            
			st_UiMsgButtons:=["","","",st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
			st_UiMsgLines:=[st_UiMsgLine1{n_Sp},"",st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},""]; 
			
			br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons \Icon:=iconError);
            
            IF br_UiAnswer=5 THEN
                ClearPath;
                Stop;
            ENDIF
            
            jpCurrentPos := CJointT();
        ENDWHILE
     ENDIF
 ENDIF

!Store current positional data
t_Home := CTool(); 
t_home.robhold:=TRUE;
jpCurrentPos:=CJointT();
 
!Call brake test routine
IF DOutput(SM1_do_BrakeOk) = 0 	VelSet 100, 150;

!Execute braketest call
SM1_BrakeTest;
  
!Ensure robot is back in correct position
 TEST n_FirstHome
 
    CASE 0:
        MoveAbsJ jpCurrentPos\NoEoffs, v1000, fine, t_Home; 
    CASE 1:
        MoveAbsJ jpHome1\NoEoffs, v1000, fine, t_Home;  
    CASE 2:
        MoveAbsJ jpHome2\NoEoffs, v1000, fine, t_Home;  
    CASE 3:
        MoveAbsJ jpHome3\NoEoffs, v1000, fine, t_Home;  
    CASE 4:
        MoveAbsJ jpHome4\NoEoffs, v1000, fine, t_Home;  
    CASE 5:
        MoveAbsJ jpHome5\NoEoffs, v1000, fine, t_Home;      
 ENDTEST
    
ENDPROC !(BrakeTest_CTRL)

!*******************************************************************************

PROC SM1_BrakeTest()
 !**********************************
 !* Check Save Move Brake Function *
 !**********************************
 VAR bool b_retryBrake;
 WaitTime \InPos, 1; 
 ReRunBrake1:
 CyclicBrakeCheck_V2;
 
 WaitTime 0.2; 
 IF (DOutput(SM1_do_BrakeReq) = 1)	THEN
 	st_MsgBoxHeader:=["ComBase, Wait for brake test OK","ComBase, Warte auf Bremsentest i.O.","???"];
	st_MsgBoxLine3:=["There was an problem during the brake test and the","Ueberpruefung der Bremse ist fehlgeschlagen!","???"];
        st_MsgBoxLine4:=["Brake test required signal from the controller is","Bremsentest Anforderung vom Controller steht an.","???"];
        st_MsgBoxLine5:=["still on. Please repeat the test again.","Bremsentest muss wiederholt werden.","???"];
	st_MsgBoxbutton5:=["Ok","Ok","???"];
	st_MsgBoxGeraeteName:=["SafeMove","SafeMove","???"];
	n_MsgBoxGeraeteNr:=1;
	st_MsgBoxSignal:="SM1_do_BrakeReq";
	st_MsgBoxSignalValue:="0";
	n_MsgBoxApplError:=0;
	!Fehler Nummer an die SPS\Error number to the PLC
	n_MsgBoxPLC_Error:=43;
	st_MsgBoxElogLine4:="ComBase/SM1_BrakeTest Request";
	MsgBox \diBreakSignal:=SYS_di_ErrReset;
	GOTO ReRunBrake1;	
 ENDIF
 
 WaitUntil (DOutput(SM1_do_BrakeOk) = 1 OR  DOutput(SM1_do_BrakeLimit) = 1) AND DOutput(SM1_do_BrakeFault)= 0\MaxTime:=1;
 !*******************************************************
 !* Waiting for brake test to be satisfactory completed *
 !*******************************************************

 IF b_retryBrake=TRUE THEN
 	b_retryBrake:=FALSE;
	GOTO ReRunBrake1;
 ENDIF

 IF DOutput(SM1_do_BrakeOk) =1 OR DOutput(SM1_do_BrakeLimit) =1 THEN
  	VelSet 100,5000;
 ELSE
  	VelSet 100,150;
 ENDIF
 !
 ERROR 
 !** Error Handler**
 
 MsgBox_Clear;
 
 SkipWarn;
 IF ERRNO=ERR_WAIT_MAXTIME THEN
	st_MsgBoxHeader:=["Wait for brake test OK","Warte auf SafeMove Bremsentest i.O.","???"];
	IF DOutput(SM1_do_BrakeFault) = 1 THEN
 		st_MsgBoxLine3:=["The robot motor brake/s are not","Die minimale Bremskraft ist nicht erreicht!","???"];
   		st_MsgBoxLine4:=["holding and must be replaced.","Defekte Bremse muss getauscht werden","???"];
 	ELSE
  		st_MsgBoxLine3:=["There was an problem during Robot motor","Ueberpruefung der Bremse war NIO","???"];
  		st_MsgBoxLine4:=["Brake test, please repeat test.","Bremsentest muss wiederholt werden","???"];
  	ENDIF
	st_MsgBoxLine5:=["With this fault, Automatic mode is not possible!!!","Automatikbetrieb ist bis zur Fehlerbehebung nicht moeglich","???"];
	st_MsgBoxbutton3:=["Retry","Wiederholen","???"];
	st_MsgBoxbutton5:=["Ok","Ok","???"];
	st_MsgBoxGeraeteName:=["SafeMove","SafeMove","???"];
	n_MsgBoxGeraeteNr:=1;
	st_MsgBoxSignal:="(BrakeOk OR BrakeWarn) AND BrakeNio=0";
	st_MsgBoxSignalValue:="";
	n_MsgBoxApplError:=0;
	
	!Fehler Nummer an die SPS\Error number to the PLC
	n_MsgBoxPLC_Error:=43;
	st_MsgBoxElogLine4:="ComBase/SM1_BrakeTest";
	MsgBox \diBreakSignal:=SYS_di_ErrReset;
	TEST n_MsgBoxAnswer
		CASE 0:
			TRYNEXT;
		CASE 3:
			b_retryBrake:=TRUE;
			TRYNEXT;
		CASE 5:
			TRYNEXT;
	ENDTEST
 ENDIF
ENDPROC !(SM1_BrakeTest)

!*******************************************************************************

PROC ManSyncService()
 !--------------------------------------------------------------
 ! function/Funktion: Procedure manuelle Synchronfahrt / manual SyncMove
 !
 ! state/Stand: 29.08.2011
 !
 ! author/Ersteller: Ramacher
 !--------------------------------------------------------------
 VAR jointtarget jpTempPos:=[ [ 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0]];
 VAR Bool b_ManSyncInt_Found:=TRUE;
 VAR Bool b_SetUpWasSelected:=FALSE;
 
 n_ManSyncCMD:=-2 ;
 !Test if 'ManSyncIntPos' routine exist
 %"ManSyncIntPos"%;
 n_ManSyncCMD:=-2 ;
  
 ReRun1:
  
 br_UiAnswer:=0;
  
 st_UiHeader:=["Com, CalibPos to move","Com, Kalibrierposition anfahren","???"];    
 st_UiMsgLine1:=["Before the robot can be synchronised ensure it is","Bevor der Roboter synchronisiert werden kann, ist die","???"];
 st_UiMsgLine2:=["at the calibration position and the calib marks are","Kalibrierposition anzufahren und die Markierungen zu","???"];
 st_UiMsgLine3:=["          ***  Visuslly checked!  ***","      ***   KONTROLLIEREN !  ***","???"];
 st_UiMsgLine4:=["Where necessary, the calibration can be realised using","Mit Setup wird festgelegt ob die Markierungen mit einer oder zwei Positionen","???"];
 
 IF b_TwoSyncPos=FALSE THEN
 	st_UiMsgLine5:=["two separate positions. Current Setting = One position.","angefahren werden. Eingestellt:= Eine Position","???"];
 ELSE
 	st_UiMsgLine5:=["one position. Current Setting = Two seperate positions.","angefahren werden. Eingestellt:= Zwei Positionen","???"];
 ENDIF
 !
 st_UiMsgButtons1:=["Setup","Setup","???"];
 st_UiMsgButtons4:=["Move To","Anfahren","???"];
 st_UiMsgButtons5:=["Abort","Abbruch","???"];
 st_UiMsgButtons:=[st_UiMsgButtons1{n_Sp},"","",st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
 st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},st_UiMsgLine5{n_Sp}]; 
 !
 br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons 
							\Icon:=iconInfo);
TEST br_UiAnswer
	CASE 1: ! Setup
 		ReRun3:
        
        b_SetUpWasSelected:=TRUE;
 		br_UiAnswer:=0;
 		st_UiHeader:=["Com, Calib Pos-Setup","Com, Kalibrierpositions-Setup","???"];    
 		st_UiMsgLine1:=["If the calibration position cannot be reached the with","Ist die Kalibrierposition nicht gleichzeitig mit allen ","???"];
 		st_UiMsgLine2:=["all axes at the same time, two positions can be used.","Achsen zu ereichen, koennen hier zwei Positionen gespeichert werden.","???"];
 		st_UiMsgLine4:=["The current setting is: ","Die aktuelle Einstellung ist: ","???"];
 		
        IF b_TwoSyncPos=FALSE THEN
 			st_UiMsgLine5:=["One position.","Eine Position","???"];
 		ELSE
 			st_UiMsgLine5:=["Two seperate positions.","Zwei Positionen","???"];
 		ENDIF
 		!
 		IF b_TwoSyncPos=FALSE THEN
 			st_UiMsgButtons1:=["","",""];
 		ELSE
 			st_UiMsgButtons1:=["Set positions","Positionen festlegen","???"]; 
 		ENDIF
        
 		st_UiMsgButtons3:=["One Position ","Eine  Position_ ","???"];
 		st_UiMsgButtons4:=["Two Positions","Zwei Positionen","???"];
 		st_UiMsgButtons5:=["Back","Zurueck","???"];
 		st_UiMsgButtons:=[st_UiMsgButtons1{n_Sp},"",st_UiMsgButtons3{n_Sp},st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
 		st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},"",st_UiMsgLine4{n_Sp}+st_UiMsgLine5{n_Sp},""]; 
 		!
 		br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconInfo);
 		TEST br_UiAnswer
 			CASE 1: ! Setup, Positionfestlegen
  			    ReRun2:
          
 				br_UiAnswer:=0;
 				st_UiHeader:=["Com, Calib Pos-Setup","Com, Kalibrierposition-Setup","???"];    
 				st_UiMsgLine1:=["Please move the robot to the two positions","Bitte nacheinander den Roboter auf ein der beiden","???"];
 				st_UiMsgLine2:=["When you are sure the robot is at the correct","Positionen stellen, die Oberflaeche starten und mit den","???"];
 				st_UiMsgLine3:=["position, teach the positions.","Tasten die Positionen speichern. ","???"];
 				st_UiMsgLine4:=["Pos 1: Axis 1 to zero degrees. Axis 2-6 & external any other position.","Pos 1: Achse 1 fest auf 0 Grad, 2-6 u. ext. Achsen sind frei programmierbar","???"];
 				st_UiMsgLine5:=["Pos 2: Axis 2-6 & external to zero degrees, Axis 1 any other position.","Pos 2: Achsen 2-6 u. ext. Achse fest auf 0 Grad, 1 ist frei programmierbar","???"];
 				!
 				st_UiMsgButtons2:=["Teach Pos1","Pos 1 speichern","???"];
 				st_UiMsgButtons3:=["Teach Pos2","Pos 2 speichern","???"];
 				st_UiMsgButtons4:=["   SyncPos Teach/Info","Info SyncPos","???"];
 				st_UiMsgButtons5:=["Back","Zurueck","???"];
 				st_UiMsgButtons:=["",st_UiMsgButtons2{n_Sp},st_UiMsgButtons3{n_Sp},st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
 				st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},st_UiMsgLine5{n_Sp}]; 
 				!
 				br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons	\Icon:=iconInfo);
 				IF br_UiAnswer=5 GOTO ReRun1;
 				IF br_UiAnswer=2 THEN
 					jpCalibPos1 := CJointT();
					jpCalibPos1.robax.rax_1 := 0;
 				ENDIF
                
 				IF br_UiAnswer=3 THEN
 					jpTemp := CJointT();
					jpCalibPos2:=jpCalibA1_A6;
					jpCalibPos2.robax.rax_1 := jpTemp.robax.rax_1;
 				ENDIF
                
				IF br_UiAnswer=4 THEN
					br_UiAnswer:=0;
 					st_UiHeader:=["Synchronisation Position Info","Info Synchron Position","???"];
 					st_UiMsgLine1:=["When using two separate positions for synchronisation, it is","Bei zwei Positionen fuer die Markierungstellung ist es","???"];
 					st_UiMsgLine2:=["recommended the second position is taught on the calibration marks.","sinnvoll die Synchronposition mit der 2. Position gleich zu setzen.","???"];
 					st_UiMsgLine3:=["If the robot is at Position 2, continue to save the position.","Steht der Roboter auf der 2.Pos? Mit Weiter die Sync-Position speichern","???"];
 					st_UiMsgButtons4:=["Next","Weiter","???"];
 					st_UiMsgButtons5:=["Back","Zurueck","???"];
 					st_UiMsgButtons:=["","","",st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
 					st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},"",""]; 
					 br_UiAnswer:= UIMessageBox (\Header:=st_UiHeader{n_Sp}
									\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconInfo);
 					IF br_UiAnswer = 4 THEN
						SyncPosSetup;
					ENDIF
				ENDIF
 				GOTO ReRun2;
 			CASE 3: ! Setup, direkt anfahren
 				b_TwoSyncPos:=FALSE;
 				GOTO ReRun1;
 			CASE 4: ! Setup, auf 2 mal 
 				b_TwoSyncPos:=TRUE;
 				GOTO ReRun3;
 			CASE 5: ! Setup, zurueck
 				GOTO ReRun1;
 			ENDTEST
	CASE 4: ! Anfahren
 		ReRun5:
		! Abfrage wegen Tool 0 / check because of tool zero
		IF CTool()=tool0 THEN
      		br_UiAnswer:=0;
      		st_UiHeader:=["Com, Tool check","Com, Tool Ueberpruefung","???"];    
      		st_UiMsgLine1:=["Attention the active tool is tool0","Achtung das aktive Tool ist - tool0 - !!! ","???"];
      		st_UiMsgLine2:=["The robot cannot move with tool0 because","Der Roboter kann vermutlicht wegen falschen  ","???"];
      		st_UiMsgLine3:=["it has the incorrect payload configured.","Gewichtsdaten nicht bewegt werden, ","???"];
      		st_UiMsgLine4:=["Using the Jogging Window, please select the correct","bitte waehle im Bewegenfenster das richtige Tool aus,","???"];
      		st_UiMsgLine5:=["tool then press the 'Ok' button to continue.","bevor es mit Ok weiter geht.","???"];
      		st_UiMsgButtons1:=["","","???"];
      		st_UiMsgButtons2:=["","","???"];
      		st_UiMsgButtons3:=["","","???"];
      		st_UiMsgButtons4:=["Ok","Ok","???"];
      		st_UiMsgButtons5:=["","","???"];
      		st_UiMsgButtons:=[st_UiMsgButtons1{n_Sp},st_UiMsgButtons2{n_Sp},st_UiMsgButtons3{n_Sp},st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
      		st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},st_UiMsgLine5{n_Sp}]; 
      		!
      		br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconWarning);
		ENDIF
 	
        IF n_ManSyncCMD=-2 THEN
               st_UiHeader:=["Com, ManSyncIntPos","Com, ManSyncIntPos","???"];    

            IF b_ManSyncInt_Found THEN
                st_UiMsgLine1:=["This Robot has the 'ManSyncIntPos' module installed","Dieser Roboeter hat das 'ManSyncIntPos' Modul installiert","???"];

                IF b_SetUpWasSelected<>TRUE THEN
                    st_UiMsgLine2:=["which may contain additional motion points which may move","welches zusaetzliche Punkte enthalten koennten, welche","???"];
                    st_UiMsgLine3:=["the robot from/to the calibration and Home1 poitions.","den Roboter von/zur Kalibrierungs und Home1 Position bewegen koennten","???"];
                    st_UiMsgLine4:=["","","???"];
                ELSE
                    st_UiMsgLine2:=["but, because the setup option was selected,","aber, da die Setup Option ausgewaehlt wurde,","???"];
                    st_UiMsgLine3:=["the positions within this module will not be executed.","werden die Positionen in diesem Modul nicht ausgefuehrt.","???"];
                    st_UiMsgLine4:=["","","???"];
                ENDIF
            ELSE
                st_UiMsgLine1:=["This Robot does not have the 'ManSyncIntPos' module installed.","Dieser Roboter hat das ManSyncIntPos Modul nicht installiert.","???"];
                st_UiMsgLine2:=["","","???"];
                st_UiMsgLine3:=["The robot will move directly to the","Der Roboter wird direkt zu den","???"];
                st_UiMsgLine4:=["predifined calibration positions.","vordefinierten Kalibrierungspositionen fahren","???"];

            ENDIF
            
            st_UiMsgLine5:=["Please exercise caution and watch for collisions.","Bitte vorsichtig sein und auf moegliche Kollisionen achten!","???"];

            st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},st_UiMsgLine5{n_Sp}]; 

            br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\Buttons:=btnOk\Icon:=iconwarning);  
            
            n_ManSyncCMD:=-1;
            
        ENDIF
        
 		t_Home := CTool();
 		t_home.robhold:=TRUE;
 		br_UiAnswer:=0;
 		st_UiHeader:=["Com, CalibPos","Com, Kalibrierposition","???"];    
 		st_UiMsgLine1:=["The robot is at the calibration position with all axes.","Der Roboter hat die Kalibrierposition mit","???"];
 		
        IF  b_TwoSyncPos=FALSE THEN
            IF n_ManSyncCMD=-1 AND b_ManSyncInt_Found AND b_SetUpWasSelected<>TRUE THEN
                n_ManSyncCMD:=1 ;
                %"ManSyncIntPos"%;
            ENDIF
            
  			MoveAbsJ jpCalibA1_A6,v200,fine,t_Home;
  			st_UiMsgLine2:=["Please check calibration marks line up.","allen Achsen erreicht, bitte alle Markierungen pruefen.","???"];
 		ELSE
 			IF 	jpCalibPos1.robax.rax_1 <> 0 OR jpCalibPos2.robax.rax_2 <> 0 OR jpCalibPos2.robax.rax_3 <> 0 OR jpCalibPos2.robax.rax_4 <> 0 OR jpCalibPos2.robax.rax_5 <> 0 OR jpCalibPos2.robax.rax_6 <> 0 THEN
				br_UiAnswer:=0;
 				st_UiHeader:=["Com, Calib Pos-Error","Com, Kalibrierposition Fehler","???"];    
 				st_UiMsgLine1:=["Attention incorrect calibration position stored as at ","Achtung fehlerhafte Kalibrierposition mindestens einer Achse.","???"];
 				st_UiMsgLine2:=["least one of the axis is not at zero degrees.","Diese ist nicht auf 0 Grad in den gespeicherten Positionen.","???"];
 				st_UiMsgLine3:=["Please check positions and modify if necessary.","Beide Positionen ueberpruefen, gegebenenfalls neu speicher.","???"];
 				st_UiMsgLine4:=["The current process will be aborted.","Das Pogramm wird abgebrochen.","???"];
 				!
 				st_UiMsgButtons5:=["Abort","Abbruch","???"];
 				st_UiMsgButtons:=["","","","",st_UiMsgButtons5{n_Sp}];
 				st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},""]; 
 				!
 				br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons \Icon:=iconError);
			ENDIF	
            
			IF br_UiAnswer=5 RETURN;
            
			! erste Pos von zwei
            IF n_ManSyncCMD=-1 AND b_ManSyncInt_Found AND b_SetUpWasSelected<>TRUE THEN
                n_ManSyncCMD:=2 ;
                %"ManSyncIntPos"%;
                n_ManSyncCMD:=2;
            ENDIF
            
			MoveAbsJ jpCalibPos1,v200,fine,t_Home;
            
  			st_UiMsgLine2:=["Axis 1 position reached. Please check Axis 1 calibration marks.","Achse 1 erreicht, bitte  Markierung 1 pruefen.","???"];
 			st_UiMsgButtons4:=["Next Pos 2","Weiter 2. Pos","???"];
			st_UiMsgButtons:=["","","",st_UiMsgButtons4{n_Sp},""];
			st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},"","",""]; 
 			!
 			br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons\Icon:=iconInfo);
			
            ! zweite POs  

             IF n_ManSyncCMD=2 AND b_ManSyncInt_Found AND b_SetUpWasSelected<>TRUE THEN
                n_ManSyncCMD:=3 ;
                %"ManSyncIntPos"%;
            ENDIF
            
            MoveAbsJ jpCalibPos2,v200,fine,t_Home;
            
   			st_UiMsgLine2:=["Axis 2-6 & Ext axis position reached. Please check Axis 2-6 & Ext markers.","Achse 2-6 u. d. Externen erreicht, bitte Markierung 2-6 u. ext. pruefen.","???"];
		ENDIF
        
		st_UiMsgLine5:=["Are all the markers lined up OK?","Sind alle Markierung in Ordnung?","???"];
		!
		st_UiMsgButtons3:=["Yes","Ja","???"];
		st_UiMsgButtons4:=["No","Nein","???"];
		st_UiMsgButtons5:=["Finished","Beenden","???"];
		st_UiMsgButtons:=["","",st_UiMsgButtons3{n_Sp},st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
		st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},"","",st_UiMsgLine5{n_Sp}]; 
		!
		br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons \Icon:=iconInfo);
		IF br_UiAnswer=5 RETURN;
		
        IF br_UiAnswer=4 THEN
 			br_UiAnswer:=0;
 			st_UiHeader:=["Com, CalibPos not OK","Com, Kalibrierposition n.i.O","???"];    
 			st_UiMsgLine1:=["The robot is not in the correct position!","Achtung der Roboter positioniert nicht richtig!","???"];
 			st_UiMsgLine2:=["Please reset the revolution counters","Der Umdrehungszaehler der betreffenden Achsen muss ","???"];
 			st_UiMsgLine3:=["for all the axis then check the markers again.","neu gesetzt werden.","???"];
 			st_UiMsgLine4:=["","Danach die Markierung noch mal anfahren.","???"];
			!
  			st_UiMsgButtons4:=["Move again","Nochmal Anfahren","???"];
 			st_UiMsgButtons5:=["Abort","Abbruch","???"];
 			st_UiMsgButtons:=["","","",st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
 			st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},""]; 
 			!
 			br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons 
								\Icon:=iconError);
		ENDIF
		
        IF br_UiAnswer=5 RETURN;
        
		IF br_UiAnswer=4 THEN
			ReRun6:
			IF  b_TwoSyncPos=TRUE THEN
		  		br_UiAnswer:=0;
 				st_UiHeader:=["Com, CalibPos","Com, Kalibrierposition","???"];    
 				st_UiMsgLine1:=["The Robot have two positions do you want to","Der Roboter hat 2 Positonen um die Makierungen","???"];
 				st_UiMsgLine2:=["move the robot to both or just position 2.","zu pruefen. Wollen Sie wieder beide anfahren oder nur die Zweite?","???"];
 				st_UiMsgLine3:=["","","???"];
 				st_UiMsgLine4:=["Please select.","Bitte waehlen","???"];
				!
                IF b_ManSyncInt_Found THEN
  				    st_UiMsgButtons1:=["","","???"];
                ELSE
  				    st_UiMsgButtons1:=["Both","Beide","???"];                   
                ENDIF
  				st_UiMsgButtons2:=["Position 2","2. Position","???"];
 				st_UiMsgButtons5:=["Abort","Abbruch","???"];
 				st_UiMsgButtons:=[st_UiMsgButtons1{n_Sp},st_UiMsgButtons2{n_Sp},"","",st_UiMsgButtons5{n_Sp}];
 				st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},""]; 
 				!
 				br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons 
								\Icon:=iconInfo);
				IF br_UiAnswer=1 GOTO rerun5;
		  		IF br_UiAnswer=2 THEN
                    
					! zweite Pos
					MoveAbsJ jpCalibPos2,v200,fine,t_Home;
					st_UiHeader:=["Com, Calibration Position","Com, Kalibrierposition","???"];    
					st_UiMsgLine1:=["The robot is at the calibration position with","Der Roboter hat die Kalibrierposition mit","???"];
   					st_UiMsgLine2:=["Axis 2-6 & External position reached. Please check Axis 2-6 & Ext markers.","Achse 2-6 u. d. Externen erreicht, bitte Markierung 2-6 u. ext. pruefen.","???"];
 					st_UiMsgLine3:=["Is the Robot at the correct position?","Ist der Roboter jetzt in Ordnung?","???"];		
					!
					st_UiMsgButtons3:=["Yes","Ja","???"];
					st_UiMsgButtons4:=["No","Nein","???"];
					st_UiMsgButtons5:=["Finished","Beenden","???"];
					st_UiMsgButtons:=["","",st_UiMsgButtons3{n_Sp},st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
					st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},"",""]; 
					!
					br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons \Icon:=iconInfo);
				ENDIF
		  		IF br_UiAnswer=4 GOTO ReRun6;
		  		IF br_UiAnswer=5 RETURN;
			ELSE
				GOTO rerun5;
			ENDIF
	    ENDIF	
 		
 		ReRun4:
 		br_UiAnswer:=0;
 		st_UiHeader:=["Com, Syncron Pos move","Com, Synch. Position fahren","???"];    
 		st_UiMsgLine1:=["The robot will move to the synchronisation position","Der Roboter faehrt auf die Synchronisationsposition","???"];
 		st_UiMsgLine2:=["and will begin the soft-synchronisation function.","und startet die Soft-Synchronisierung.","???"];
 		st_UiMsgLine4:=["IMPORTANT before performing function switch to safety User.","WICHTIG Benutzerwechsel durchfuehren.","???"];
 		st_UiMsgLine5:=["This function is only permisable to safety users!","Die Synchronisierung ist nur als Safety User moeglich!","???"];
 		!
 		st_UiMsgButtons4:=["Next","Weiter","???"];
 		st_UiMsgButtons5:=["Finished","Beenden","???"];
 		st_UiMsgButtons:=["","","",st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
 		st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},"",st_UiMsgLine4{n_Sp},st_UiMsgLine5{n_Sp}]; 
 		!
 		br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons \Icon:=iconInfo);
 		IF br_UiAnswer=5 RETURN;
 		! Synchron Pos anfahren
 		t_SMSync := CTool();
 		t_SMSync.robhold:=TRUE;
               
 		MoveAbsJ jpSM1SyncSwitch, v200, fine, t_SMSync;
        
 		! Aufruf der SM Software
 		%"SoftwareSync"%;
        
    	IF DOutput(SM1_do_Synced) =0 THEN
    		br_UiAnswer:=0;
    		st_UiHeader:=["Com, Error Syncron Pos","Com, Fehler Synch. Position","???"];    
    		st_UiMsgLine1:=["The synchronisation has failed","Die Synchronisation ist fehlgeschlagen","???"];
    		st_UiMsgLine2:=["therefore, automatic operation is not possible.","ein Automatikbetrieb ist nicht moeglich.","???"];
    		st_UiMsgLine4:=["Eliminate the cause of the error! Then repeat the process.","Die Fehlerursache beseitigen! Danach den Vorgang wiederholen.","???"];
    		st_UiMsgButtons4:=["Retry","Wiederholen","???"];
    		st_UiMsgButtons5:=["Abort","Abbruch","???"];
    		st_UiMsgButtons:=["","","",st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
    		st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},"",st_UiMsgLine4{n_Sp},""]; 
    		!
    		br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons \Icon:=iconError);
    		IF br_UiAnswer=4 GOTO ReRun4;
        ELSE
 			br_UiAnswer:=0;
 			st_UiHeader:=["Com, Robot Synchron","Com, Roboter Synchron ","???"];    
 			st_UiMsgLine1:=["The Robot is synchronised.","Der Roboter ist synchronisiert.","???"];
  			st_UiMsgButtons4:=["Check Brake","Bremsen testen","???"];
 			st_UiMsgButtons5:=["Finished","Beenden","???"];
			st_UiMsgButtons:=["","","",st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
			st_UiMsgLines:=[st_UiMsgLine1{n_Sp},"","","",""]; 
 			!
 			br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons \Icon:=iconInfo);
			!
			IF br_UiAnswer=4  THEN
				jpTempPos := CJointT();
                br_UiAnswer:=0;
                
				WHILE ABS(jpTempPos.extax.eax_a) <= 5 AND br_UiAnswer<>4 DO
				 	br_UiAnswer:=0;
 					st_UiHeader:=["Com, Brake Test","Com, Bremsentest","???"];    
 					st_UiMsgLine1:=["Warning! The Linear track axis 7 is near 0mm and may fail braketest.","Achtung, die Achse 7 ist nahe 0 mm der Bremsentest koennte fehlschlagen","???"];
                    
 					st_UiMsgLine3:=["Select 'Ignore' to start the Brake Test at current position.","Mit 'ignorieren' wird der Bremsentest in der aktuellen Position gestartet.","???"];
 					st_UiMsgLine4:=["Select 'Jog' then please move the axis >5 mm then 'Play' to start test.","Mit 'Jog' Bitte die Achse min. >5 mm. bewegen, mit 'Play' Test starten","???"];
                   
                    st_UiMsgButtons4:=["Ignore","ignorieren","???"];
  					st_UiMsgButtons5:=["Jog","Jog","???"];
                    
					st_UiMsgButtons:=["","","",st_UiMsgButtons4{n_Sp},st_UiMsgButtons5{n_Sp}];
					st_UiMsgLines:=[st_UiMsgLine1{n_Sp},"",st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},""]; 
 					
 					br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\BtnArray:=st_UiMsgButtons \Icon:=iconError);
                    
                    IF br_UiAnswer=5 THEN
                        ClearPath;
                        Stop;
                    ENDIF
                    
                    jpTempPos := CJointT();
                ENDWHILE
			
                CyclicBrakeCheck_V2;
                
			ENDIF
 		ENDIF
        
        IF n_ManSyncCMD=0 AND b_ManSyncInt_Found AND b_SetUpWasSelected<>TRUE THEN
                    
            st_UiHeader:=["Com, ManSyncIntPos","Com, ManSyncIntPos","???"];    
            st_UiMsgLine1:=["This Robot will move back to the Home Position 1.","Dieser Roboter wird zurueck zur Home Position 1 fahren.","???"];
            st_UiMsgLine2:=["","","???"];
            st_UiMsgLine3:=["","","???"];
            st_UiMsgLine4:=["","","???"];
            st_UiMsgLine5:=["","","???"];

            st_UiMsgLines:=[st_UiMsgLine1{n_Sp},st_UiMsgLine2{n_Sp},st_UiMsgLine3{n_Sp},st_UiMsgLine4{n_Sp},st_UiMsgLine5{n_Sp}]; 

            br_UiAnswer:=UIMessageBox (\Header:=st_UiHeader{n_Sp}\MsgArray:=st_UiMsgLines\Buttons:=btnOk\Icon:=iconwarning);  

     		n_ManSyncCMD:=4 ;
            %"ManSyncIntPos"%;
        ENDIF
 CASE 5: ! Abbruch
 	TPErase;
 	RETURN;
 ENDTEST 
 !
 TPErase;
  
 ERROR
!** Error Handler**

SkipWarn;
TEST ERRNO

CASE ERR_REFUNKPRC:
    IF n_ManSyncCMD=-2 THEN
        b_ManSyncInt_Found:=FALSE ;
        TRYNEXT;
    ENDIF

ENDTEST

ENDPROC ! ManSyncService ()

!*******************************************************************************

PROC PLC_Release (string Comment \VAR signaldo Set_ \VAR signaldi Wait_ \switch InPos\num Job)
 !****************************************
 !* Request operation handshake with PLC *
 !****************************************

 VAR errnum errno1;
 VAR signaldo PLC_JobStarted;
 VAR string st_alias;
 CONST string st_C:="PLC_do_Job";
 CONST string st_D:="_Started";

 IF Present(Job) CheckValue Job, 1, 32, 0, "Job Number";
 
 ! Abfrage fuer das Argument InPos
 IF Present (Inpos) WaitRob \InPos;
 
 ! Setzendes des Ausgangs
 
 IF Present (Set_) Set Set_;
 ! Warten auf die rueckmeldung von der SPS
 
 IF Present(Wait_) WaitDI Wait_,1\MaxTime:=3;
 !****************************
 !* Waiting PLC reease Input *
 !****************************
 
 IF Present(Job) THEN
	! Signalnamen erzeugen / signalname to procreate
	IF Job <10 THEN
		st_alias :=st_C+"0"+NumToStr(Job,0)+st_D;
	ELSE
		st_alias :=st_C+NumToStr(Job,0)+st_D;
	ENDIF
    
	AliasIO st_alias, PLC_JobStarted;
	
  	Set PLC_JobStarted;
 ENDIF

  ! Ruecksetzen des Ausgangs
 IF  Present (Set_) AND Present(Wait_) Reset Set_;

 ERROR
 !** Error Handler**
 SkipWarn;
 
 MsgBox_Clear;
 
 TEST ERRNO
 CASE ERR_WAIT_MAXTIME:
	st_UiHeader:=["PLC_Release, Waiting!!","PLC_Release, Warte auf ...","???"];
	st_UiMsgLine2:=["Waiting for "+ArgName(Wait_)+":= 1","Warte auf "+ArgName(Wait_)+":= 1","???"];
	
    IF Present(Set_) THEN
        st_UiMsgLine4:=["The Output '"+ArgName(Set_)+"' was set but, the robot","Der Ausgang "+ArgName(Set_)+" wurde gesetzt.","???"];
        st_UiMsgLine5:=["is waiting for the release signal '"+ArgName(Wait_)+"' from the PLC.","Der Roboter wartet auf die Freigabe von "+ArgName(Wait_)+" durch die SPS.","???"];
    ELSE
         st_UiMsgLine5:=["Robot is waiting for the release signal '"+ArgName(Wait_)+"' from the PLC.","Der Roboter wartet auf die Freigabe von "+ArgName(Wait_)+" durch die SPS.","???"];
    ENDIF
    
    UIMsgBox\Header:=st_UiHeader{n_Sp},Comment \MsgLine2:=st_UiMsgLine2{n_Sp}\MsgLine4:=st_UiMsgLine4{n_Sp}
					\MsgLine5:=st_UiMsgLine5{n_Sp}\Buttons:=btnNone\Icon:=iconInfo\DIBreak:=Wait_
					\BreakFlag:=errno1;
	TRYNEXT;

 ENDTEST
ENDPROC ! PLC_Release()

!*******************************************************************************

PROC MsgBox(\VAR signaldi diBreakSignal\VAR signaldo doBreakSignal\string Line1\string Line2\switch ErrorToPLC |switch StopToPLC)
 !*****************************************************************************************************
 !*                             Prozedur meldet Meldung/Fehler an die SPS und                         * 
 !*                      Zeigt Fehler auf dem TP und wartet auf eine Aktion vom Bediener              * 
 !*                                                                                                   *     
 !* optionale Parameter: \VAR signaldi diBreakSignal = Abbruchsignal zum abloeschen der Meldung am TP  *
 !*						\VAR signaldi doBreakSignal = Abbruchsignal zum abloeschen der Meldung am TP  *
 !*						\string Line1 = Es wird der uebergebene Text in Line1 angezeigt               *
 !*						\string Line2 = Es wird der uebergebene Text in Line2 angezeigt               *
 !*						\switch ErrorToPLC) = Es wird der Ausgang PLC_do_ErrorToPLC 1                *
 !*						|switch StopToPLC) = Es wird der Ausgang PLC_do_StopToPLC 1                  *
 !*                                                                                                   *     
 !*                          Message handler logs / errors to the PLC, and                            * 
 !*                  Displays error on TP and waits for an action by the operator                     * 
 !*****************************************************************************************************
 VAR errnum errno1;	
 CONST string st_MsgBoxLine1{3}:=["Waiting for: ","Warte auf: ","???"];
 CONST string st_MsgBoxLine2{3}:=["Error: ","Fehler: ","???"];
 VAR string st_MsgBoxLine_1;
 VAR string st_MsgBoxLine_2;
 VAR string st_MsgBox_buttons{5};
 VAR string st_MsgBoxLine1_5{5};
 VAR bool b_Timeflag:=FALSE;
 VAR icondata id_MsgIcon;
 VAR signaldo alias_do;
 VAR signaldi alias_di; 
 VAR bool b_IO_RequiredStateOK:=TRUE;
 VAR bool b_IO_Defined:=TRUE;
 VAR dionum dn_State_Required;
 
 n_MsgBoxAnswer:=0;
 IF Present(Line1) THEN
 	st_MsgBoxLine_1:=Line1;
 ELSE
 	IF st_MsgBoxSignalValue <> stEmpty THEN
 		st_MsgBoxLine_1:=st_MsgBoxLine1{n_Sp}+st_MsgBoxSignal+"= "+st_MsgBoxSignalValue;
 	ELSE
 		st_MsgBoxLine_1:=st_MsgBoxLine1{n_Sp}+st_MsgBoxSignal;
 	ENDIF
 ENDIF
 
 IF Present(Line2) THEN
 	st_MsgBoxLine_2:=Line2;
 ELSE
 	IF n_MsgBoxApplError > 0 THEN
 		st_MsgBoxLine_2:=st_MsgBoxLine2{n_Sp}+st_MsgBoxGeraeteName{n_Sp}+" "+NumToStr(n_MsgBoxGeraeteNr,0)
 		+" Error Code: "+NumToStr(n_MsgBoxApplError,0);
 	ELSE
 		st_MsgBoxLine_2:=st_MsgBoxLine2{n_Sp}+st_MsgBoxGeraeteName{n_Sp}+" "+NumToStr(n_MsgBoxGeraeteNr,0);
 	ENDIF
 ENDIF
 ErrWrite \W,	st_MsgBoxHeader{n_Sp},st_MsgBoxLine_1\
 RL2:=st_MsgBoxLine_2\
 RL3:=" "\
 RL4:=st_MsgBoxElogLine4+"/"+NumToStr(n_Step,0)+"/"+NumToStr(n_MsgBoxApplError,0)+"/"+NumToStr(n_MsgBoxPLC_Error,0);
 !
 ! Icon vorbesetzen / Text from Icon
 id_MsgIcon:=iconInfo;
 IF Present(ErrorToPLC) id_MsgIcon:=iconWarning; 
 IF Present(StopToPLC)  id_MsgIcon:=iconError;
 ! Wenn ErrorNr >0 oder kein Hinergrundtask dann setze Fehler zur SPS ab /
 ! If ErrorNr> 0, or no errors in ground task then dont send errors to the PLC
 IF n_MsgBoxPLC_Error  >0 AND TaskRunRob( )THEN
	!Fehlernummer zur SPS setzen / Error number send to the PLC
	SetGO PLC_go_ErrCode, n_MsgBoxPLC_Error;
	! setze Fehlerart\Send fault control bit
	IF Present(ErrorToPLC) THEN
		Set PLC_do_ErrorToPLC;		
	ELSEIF Present (StopToPLC)THEN
		Set PLC_do_StopToPLC;
	ELSE
		Set PLC_do_MsgToPLC;
	ENDIF
	!
 ENDIF
 !
 st_MsgBoxLine1_5:=[st_MsgBoxLine_1,st_MsgBoxLine_2,st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp},st_MsgBoxLine5{n_Sp}];
 st_MsgBox_buttons:=[st_MsgBoxbutton1{n_Sp},st_MsgBoxbutton2{n_Sp},st_MsgBoxbutton3{n_Sp},st_MsgBoxbutton4{n_Sp},st_MsgBoxbutton5{n_Sp}];
 !
 IF Present(diBreakSignal) AND Present(doBreakSignal) THEN
 	WaitUntil diBreakSignal=0 AND DOutput(doBreakSignal) = 0\MaxTime:=2\TimeFlag:=b_Timeflag;
 	n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=st_MsgBoxLine1_5\
 												BtnArray:=st_MsgBox_buttons\Icon:=id_MsgIcon\DIBreak:=diBreakSignal\
 												DOBreak:=doBreakSignal\BreakFlag:=errno1);
 ELSEIF Present(diBreakSignal) THEN
 	WaitDI diBreakSignal,0\MaxTime:=2\TimeFlag:=b_Timeflag;
 	n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=st_MsgBoxLine1_5\
 												BtnArray:=st_MsgBox_buttons\Icon:=id_MsgIcon\
 												DIBreak:=diBreakSignal\BreakFlag:=errno1);
 ELSEIF Present(doBreakSignal) THEN
 	WaitDO doBreakSignal,0\MaxTime:=2\TimeFlag:=b_Timeflag;
 	n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=st_MsgBoxLine1_5\
 												BtnArray:=st_MsgBox_buttons\Icon:=id_MsgIcon\
 												DOBreak:=doBreakSignal\BreakFlag:=errno1);
 ELSE
 	n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=st_MsgBoxLine1_5\
 												BtnArray:=st_MsgBox_buttons\Icon:=id_MsgIcon\BreakFlag:=errno1);
 ENDIF
 
 !Code to avoid error code being reset when signal message box is waiting is still in incorrect state  
 IF Present(ErrorToPLC) AND StrLen(st_MsgBoxSignal)>4 AND StrLen(st_MsgBoxSignalValue)=1 THEN
     
    IF StrMatch (st_MsgBoxSignal,1," ") = StrLen(st_MsgBoxSignal)+1 AND (st_MsgBoxSignalValue="0" OR st_MsgBoxSignalValue="1") THEN
        
        IF st_MsgBoxSignalValue="0" THEN
            dn_State_Required:=0;
        ELSE
            dn_State_Required:=1;            
        ENDIF
        
        IF StrMatch(st_MsgBoxSignal,1,"_di_") <> StrLen(st_MsgBoxSignal)+1 THEN
            AliasIO st_MsgBoxSignal, alias_di;
 
            IF b_IO_Defined THEN
                b_IO_RequiredStateOK:= (alias_di=dn_State_Required);
            ENDIF
            
        ELSEIF StrMatch(st_MsgBoxSignal,1,"_do_") <> StrLen(st_MsgBoxSignal)+1 THEN 
            AliasIO st_MsgBoxSignal, alias_do;
            
            IF b_IO_Defined THEN
                b_IO_RequiredStateOK:= (DOutput(alias_do)= dn_State_Required);
            ENDIF
         ENDIF
    ENDIF    
ENDIF
     

 IF n_MsgBoxPLC_Error >0 THEN
     IF b_IO_RequiredStateOK THEN
         SetGO PLC_go_ErrCode, 0;
         Reset PLC_do_ErrorToPLC;
         n_PLC_ErrCode_Mem:=-2;
     ELSE    
        n_PLC_ErrCode_Mem:=n_MsgBoxPLC_Error;
     ENDIF

 	Reset PLC_do_MsgToPLC;
 	Reset PLC_do_StopToPLC;
 ENDIF
 !
 MsgBox_Clear;
 TPShow TP_LATEST;
 
 ERROR
!** Error Handler **

TEST ERRNO

CASE ERR_ALIASIO_DEF,ERR_ALIASIO_TYPE:
    b_IO_Defined:=FALSE;
    TRYNEXT;
ENDTEST

ENDPROC !(MsgBox)

!*******************************************************************************

PROC MsgBox_Clear ()
!**********************************
!*    Messagebox clear routine    *
!**********************************

 !Reset st VAR	
 st_MsgBoxHeader:=["","",""];
 st_MsgBoxLine3:=["","",""];
 st_MsgBoxLine4:=["","",""];
 st_MsgBoxLine5:=["","",""];
 !Reset Tasten 1-5 
 st_MsgBoxbutton1:=["","",""];
 st_MsgBoxbutton2:=["","",""];
 st_MsgBoxbutton3:=["","",""];
 st_MsgBoxbutton4:=["","",""];
 st_MsgBoxbutton5:=["","",""];
 !Reset st
 st_MsgBoxGeraeteName:=["","",""];
 n_MsgBoxGeraeteNr:=0;
 st_MsgBoxSignal:="";
 n_MsgBoxApplError:=0;
 n_MsgBoxPLC_Error:=0;
 st_MsgBoxElogLine4:="";
ENDPROC !(MsgBox_Clear)

!*******************************************************************************

PROC MsgBoxEv(\VAR signaldi diBreakSignal\VAR signaldo doBreakSignal\string Line1\string Line2\switch ErrorToPLC |switch StopToPLC)
 !*****************************************************************************************************
 !*                             Prozedur meldet Meldung/Fehler von einer Eventrout. an die SPS und    * 
 !*                      Zeigt Fehler auf dem TP und wartet auf eine Aktion vom Bediener              * 
 !*                                                                                                   *     
 !* optionale Parameter: \VAR signaldi diBreakSignal = Abbruchsignal zum abloeschen der Meldung am TP  *
 !*						\VAR signaldi doBreakSignal = Abbruchsignal zum abloeschen der Meldung am TP  *
 !*						\string Line1 = Es wird der uebergebene Text in Line1 angezeigt               *
 !*						\string Line2 = Es wird der uebergebene Text in Line2 angezeigt               *
 !*						\switch ErrorToPLC) = Es wird der Ausgang PLC_do_ErrorToPLC 1                *
 !*						|switch StopToPLC) = Es wird der Ausgang PLC_do_StopToPLC 1                  *
 !*                                                                                                   *     
 !*                          Message handler logs / errors from Eventrout. to the PLC, and                            * 
 !*                  Displays error on TP and waits for an action by the operator                     * 
 !*****************************************************************************************************
 VAR errnum errno1;	
 CONST string st_MsgBoxEvLine1{3}:=["Waiting for: ","Warte auf: ","???"];
 CONST string st_MsgBoxEvLine2{3}:=["Error: ","Fehler: ","???"];
 VAR string st_MsgBoxEvLine_1;
 VAR string st_MsgBoxEvLine_2;
 VAR string st_MsgBoxEv_buttons{5};
 VAR string st_MsgBoxEvLine1_5{5};
 VAR bool b_Timeflag:=FALSE;
 VAR icondata id_MsgBoxEvIcon;
 VAR dionum dn_PLC_do_MsgToPLC:=0;
 VAR dionum dn_PLC_do_ErrorToPLC:=0;
 VAR dionum dn_PLC_do_StopToPLC:=0;
 !
 n_MsgBoxEvAnswer:=0;
 IF Present(Line1) THEN
 	st_MsgBoxEvLine_1:=Line1;
 ELSE
 	IF st_MsgBoxEvSignalValue <> stEmpty THEN
 		st_MsgBoxEvLine_1:=st_MsgBoxEvLine1{n_Sp}+st_MsgBoxEvSignal+"= "+st_MsgBoxEvSignalValue;
 	ELSE
 		st_MsgBoxEvLine_1:=st_MsgBoxEvLine1{n_Sp}+st_MsgBoxEvSignal;
 	ENDIF
 ENDIF
 IF Present(Line2) THEN
 	st_MsgBoxEvLine_2:=Line2;
 ELSE
 	IF n_MsgBoxEvApplError > 0 THEN
 		st_MsgBoxEvLine_2:=st_MsgBoxEvLine2{n_Sp}+st_MsgBoxEvGeraeteName{n_Sp}+" "+NumToStr(n_MsgBoxEvGeraeteNr,0)
 		+" Error Code: "+NumToStr(n_MsgBoxEvApplError,0);
 	ELSE
 		st_MsgBoxEvLine_2:=st_MsgBoxEvLine2{n_Sp}+st_MsgBoxEvGeraeteName{n_Sp}+" "+NumToStr(n_MsgBoxEvGeraeteNr,0);
 	ENDIF
 ENDIF
  ErrWrite \W,	st_MsgBoxEvHeader{n_Sp},st_MsgBoxEvLine_1\
  RL2:=st_MsgBoxEvLine_2\
  RL3:=" "\
  RL4:=st_MsgBoxEvElogLine4+"/"+NumToStr(n_Step,0)+"/"+NumToStr(n_MsgBoxEvApplError,0)+"/"
  +NumToStr(n_MsgBoxEvPLC_Error,0);
 !
 ! Icon vorbesetzen
  id_MsgBoxEvIcon:=iconInfo;
  IF Present(ErrorToPLC) id_MsgBoxEvIcon:=iconWarning; 
  IF Present(StopToPLC)  id_MsgBoxEvIcon:=iconError;
  ! Wenn ErrorNr >0 oder kein Hintergrundtask dann setze Fehler zur SPS ab 
 IF n_MsgBoxEvPLC_Error  >0 AND TaskRunRob( )THEN
  !
  IF DOutput(PLC_do_MsgToPLC) = 1 dn_PLC_do_MsgToPLC:=1;
  IF DOutput(PLC_do_ErrorToPLC) = 1 dn_PLC_do_ErrorToPLC:=1;
  IF DOutput(PLC_do_StopToPLC) = 1 dn_PLC_do_StopToPLC:=1;
  SetGO PLC_go_ErrCode, 0;
  Reset PLC_do_MsgToPLC;
  Reset PLC_do_ErrorToPLC;
  Reset PLC_do_StopToPLC;
  !
   !Fehlernummer zur SPS setzen  
   SetGO PLC_go_ErrCode, n_MsgBoxEvPLC_Error;
   ! setze Fehlerart
  IF Present(ErrorToPLC) THEN
   Set PLC_do_ErrorToPLC;		
  ELSEIF Present (StopToPLC)THEN
   Set PLC_do_StopToPLC;
  ELSE
   Set PLC_do_MsgToPLC;
  ENDIF
 !
 ENDIF
 !
 st_MsgBoxEvLine1_5:=[st_MsgBoxEvLine_1,st_MsgBoxEvLine_2,st_MsgBoxEvLine3{n_Sp},st_MsgBoxEvLine4{n_Sp},st_MsgBoxEvLine5{n_Sp}];
 st_MsgBoxEv_buttons:=[st_MsgBoxEvbutton1{n_Sp},st_MsgBoxEvbutton2{n_Sp},st_MsgBoxEvbutton3{n_Sp},st_MsgBoxEvbutton4{n_Sp},st_MsgBoxEvbutton5{n_Sp}];
 !
 IF Present(diBreakSignal) AND Present(doBreakSignal) THEN
 		WaitUntil diBreakSignal=0 AND DOutput(doBreakSignal) = 0\MaxTime:=2\TimeFlag:=b_Timeflag;
 		n_MsgBoxEvAnswer:= UIMessageBox (\Header:=st_MsgBoxEvHeader{n_Sp}\MsgArray:=st_MsgBoxEvLine1_5\
 													BtnArray:=st_MsgBoxEv_buttons\Icon:=id_MsgBoxEvIcon\
 													DIBreak:=diBreakSignal\	DOBreak:=doBreakSignal\
 	           										BreakFlag:=errno1);
 ELSEIF Present(diBreakSignal) THEN
 		WaitDI diBreakSignal,0\MaxTime:=2\TimeFlag:=b_Timeflag;
 		n_MsgBoxEvAnswer:= UIMessageBox (\Header:=st_MsgBoxEvHeader{n_Sp}\MsgArray:=st_MsgBoxEvLine1_5\
 													BtnArray:=st_MsgBoxEv_buttons\Icon:=id_MsgBoxEvIcon\
 													DIBreak:=diBreakSignal\BreakFlag:=errno1);
 ELSEIF Present(doBreakSignal) THEN
 		WaitDO doBreakSignal,0\MaxTime:=2\TimeFlag:=b_Timeflag;
 		n_MsgBoxEvAnswer:= UIMessageBox (\Header:=st_MsgBoxEvHeader{n_Sp}\MsgArray:=st_MsgBoxEvLine1_5\
 													BtnArray:=st_MsgBoxEv_buttons\Icon:=id_MsgBoxEvIcon\
 													DOBreak:=doBreakSignal\BreakFlag:=errno1);
 ELSE
 		n_MsgBoxEvAnswer:= UIMessageBox (\Header:=st_MsgBoxEvHeader{n_Sp}\MsgArray:=st_MsgBoxEvLine1_5\
 													BtnArray:=st_MsgBoxEv_buttons\Icon:=id_MsgBoxEvIcon\
 	           										BreakFlag:=errno1);
 ENDIF
 !
 IF n_MsgBoxEvPLC_Error >0 THEN
 	SetGO PLC_go_ErrCode, n_MsgBoxPLC_Error;
 	SetDO PLC_do_MsgToPLC, dn_PLC_do_MsgToPLC;
 	SetDO PLC_do_ErrorToPLC, dn_PLC_do_ErrorToPLC;
 	SetDO PLC_do_StopToPLC, dn_PLC_do_StopToPLC;
 ENDIF
 MsgBoxEv_Clear;
 TPShow TP_LATEST;
 !
ENDPROC !(MsgBoxEv)

!*******************************************************************************

PROC MsgBoxEv_Clear()
!**********************************
!* Messagebox event clear routine *
!**********************************

 !Reset st VAR	MsgBoxEv
 st_MsgBoxEvHeader:=["","",""];
 st_MsgBoxEvLine3:=["","",""];
 st_MsgBoxEvLine4:=["","",""];
 st_MsgBoxEvLine5:=["","",""];
 !Reset Tasten 1-5 
 st_MsgBoxEvbutton1:=["","",""];
 st_MsgBoxEvbutton2:=["","",""];
 st_MsgBoxEvbutton3:=["","",""];
 st_MsgBoxEvbutton4:=["","",""];
 st_MsgBoxEvbutton5:=["","",""];
 !Reset st
 st_MsgBoxEvGeraeteName:=["","",""];
 n_MsgBoxEvGeraeteNr:=0;
 st_MsgBoxEvSignal:="";
 n_MsgBoxEvApplError:=0;
 n_MsgBoxEvPLC_Error:=0;
 st_MsgBoxEvElogLine4:="";
ENDPROC ! (MsgBoxEv_Clear)

!*******************************************************************************


PROC MsgBoxBreak (string SignalName,dNum RequiredValue,\SWITCH InverseControl)
!*******************************************************************
!*  Procedure for the Msgbox function to allow the Break function  * 
!*      to operate for a signal that goes from High to Low.        *
!*           Software works in association with TB_COM             *
!*******************************************************************

VAR Bool b_Timeout;
VAR String st_Temp;

!Transfer to Persistent string
st_MsgboxBrk_SignalName:=SignalName;
dn_MsgboxBrk_ReqValue:=RequiredValue;
b_Invert_Control:=Present(InverseControl);

!Reset TB_Com Return String
st_MsgboxBrk_ReturnName:=" ";

WHILE st_MsgboxBrk_SignalName<>st_MsgboxBrk_ReturnName DO

      WaitUntil st_MsgboxBrk_SignalName=st_MsgboxBrk_ReturnName\MaxTime:=5 \TimeFlag:=b_Timeout;
      !**************************************
      !* Waiting for the TB_Com routine to  *
      !*  echo back the string sent to it.  *
      !**************************************
      
      IF b_Timeout THEN
            TPErase;
            st_MsgBoxHeader:=["MsgBoxIBreak Error" ,"MsgBoxIBreak Error","???"];
            
            IF st_MsgboxBrk_SignalName="SignalNameError" THEN
                  st_MsgBoxLine3:=["The Signal name programmed '" + SignalName + "' is invalid." ,"Der Signal namen programmiert '" + SignalName + "' ist ungltig.","???"];
                  st_MsgBoxLine5:=["Please Select 'OK' to Retry.","Bitte whlen Sie 'OK' zu wiederholen.","???"];
                  n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp},st_MsgBoxLine5{n_Sp}]\Buttons:=btnOK\Icon:=iconError);
                  Stop;
            ELSE
                  st_MsgBoxLine3:=["TB Com Communication Timeout." ,"TB Com Communication Timeout.","???"];
                  st_MsgBoxLine5:=["Please Select 'OK' to Retry.","Bitte whlen Sie 'OK' zu wiederholen.","???"];
                  n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp},st_MsgBoxLine5{n_Sp}]\Buttons:=btnOK\Icon:=iconError);
            ENDIF
            
      ENDIF
ENDWHILE

ENDPROC !(MsgBoxBreak)


!*******************************************************************************


PROC Log_Message (string Category, string Message,\Num TimeOut)
!************************************************
!*   Send message TXT data to log file system   * 
!************************************************
VAR bool b_timeout;
VAR num nTimeout:=0;

IF Present(TimeOut) THEN
    IF TimeOut<0 OR TimeOut>5 TimeOut:=0; 
    nTimeout:=TimeOut;
ENDIF

WaitUntil s_LOG_TX_Data=""\Maxtime:=nTimeOut\TimeFlag := b_timeout;
!*****************************************************
!* Waiting for message to be written to log database *
!*****************************************************

s_LOG_TX_Cat:=Category;
s_LOG_TX_Data:=Message;

ENDPROC !(Log_Message)


!*******************************************************************************


FUNC Num GetGroupIP (VAR Signaldi diSignalName,Num n_diBitLength)
!***************************************
!* Procedure to return a numeric value *
!*    from a group of Digital Inputs   *
!***************************************

VAR signaldi di_Temp;

VAR Num n_FirstBitNr;
VAR Num n_LastBitNr;
VAR Num n_diSignal_Length;
VAR Num n_CharNr;
VAR Num n_ScrollNr;
VAR Num n_ValueCount;
VAR Num n_CharFirstNumber;
VAR Num n_CharLastNumber;
VAR Num n_CharNumberCount;
VAR Num n_NumberCharlength;

VAR String st_diSignalName;
VAR String st_FirstbitNr;
VAR String st_diSignalDesc;
VAR String st_diSignalDesc1;
VAR String st_diSignalDesc2;
VAR String st_tempString ;

!Stop advance pointer
WaitTime\Inpos, 0.0 ;

!Check first bit configured is a valid input
st_diSignalName:=ArgName(diSignalName);
AliasIO st_diSignalName, di_Temp;

!Check input name length
n_diSignal_Length:=StrLen(st_diSignalName);

IF n_diSignal_Length > 3 THEN 
	!Determine which characters the Bit numbers start
	n_CharFirstNumber:=StrFind(st_diSignalName,1,STR_DIGIT) ;
	
	!Determine how many characters are numeric
	IF n_CharFirstNumber<n_diSignal_Length THEN
		n_CharLastNumber:=StrFind(st_diSignalName,n_CharFirstNumber+1,STR_DIGIT);
	ELSE
		n_CharLastNumber:=n_diSignal_Length;
	ENDIF
	
	n_NumberCharlength:=n_CharLastNumber-n_CharFirstNumber +1;
	
	!Check that there are numbers in signal description
	WHILE n_CharFirstNumber>n_diSignal_Length DO 
		TPErase;
		st_MsgBoxHeader:=["GetGIValue  Signal=" + st_diSignalName ,"GetGIValue  Signal=" + st_diSignalName,"???"];
		st_MsgBoxLine3:=["There are no bit numbers in the signal name defined." ,"Es gibt keine Bit-Zahlen in der Signal-Namen definiert","???"];
		st_MsgBoxLine4:=["Please check Configuration.","Bitte berprfe Konfiguration.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	n_CharNumberCount:=1;
	
	!Check how many characters are numbers
	FOR n_CharNr FROM n_CharFirstNumber +1 TO n_diSignal_Length DO
		IF StrFind(st_diSignalName,n_CharNr,STR_DIGIT)<=n_diSignal_Length THEN
			INCR n_CharNumberCount ;
		ENDIF
	ENDFOR
 
	!Check that there are no more than 3 numbers in the signal description
	WHILE n_CharNumberCount>2 DO 
		TPErase;
		st_MsgBoxHeader:=["GetGIValue  Signal=" + st_diSignalName ,"GetGIValue  Signal=" + st_diSignalName,"???"];
		st_MsgBoxLine3:=["There are more than two numbers in the" ,"Es gibt mehr als zwei Zahlen in der","???"];
		st_MsgBoxLine4:=["signal name defined. Check Configuration.","Signal-Name definiert. Konfiguration prfen.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	!Check that there are no less than numbers in signal description
	WHILE n_CharNumberCount<2 DO 
		TPErase;
		st_MsgBoxHeader:=["GetGIValue  Signal=" + st_diSignalName ,"GetGIValue  Signal=" + st_diSignalName,"???"];
		st_MsgBoxLine3:=["The are less than two numbers in the" ,"Das sind weniger als zwei Zahlen in der","???"];
		st_MsgBoxLine4:=["signal name defined. Check Configuration.","Signal-Name definiert. Konfiguration prfen.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	!Get Bit number as a string
	st_FirstbitNr:=StrPart(st_diSignalName,n_CharFirstNumber,n_NumberCharlength);

	!Check st_FirstbitNr is a number
	WHILE StrToVal(st_FirstbitNr,n_FirstBitNr)<>TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["GetGIValue  Signal=" + st_diSignalName ,"GetGIValue  Signal=" + st_diSignalName ,"???"];
		st_MsgBoxLine3:=["There are not two consecutive bit numbers defined." ,"Es gibt nicht zwei aufeinander folgenden Bit-Zahlen definiert.","???"];
		st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE
	
	st_diSignalDesc1:=StrPart(st_diSignalName,1,n_CharFirstNumber-1);

	IF (n_CharFirstNumber+1)=n_diSignal_Length OR n_CharFirstNumber=n_diSignal_Length THEN
		!Bit numbers are the last or last two characters
		st_diSignalDesc2:="" ;
		st_diSignalDesc:=st_diSignalDesc1 + "??" ;
	ELSE
		st_diSignalDesc2:=StrPart(st_diSignalName,n_CharFirstNumber+2,n_diSignal_Length-n_CharFirstNumber-1);
		st_diSignalDesc:=st_diSignalDesc1 + "??" + st_diSignalDesc2 ;
	ENDIF
	
	n_LastBitNr:=n_FirstBitNr+n_diBitLength-1;
	
	IF n_diBitLength<1 OR n_diBitLength>16 THEN
		!Check n_diBitLength paramater is valid

		WHILE TRUE DO 
			TPErase;
			st_MsgBoxHeader:=["GetGIValue Signal=" + st_diSignalDesc ,"GetGIValue Signal=" + st_diSignalDesc,"???"];
			st_MsgBoxLine3:=["The Bit length Specified=" + ValToStr(n_diBitLength) + ". Value must be between 1-16." ,"Die Bitlnge angegeben=" + ValToStr(n_diBitLength) + ". Wert muss zwischen 1-16.","???"];
			st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
			n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
			
			STOP;
		ENDWHILE

	ELSEIF n_LastBitNr>32 THEN
		!Check last bit number

		WHILE TRUE DO 
			TPErase;
			st_MsgBoxHeader:=["GetGIValue Signal="+ st_diSignalDesc ,"GetGIValue Signal="+ st_diSignalDesc,"???"];
			st_MsgBoxLine3:=["The first Bit specified=" + ValToStr(n_FirstBitNr) + " + length specified=" + ValToStr(n_diBitLength) + " is >32.","Die Erstes Bit angegeben=" + ValToStr(n_FirstBitNr) + " + Lnge angegeben=" + ValToStr(n_diBitLength) + " ist >32.","???"];
			st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
			n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
			
			STOP;
		ENDWHILE

	ELSE !n_diBitLength<1
		n_ScrollNr:=0.5;
		n_ValueCount:=0;
		
		FOR n_CharNr FROM n_FirstBitNr	TO n_LastBitNr DO
			n_ScrollNr:=n_ScrollNr*2;
			
			IF n_CharNr<10 AND n_CharFirstNumber<>n_diSignal_Length THEN
				st_tempString:=st_diSignalDesc1 +"0" + ValToStr(n_CharNr) + st_diSignalDesc2;
			ELSE
				st_tempString:=st_diSignalDesc1 + ValToStr(n_CharNr) + st_diSignalDesc2;
			ENDIF

			AliasIO st_tempString, di_Temp;
			
			IF di_Temp = 1 THEN
				n_ValueCount:=n_ValueCount + n_ScrollNr ;
			ENDIF
		
		ENDFOR
		
		n_LastGroupInput:=n_ValueCount;
		RETURN n_ValueCount ;
	ENDIF !n_diBitLength<1
ENDIF !n_diSignal_Length

ERROR
!** Error Handler **

TEST  ERRNO
CASE ERR_ALIASIO_DEF,ERR_ALIASIO_TYPE :
	WHILE TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["GetGIValue Signal=" + st_tempString ,"GetGIValue Signal=" + st_tempString,"???"];
		st_MsgBoxLine3:=["Signal is missing or incorrectly defined","IO Signal ist nicht vorhanden oder Falsch geschrieben","???"];
		st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE
DEFAULT :
	WHILE TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["GetGIValue Unknown Error =" + ValToStr(Errno) ,"GetGIValue unbekannter Fehler =" + ValToStr(Errno),"???"];
		st_MsgBoxLine3:=["Support Required.","Untersttzung erforderlich.","???"];
		st_MsgBoxLine4:=[" "," ","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE
ENDTEST

ENDFUNC !(GetGroupIP)


!*******************************************************************************


FUNC Num GetGroupIP_Bit (VAR Signaldi diSignalName,Num n_diBitLength\Switch ReturnBitOffset)
!***************************************
!* Procedure to return a numeric value *
!*    from a group of Digital Inputs   *
!* providing only one input is logic 1 *
!***************************************

VAR signaldi di_Temp;

VAR Num n_FirstBitNr;
VAR Num n_FirstBitNrMem:=0;
VAR Num n_LastBitNr;
VAR Num n_diSignal_Length;
VAR Num n_CharNr;
VAR Num n_ScrollNr;
VAR Num n_CharFirstNumber;
VAR Num n_CharLastNumber;
VAR Num n_CharNumberCount;
VAR Num n_NumberCharlength;

VAR String st_diSignalName;
VAR String st_FirstbitNr;
VAR String st_diSignalDesc;
VAR String st_diSignalDesc1;
VAR String st_diSignalDesc2;
VAR String st_tempString ;

!Stop advance pointer
WaitTime\Inpos, 0.0 ;

!Check first bit configured is a valid input
st_diSignalName:=ArgName(diSignalName);
AliasIO st_diSignalName, di_Temp;

!Check input name length
n_diSignal_Length:=StrLen(st_diSignalName);

IF n_diSignal_Length > 3 THEN 
	!Determine which characters the Bit numbers start
	n_CharFirstNumber:=StrFind(st_diSignalName,1,STR_DIGIT) ;
	
	!Determine how many characters are numeric
	IF n_CharFirstNumber<n_diSignal_Length THEN
		n_CharLastNumber:=StrFind(st_diSignalName,n_CharFirstNumber+1,STR_DIGIT);
	ELSE
		n_CharLastNumber:=n_diSignal_Length;
	ENDIF
	
	n_NumberCharlength:=n_CharLastNumber-n_CharFirstNumber +1;
	
	!Check that there are numbers in signal description
	WHILE n_CharFirstNumber>n_diSignal_Length DO 
		TPErase;
		st_MsgBoxHeader:=["GetGiBitValue  Signal=" + st_diSignalName ,"GetGiBitValue  Signal=" + st_diSignalName,"???"];
		st_MsgBoxLine3:=["There are no bit numbers in the signal name defined." ,"Es gibt keine Bit-Zahlen in der Signal-Namen definiert","???"];
		st_MsgBoxLine4:=["Please check Configuration.","Bitte berprfe Konfiguration.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	n_CharNumberCount:=1;
	
	!Check how many characters are numbers
	FOR n_CharNr FROM n_CharFirstNumber +1 TO n_diSignal_Length DO
		IF StrFind(st_diSignalName,n_CharNr,STR_DIGIT)<=n_diSignal_Length THEN
			INCR n_CharNumberCount ;
		ENDIF
	ENDFOR
 
	!Check that there are no more than 3 numbers in the signal description
	WHILE n_CharNumberCount>2 DO 
		TPErase;
		st_MsgBoxHeader:=["GetGiBitValue  Signal=" + st_diSignalName ,"GetGiBitValue  Signal=" + st_diSignalName,"???"];
		st_MsgBoxLine3:=["There are more than two numbers in the" ,"Es gibt mehr als zwei Zahlen in der","???"];
		st_MsgBoxLine4:=["signal name defined. Check Configuration.","Signal-Name definiert. Konfiguration prfen.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	!Check that there are no less than numbers in signal description
	WHILE n_CharNumberCount<2 DO 
		TPErase;
		st_MsgBoxHeader:=["GetGiBitValue  Signal=" + st_diSignalName ,"GetGiBitValue  Signal=" + st_diSignalName,"???"];
		st_MsgBoxLine3:=["The are less than two numbers in the" ,"Das sind weniger als zwei Zahlen in der","???"];
		st_MsgBoxLine4:=["signal name defined. Check Configuration.","Signal-Name definiert. Konfiguration prfen.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	!Get Bit number as a string
	st_FirstbitNr:=StrPart(st_diSignalName,n_CharFirstNumber,n_NumberCharlength);

	!Check st_FirstbitNr is a number
	WHILE StrToVal(st_FirstbitNr,n_FirstBitNr)<>TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["GetGiBitValue  Signal=" + st_diSignalName ,"GetGiBitValue  Signal=" + st_diSignalName ,"???"];
		st_MsgBoxLine3:=["There are not two consecutive bit numbers defined." ,"Es gibt nicht zwei aufeinander folgenden Bit-Zahlen definiert.","???"];
		st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE
	
	st_diSignalDesc1:=StrPart(st_diSignalName,1,n_CharFirstNumber-1);

	IF (n_CharFirstNumber+1)=n_diSignal_Length OR n_CharFirstNumber=n_diSignal_Length THEN
		!Bit numbers are the last or last two characters
		st_diSignalDesc2:="" ;
		st_diSignalDesc:=st_diSignalDesc1 + "??" ;
	ELSE
		st_diSignalDesc2:=StrPart(st_diSignalName,n_CharFirstNumber+2,n_diSignal_Length-n_CharFirstNumber-1);
		st_diSignalDesc:=st_diSignalDesc1 + "??" + st_diSignalDesc2 ;
	ENDIF
	
	n_LastBitNr:=n_FirstBitNr+n_diBitLength-1;
	
	IF n_diBitLength<1 OR n_diBitLength>16 THEN
		!Check n_diBitLength paramater is valid

		WHILE TRUE DO 
			TPErase;
			st_MsgBoxHeader:=["GetGiBitValue Signal=" + st_diSignalDesc ,"GetGiBitValue Signal=" + st_diSignalDesc,"???"];
			st_MsgBoxLine3:=["The Bit length Specified=" + ValToStr(n_diBitLength) + ". Value must be between 1-16." ,"Die Bitlnge angegeben=" + ValToStr(n_diBitLength) + ". Wert muss zwischen 1-16.","???"];
			st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
			n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
			
			STOP;
		ENDWHILE

	ELSEIF n_LastBitNr>32 THEN
		!Check last bit number

		WHILE TRUE DO 
			TPErase;
			st_MsgBoxHeader:=["GetGiBitValue Signal="+ st_diSignalDesc ,"GetGiBitValue Signal="+ st_diSignalDesc,"???"];
			st_MsgBoxLine3:=["The first Bit specified=" + ValToStr(n_FirstBitNr) + " + length specified=" + ValToStr(n_diBitLength) + " is >32.","Die Erstes Bit angegeben=" + ValToStr(n_FirstBitNr) + " + Lnge angegeben=" + ValToStr(n_diBitLength) + " ist >32.","???"];
			st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
			n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
			
			STOP;
		ENDWHILE

	ELSE !n_diBitLength<1
		n_ScrollNr:=0;
		
		FOR n_CharNr FROM n_FirstBitNr	TO n_LastBitNr DO
			INCR n_ScrollNr ;
			
			IF n_CharNr<10 AND n_CharFirstNumber<>n_diSignal_Length THEN
				st_tempString:=st_diSignalDesc1 +"0" + ValToStr(n_CharNr) + st_diSignalDesc2;
			ELSE
				st_tempString:=st_diSignalDesc1 + ValToStr(n_CharNr) + st_diSignalDesc2;
			ENDIF

			AliasIO st_tempString, di_Temp;
			
			IF di_Temp = 1 THEN
				IF n_FirstBitNrMem= 0 THEN
					IF Present(ReturnBitOffset) THEN
						n_FirstBitNrMem:=n_CharNr;
					ELSE
						n_FirstBitNrMem:=n_ScrollNr;
					ENDIF
				ELSE
					RETURN 0;
				ENDIF
			ENDIF
		
		ENDFOR
		
		RETURN n_FirstBitNrMem;
		
	ENDIF !n_diBitLength<1
ENDIF !n_diSignal_Length

RETURN 0;

ERROR
!** Error Handler **

TEST  ERRNO
CASE ERR_ALIASIO_DEF,ERR_ALIASIO_TYPE :
	WHILE TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["GetGiBitValue Signal=" + st_tempString ,"GetGiBitValue Signal=" + st_tempString,"???"];
		st_MsgBoxLine3:=["Signal is missing or incorrectly defined","IO Signal ist nicht vorhanden oder Falsch geschrieben","???"];
		st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE
DEFAULT :
	WHILE TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["GetGiBitValue Unknown Error =" + ValToStr(Errno) ,"GetGiBitValue unbekannter Fehler =" + ValToStr(Errno),"???"];
		st_MsgBoxLine3:=["Support Required.","Untersttzung erforderlich.","???"];
		st_MsgBoxLine4:=[" "," ","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE
ENDTEST

ENDFUNC !(GetGroupIP_Bit)


!*******************************************************************************


FUNC Num GetGroupOP (VAR Signaldo doSignalName,Num n_doBitLength)
!***************************************
!* Procedure to return a numeric value *
!*   from a group of Digital Outputs   *
!***************************************

VAR signaldo do_Temp;

VAR Num n_FirstBitNr;
VAR Num n_LastBitNr;
VAR Num n_doSignal_Length;
VAR Num n_CharNr;
VAR Num n_ScrollNr;
VAR Num n_ValueCount;
VAR Num n_CharFirstNumber;
VAR Num n_CharLastNumber;
VAR Num n_CharNumberCount;
VAR Num n_NumberCharlength;

VAR String st_doSignalName;
VAR String st_FirstbitNr;
VAR String st_doSignalDesc;
VAR String st_doSignalDesc1;
VAR String st_doSignalDesc2;
VAR String st_tempString ;

!Stop advance pointer
WaitTime\Inpos, 0.0 ;

!Check first bit configured is a valid output
st_doSignalName:=ArgName(doSignalName);
AliasIO st_doSignalName, do_Temp;

!Check output name length
n_doSignal_Length:=StrLen(st_doSignalName);

IF n_doSignal_Length > 3 THEN 
	!Determine which characters the Bit numbers start
	n_CharFirstNumber:=StrFind(st_doSignalName,1,STR_DIGIT) ;
	
	!Determine how many characters are numeric
	IF n_CharFirstNumber<n_doSignal_Length THEN
		n_CharLastNumber:=StrFind(st_doSignalName,n_CharFirstNumber+1,STR_DIGIT);
	ELSE
		n_CharLastNumber:=n_doSignal_Length;
	ENDIF
	
	n_NumberCharlength:=n_CharLastNumber-n_CharFirstNumber +1;

	!Check that there are numbers in signal description
	WHILE n_CharFirstNumber>n_doSignal_Length DO 
		TPErase;
		st_MsgBoxHeader:=["GetGOValue  Signal=" + st_doSignalName ,"GetGOValue  Signal=" + st_doSignalName,"???"];
		st_MsgBoxLine3:=["There are no bit numbers in the signal name defined." ,"Es gibt keine Bit-Zahlen in der Signal-Namen definiert","???"];
		st_MsgBoxLine4:=["Check Configuration","berprfe Konfiguration","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	n_CharNumberCount:=1;
	
	!Check how many characters are numbers
	FOR n_CharNr FROM n_CharFirstNumber +1 TO n_doSignal_Length DO
		IF StrFind(st_doSignalName,n_CharNr,STR_DIGIT)<=n_doSignal_Length THEN
			INCR n_CharNumberCount ;
		ENDIF
	ENDFOR
 
	!Check that there are no more than 3 numbers in the signal description
	WHILE n_CharNumberCount>2 DO 
		TPErase;
		st_MsgBoxHeader:=["GetGOValue  Signal=" + st_doSignalName ,"GetGOValue  Signal=" + st_doSignalName,"???"];
		st_MsgBoxLine3:=["There are more than two numbers in the" ,"Es gibt mehr als zwei Zahlen in der","???"];
		st_MsgBoxLine4:=["signal name defined. Check Configuration.","Signal-Name definiert. Konfiguration prfen.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	!Check that there are no less than numbers in signal description
	WHILE n_CharNumberCount<2 DO 
		TPErase;
		st_MsgBoxHeader:=["GetGOValue  Signal=" + st_doSignalName ,"GetGOValue  Signal=" + st_doSignalName,"???"];
		st_MsgBoxLine3:=["The are less than two numbers in the" ,"???","???"];
		st_MsgBoxLine4:=["signal name defined. Check Configuration.","Signal-Name definiert. Konfiguration prfen.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	!Get Bit number as a string
	st_FirstbitNr:=StrPart(st_doSignalName,n_CharFirstNumber,n_NumberCharlength);

	!Check st_FirstbitNr is a number
	WHILE StrToVal(st_FirstbitNr,n_FirstBitNr)<>TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["GetGOValue  Signal=" + st_doSignalName ,"GetGOValue  Signal=" + st_doSignalName,"???"];
		st_MsgBoxLine3:=["There are not two consecutive bit numbers defined." ,"Es gibt nicht zwei aufeinander folgenden Bit-Zahlen definiert.","???"];
		st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE
	
	st_doSignalDesc1:=StrPart(st_doSignalName,1,n_CharFirstNumber-1);
		
	IF (n_CharFirstNumber+1)=n_doSignal_Length OR n_CharFirstNumber=n_doSignal_Length THEN
		!Bit numbers are the last two characters
		st_doSignalDesc2:="" ;
		st_doSignalDesc:=st_doSignalDesc1 + "??" ;
	ELSE
		st_doSignalDesc2:=StrPart(st_doSignalName,n_CharFirstNumber+2,n_doSignal_Length-n_CharFirstNumber-1);
		st_doSignalDesc:=st_doSignalDesc1 + "??" + st_doSignalDesc2 ;
	ENDIF
	
	n_LastBitNr:=n_FirstBitNr+n_doBitLength-1;
	
	IF n_doBitLength<1 OR n_doBitLength>16 THEN
		!Check n_doBitLength paramater is valid

		WHILE TRUE DO 
			TPErase;
			st_MsgBoxHeader:=["GetGOValue  Signal=" + st_doSignalName ,"GetGOValue  Signal=" + st_doSignalName,"???"];
			st_MsgBoxLine3:=["The Bit length Specified=" + ValToStr(n_doBitLength) + ". Value must be between 1-16." ,"Die Bitlnge angegeben=" + ValToStr(n_doBitLength) + ". Wert muss zwischen 1-16.","???"];
			st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
			n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
			
			STOP;
		ENDWHILE

	ELSEIF n_LastBitNr>32 THEN
		!Check last bit number

		WHILE TRUE DO 
			TPErase;
			st_MsgBoxHeader:=["GetGOValue  Signal=" + st_doSignalName ,"GetGOValue  Signal=" + st_doSignalName,"???"];
			st_MsgBoxLine3:=["The first Bit specified=" + ValToStr(n_FirstBitNr) + " + length specified=" + ValToStr(n_doBitLength) + " is >32.","Die Erstes Bit angegeben=" + ValToStr(n_FirstBitNr) + " + Lnge angegeben=" + ValToStr(n_doBitLength) + " ist >32.","???"];
			st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
			n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
			
			STOP;
		ENDWHILE

	ELSE !n_doBitLength<1
		n_ScrollNr:=0.5;
		n_ValueCount:=0;
		
		FOR n_CharNr FROM n_FirstBitNr	TO n_LastBitNr DO
			n_ScrollNr:=n_ScrollNr*2;
			
			IF n_CharNr<10 AND n_CharFirstNumber<>n_doSignal_Length THEN
				st_tempString:=st_doSignalDesc1 +"0" + ValToStr(n_CharNr) + st_doSignalDesc2;
			ELSE
				st_tempString:=st_doSignalDesc1 + ValToStr(n_CharNr) + st_doSignalDesc2;
			ENDIF

			AliasIO st_tempString, do_Temp;
			
			IF doutput(do_Temp) = 1 THEN
				n_ValueCount:=n_ValueCount + n_ScrollNr ;
			ENDIF
		
		ENDFOR
		
		n_LastGroupOutput:=n_ValueCount;
		RETURN n_ValueCount ;
	ENDIF !n_doBitLength<1
ENDIF !n_diSignal_Length

ERROR
!** Error Handler **

TEST  ERRNO
CASE ERR_ALIASIO_DEF,ERR_ALIASIO_TYPE :
	WHILE TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["GetGOValue Signal=" + st_tempString ,"GetGOValue Signal=" + st_tempString,"???"];
		st_MsgBoxLine3:=["Signal is missing or incorrectly defined","IO Signal ist nicht vorhanden oder Falsch geschrieben","???"];
		st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE
DEFAULT :
	WHILE TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["GetGOValue Unknown Error =" + ValToStr(Errno) ,"GetGOValue unbekannter Fehler =" + ValToStr(Errno),"???"];
		st_MsgBoxLine3:=["Support Required.","Untersttzung erforderlich.","???"];
		st_MsgBoxLine4:=[" "," ","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE
ENDTEST

ENDFUNC !(GetGroupOP)


!*******************************************************************************


PROC SetGroupOP (VAR Signaldo doSignalName,Num n_doBitLength,Num n_doSetValue)
!************************************
!* Procedure set a group of Digital *
!* Outputs based on a numeric value *
!************************************

VAR signaldo do_Temp;

VAR Byte by_HighByte ;
VAR Byte by_LowByte ;
VAR Byte by_BitMask;

VAR Num n_FirstBitNr;
VAR Num n_LastBitNr;
VAR Num n_doSignal_Length;
VAR Num n_CharNr;
VAR Num n_ScrollNr;
VAR Num n_CharFirstNumber;
VAR Num n_CharNumberCount;
VAR Num n_MaxValue ;
VAR Num n_TempNr ;
VAR Num n_ChkValue ;
VAR Num n_TempDoValue ;

VAR String st_doSignalName;
VAR String st_FirstbitNr;
VAR String st_doSignalDesc;
VAR String st_doSignalDesc1;
VAR String st_doSignalDesc2;
VAR String st_tempString ;

!Stop advance pointer
WaitTime\Inpos, 0.0 ;

!Check first bit configured is a valid output
st_doSignalName:=ArgName(doSignalName);
AliasIO st_doSignalName, do_Temp;

!Check output name length
n_doSignal_Length:=StrLen(st_doSignalName);

IF n_doSignal_Length > 3 THEN 
	!Determine which characters the Bit numbers start
	n_CharFirstNumber:=StrFind(st_doSignalName,1,STR_DIGIT) ;
	
	!Check that there are numbers in signal description
	WHILE n_CharFirstNumber>n_doSignal_Length DO 
		TPErase;
		st_MsgBoxHeader:=["SetGOValue Signal=" + st_doSignalName ,"SetGOValue Signal=" + st_doSignalName,"???"];
		st_MsgBoxLine3:=["There are no bit numbers in the signal name defined." ,"Es gibt keine Bit-Zahlen in der Signal-Namen definiert","???"];
		st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	n_CharNumberCount:=1;
	
	!Check how many characters are numbers
	FOR n_CharNr FROM n_CharFirstNumber +1 TO n_doSignal_Length DO
		IF StrFind(st_doSignalName,n_CharNr,STR_DIGIT)<=n_doSignal_Length THEN
			INCR n_CharNumberCount ;
		ENDIF
	ENDFOR
 
	!Check that there are no more than 3 numbers in the signal description
	WHILE n_CharNumberCount>2 DO 
		TPErase;
		st_MsgBoxHeader:=["SetGOValue Signal=" + st_doSignalName ,"SetGOValue Signal=" + st_doSignalName,"???"];
		st_MsgBoxLine3:=["There are more than two numbers in the" ,"Es gibt mehr als zwei Zahlen in der","???"];
		st_MsgBoxLine4:=["signal name defined. Check Configuration.","Signal-Name definiert. Konfiguration prfen.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	!Check that there are no less than numbers in signal description
	WHILE n_CharNumberCount<2 DO 
		TPErase;
		st_MsgBoxHeader:=["SetGOValue Signal=" + st_doSignalName ,"SetGOValue Signal=" + st_doSignalName,"???"];
		st_MsgBoxLine3:=["The are less than two numbers in the" ,"???","???"];
		st_MsgBoxLine4:=["signal name defined. Check Configuration.","Signal-Name definiert. Konfiguration prfen.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

	!Get Bit number as a string
	st_FirstbitNr:=StrPart(st_doSignalName,n_CharFirstNumber,2);

	!Check st_FirstbitNr is a number
	WHILE StrToVal(st_FirstbitNr,n_FirstBitNr)<>TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["SetGOValue Signal=" + st_doSignalName ,"SetGOValue Signal=" + st_doSignalName,"???"];
		st_MsgBoxLine3:=["There are not two consecutive bit numbers defined." ,"Es gibt nicht zwei aufeinander folgenden Bit-Zahlen definiert.","???"];
		st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE
	
	st_doSignalDesc1:=StrPart(st_doSignalName,1,n_CharFirstNumber-1);
		
	IF (n_CharFirstNumber+1)=n_doSignal_Length THEN
		!Bit numbers are the last two characters
		st_doSignalDesc2:="" ;
		st_doSignalDesc:=st_doSignalDesc1 + "??" ;
	ELSE
		st_doSignalDesc2:=StrPart(st_doSignalName,n_CharFirstNumber+2,n_doSignal_Length-n_CharFirstNumber-1);
		st_doSignalDesc:=st_doSignalDesc1 + "??" + st_doSignalDesc2 ;
	ENDIF
	
	n_LastBitNr:=n_FirstBitNr+n_doBitLength-1;
	
	IF n_doBitLength<1 OR n_doBitLength>16 THEN
		!Check n_doBitLength paramater is valid

		WHILE TRUE DO 
			TPErase;
			st_MsgBoxHeader:=["SetGOValue Signal=" + st_doSignalName ,"SetGOValue Signal=" + st_doSignalName,"???"];
			st_MsgBoxLine3:=["The Bit length Specified=" + ValToStr(n_doBitLength) + ". Value must be between 1-16." ,"Die Bitlnge angegeben=" + ValToStr(n_doBitLength) + ". Wert muss zwischen 1-16.","???"];
			st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
			n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
			
			STOP;
		ENDWHILE

	ELSEIF n_LastBitNr>32 THEN
		!Check last bit number

		WHILE TRUE DO 
			TPErase;
			st_MsgBoxHeader:=["SetGOValue Signal=" + st_doSignalName ,"SetGOValue Signal=" + st_doSignalName,"???"];
			st_MsgBoxLine3:=["The first Bit specified=" + ValToStr(n_FirstBitNr) + " + length specified=" + ValToStr(n_doBitLength) + " is >32.","Die Erstes Bit angegeben=" + ValToStr(n_FirstBitNr) + " + Lnge angegeben=" + ValToStr(n_doBitLength) + " ist >32.","???"];
			st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
			n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
			
			STOP;
		ENDWHILE

	ELSE !n_doBitLength<1
	
		!Calculate maximum value allowed
		n_MaxValue:=0.5;
				
		FOR n_TempNr FROM n_FirstBitNr	TO n_LastBitNr +1 DO
			n_MaxValue:=n_MaxValue*2;
		ENDFOR
		
		Decr n_MaxValue ;
		
		!Check value number enterd is a permitted value
		WHILE n_doSetValue<0 OR n_doSetValue>n_MaxValue DO 
			TPErase;
			st_MsgBoxHeader:=["SetGOValue Signal=" + st_doSignalName ,"SetGOValue Signal=" + st_doSignalName,"???"];
			st_MsgBoxLine3:=["The Group Output value set=" + ValToStr(n_doSetValue) ,"Der Konzern Ausgangswert eingestellt=" + ValToStr(n_doSetValue),"???"];
			st_MsgBoxLine4:=["It must be a value between 0-" + ValToStr(n_MaxValue) +". Check Configuration.","Es muss ein Wert zwischen sein 0-" + ValToStr(n_MaxValue) +". berprfen Konfiguration.","???"];
			n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
			
			STOP;
		ENDWHILE

		!Set Low & High byte
		by_LowByte:=0 ;
		by_HighByte:=0 ;
		n_ChkValue:=32768 ;
		n_TempDoValue:=n_doSetValue ;
		
		FOR n_TempNr FROM 16 TO 1 STEP -1 DO
			IF n_TempDoValue>=n_ChkValue THEN
				n_TempDoValue:=n_TempDoValue-n_ChkValue ;
			
				IF n_TempNr>8 THEN
					!Set High Byte
					BitSet by_HighByte, n_TempNr-8;					
				ELSE
					!Set Low Byte
					BitSet by_LowByte, n_TempNr;					
				ENDIF
			ENDIF
			
			n_ChkValue:=n_ChkValue-(n_ChkValue/2) ;
		ENDFOR
		
		!Set Outputs control		
		n_ScrollNr:=0;
		
		FOR n_TempNr FROM n_FirstBitNr	TO n_LastBitNr DO
			Incr n_ScrollNr ;
			
			IF n_ScrollNr=1 OR n_ScrollNr=9 THEN
				by_BitMask:=1;
			ELSE
				by_BitMask:=by_BitMask*2 ;
			ENDIF
					
 			IF n_TempNr<10 THEN
				st_tempString:=st_doSignalDesc1 +"0" + ValToStr(n_TempNr) + st_doSignalDesc2;
			ELSE
				st_tempString:= st_doSignalDesc1 + ValToStr(n_TempNr) + st_doSignalDesc2;
			ENDIF

			AliasIO st_tempString, do_Temp;
			
			IF n_ScrollNr<9 THEN
				!Low Byte
				B_Setdo do_Temp,(BitAND(by_LowByte,by_BitMask)<>0) ;
			ELSE
				!High Byte
				B_Setdo do_Temp,(BitAND(by_HighByte,by_BitMask)<>0) ;			
			ENDIF
		ENDFOR
	ENDIF !n_doBitLength<1
ENDIF !n_doSignal_Length

ERROR
!** Error Handler **

TEST  ERRNO
CASE ERR_ALIASIO_DEF,ERR_ALIASIO_TYPE :
	WHILE TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["SetGOValue Signal=" + st_tempString ,"SetGOValue Signal=" + st_tempString,"???"];
		st_MsgBoxLine3:=["Signal is missing or incorrectly defined","IO Signal ist nicht vorhanden oder Falsch geschrieben","???"];
		st_MsgBoxLine4:=["Please Check Configuration.","Bitte berprfe Konfiguration.","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE

DEFAULT :
	
	WHILE TRUE DO 
		TPErase;
		st_MsgBoxHeader:=["SetGOValue Unknown Error =" + ValToStr(Errno) ,"SetGOValue unbekannter Fehler =" + ValToStr(Errno),"???"];
		st_MsgBoxLine3:=["Support Required.","Untersttzung erforderlich.","???"];
		st_MsgBoxLine4:=[" "," ","???"];
		n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError) ;
		
		STOP;
	ENDWHILE
ENDTEST

ENDPROC !(SetGroupOP)


!*******************************************************************************


PROC CheckManualTestMode ()
!**********************************
!* Procedure To check Mode switch *
!*  is switched to Manual (Slow)  *
!**********************************
VAR ErrNum en_DO_Break;
	
WHILE (OpMode()<>OP_MAN_PROG) DO
	TPErase;
	st_MsgBoxHeader:=["Check Mode Keyswitch" ,"Check Mode Keyswitch","???"];
	st_MsgBoxLine3:=["This progam may only be called","Das Progamm kann nur aufgerufen werden","???"];
	st_MsgBoxLine4:=["in Manual Prog (Slow) 'T1' mode.","im Manual Prog (Slow) 'T1'-Modus.","???"];
	n_MsgBoxAnswer:= UIMessageBox (\Header:=st_MsgBoxHeader{n_Sp}\MsgArray:=[" "," ",st_MsgBoxLine3{n_Sp},st_MsgBoxLine4{n_Sp}," "]\Buttons:=btnOK\Icon:=iconError\DoBreak:=SYS_do_Manual\BreakFlag:=en_DO_Break) ;
	
	STOP;
ENDWHILE

ENDPROC !(CheckManualTestMode)


!*******************************************************************************


PROC B_Setdo (VAR signaldo do_Output,BOOL State)
!******************************************
!* Procedure To work with Digital Outputs *
!* as if they were  declared as a Boolean *
!******************************************
	
IF State THEN
	SET do_Output;
ELSE
	RESET do_Output;
ENDIF

ENDPROC !(B_SetOut)


!*******************************************************************************


FUNC Num GetTypeCode ()
!*********************************
!* Function to return a numeric  *
!*   code from type bits 1-10    *
!*  providing only one bit is on *
!*********************************

VAR Signaldi di_Temp;
VAR String st_diSignalName;
VAR Num n_ReturnValue:=0;

FOR i FROM 1 TO 10 DO
	IF i<10 THEN
		st_diSignalName:="PLC_di_Typbit_0" + ValToStr(i);
	ELSE
		st_diSignalName:="PLC_di_Typbit_10";
	ENDIF
	
	AliasIO st_diSignalName, di_Temp;
	
	IF di_Temp = 1 THEN
		IF  n_ReturnValue=0 THEN
			n_ReturnValue:=i;
		ELSE
			n_ReturnValue:=0;
			GOTO ExitFor ;
		ENDIF
	ENDIF
	
ENDFOR

ExitFor:

RETURN n_ReturnValue;

ENDFUNC !(GetTypeCode)


!*******************************************************************************


PROC SetTypeCode (Num n_CodeValue)
!*********************************
!*   Procedure to set a model    *
!*   code with type bits 1-10    *
!*         to the PLC            *
!*********************************

VAR Signaldo do_Temp;
VAR String st_doSignalName;

CheckValue n_CodeValue, 1, 10, 0, "SetTypeCode";

FOR i FROM 1 TO 10 DO
	IF i<10 THEN
		st_doSignalName:="PLC_do_Typbit_0" + ValToStr(i);
	ELSE
		st_doSignalName:="PLC_do_Typbit_10";
	ENDIF
	
	AliasIO st_doSignalName, do_Temp;
	
	IF i=n_CodeValue AND n_CodeValue>0 AND n_CodeValue<=10 THEN
		SET do_Temp ;
	ELSE
		RESET do_Temp ;
	ENDIF
	
ENDFOR

ENDPROC !(SetTypeCode)
!***************************************************************************

PROC SetRobotTypeCode (\ Num GripperSystem,\ Bool PartOnGripper,\Switch InPos )
!******************************************************
!* Procedure to set a Robot Type code Bits to the PLC *
!*       depending upon gripper system selected       *
!******************************************************

VAR Signaldo do_Temp;
VAR String st_doSignalName;
VAR Num n_Offset;

! Only execute function if optional arguments are used and a valid gripper system number is entered
IF Present (GripperSystem) AND  Present (PartOnGripper) THEN

	CheckValue GripperSystem, 1, 4, 0, "SetRobotTypeCode";

	IF Present(InPos) THEN
		WaitTime \Inpos,0;
		!***********************************
		! Waiting for robot motion pointer *
		!***********************************
	ENDIF

	n_Offset:=(GripperSystem*2)-1;
	
	st_doSignalName:="PLC_do_Typbit_" + ValToStr(24+n_Offset);
	AliasIO st_doSignalName, do_Temp;
	
	B_Setdo do_Temp,PartOnGripper;
	
	st_doSignalName:="PLC_do_Typbit_" + ValToStr(25+n_Offset);
	AliasIO st_doSignalName, do_Temp;

	B_Setdo do_Temp,NOT PartOnGripper;

ENDIF

ENDPROC !(SetRobotTypeCode)

!***************************************************************************

PROC Indirect_WOBJ(tooldata Mess_Tool,INOUT wobjdata Wobj_New)
!***********************************
!*   Define Indirect Work Object   *
!***********************************
VAR num n_key;
VAR pose Punkt;
VAR pose u_pose;
VAR num n_ErrorCode;
VAR bool M_Errror;

!Update Phil Parsons 16-June-2012

Begin:
M_Errror:=FALSE;
n_ErrorCode:=0;

t_DefWobj_Act_tool:=Mess_Tool;

s_DefWobj_Tool_Name:=ArgName(Mess_Tool);
s_DefWobj_Wobj_Name:=ArgName(Wobj_New);

IF IsPers(Wobj_New)=FALSE THEN
	TPErase;
	TEST n_sp
	CASE 1:
		TPWrite "The workobject "+s_DefWobj_Wobj_Name; 
		TPWrite "is incorrectly declared.";
		TPWrite "----------------------------------------";
		TPWrite "It must be declared as a type 'PERS'.";
	CASE 2:
	    TPWrite "Das uebergebene Werkobjekt "+s_DefWobj_Wobj_Name;
		TPWrite "ist nicht vom Typ SPEICHERND ";
		TPWrite "----------------------------------------";
		TPWrite "Variable muss umdeklariert werden!";
	CASE 3:
	
	ENDTEST
	
	TPReadFK n_key,"","","","","","OK";	

	GOTO Exit_Ende;
ENDIF

TPErase;
TEST n_sp
CASE 1:
	TPWrite "Work object defined using  ";
	TPWrite "3 measurement points ";
	TPWrite "----------------------------------------";
	TPWrite "The Work Object name is "+s_DefWobj_Wobj_Name ;
	TPWrite "using measurement tool "+s_DefWobj_Tool_Name ;
	TPReadFK n_key,"","Abort","","","","OK";
CASE 2:
	TPWrite "Werkobjektdefinition mit Hilfe von  ";
    TPWrite "3 Punkten vermessen im Werkobjekt   ";
    TPWrite "----------------------------------------";
    TPWrite "Es wird das Werkobjekt "+s_DefWobj_Wobj_Name;
    TPWrite "mit Hilfe des Mess-Tool "+s_DefWobj_Tool_Name;
    TPWrite "bestimmt!";
    TPReadFK n_key,"","Abbruch","","","","OK";
CASE 3:

ENDTEST

IF n_key=1 GOTO Exit_Ende;

IF n_key<>5 GOTO Begin;

WHILE CTool()<>t_DefWobj_Act_tool DO
 	 TPErase;
	
	TEST n_sp
	CASE 1:
		TPWrite "               WARNING!!  ";
		TPWrite "----------------------------------------";
		TPWrite "The current Tool used to Jog ";
		TPWrite "is not the measurement tool "+s_DefWobj_Tool_Name;
 		TPReadFK n_key,"Please change the jogging tool !","Abort","","","","OK";
	CASE 2:
		TPWrite "               ACHTUNG !  ";
		TPWrite "----------------------------------------";
		TPWrite "Das im Bewegenfenster eingestellte ";
		TPWrite "TOOL ist nicht gleich dem angegebenen";
		TPWrite "Mess-TOOL "+s_DefWobj_Tool_Name;
		TPReadFK n_key,"Muss geaendet werden!","Abbruch","","","","OK";
	CASE 3:
	
	ENDTEST
  
  	IF n_key=1 GOTO Exit_Ende;
ENDWHILE

FOR I FROM 1 TO 3 DO
	Re_Start:
	TPErase;

	TEST n_sp
	CASE 1:
		TPWrite "What do you want to do with measurement point" + NumToStr(I,0)+ " ?";
		TPWrite " ";
		TPWrite " - Teach new.";
		TPWrite " - Change exiting data.";
		TPWrite " - Move the robot to the point.";
		TPWrite "";
		TPReadFK n_key,"Please select option.","Teach New","","Change","","Goto Point";
	CASE 2:
		TPWrite "Wollen Sie Mess-Punkt" + NumToStr(I,0)+ " ?";
		TPWrite " ";
		TPWrite " - neu teachen";
		TPWrite " - gespeicherten Mess-Punkt uebernehmen";
		TPWrite " - gespeicherten Punkt anfahren und ggf.";
		TPWrite "   korrigieren";
		TPWrite "";
		TPReadFK n_key,"Bitte whlen Sie Option.","teachen","","uebernahme","","anfahren";
	CASE 3:
	
	ENDTEST
	
	TEST n_key
	CASE 1:
		GOTO Teach;
	CASE 3:
		GOTO Posexyz;
	CASE 5:
		GOTO ToPoint;
	DEFAULT:
		GOTO Re_Start;
	ENDTEST
	
	ToPoint:
	WHILE OpMode()<>2 DO
		TPErase;

		TEST n_sp
		CASE 1:
			TPWrite "              WARNING!                  ";
			TPWrite "----------------------------------------";
			TPWrite "This program may only be run in Manual ";
			TPWrite "program 'T1' mode.";
			TPReadFK n_key,"Please Turn the Key switch to manual!","Abort","","","","OK";
		CASE 2:
			TPWrite "              ACHTUNG!                  ";
			TPWrite "----------------------------------------";
			TPWrite "Bewegungsart ist nicht auf Hand-Betrieb!";
			TPWrite "Anfahren des Mess-Punktes ist nur in";
			TPWrite "dieser Betriebs-Art mglich!";
			TPReadFK n_key,"Stellen Sie auf Betriebs-Art Hand um!","Abbruch","","","","OK";
		CASE 3:
		
		ENDTEST

		IF n_key=1 GOTO Exit_Ende;   
	ENDWHILE
	
	TPErase;

	TEST n_sp
	CASE 1:
	
		TPWrite "      WARNING!  RICK OF COLLISION !     ";
		TPWrite "----------------------------------------";
		TPWrite "The Robot will move directly to the ";
		TPWrite "previously stored measurement point "\Num:=I;
		TPReadFK n_key,"","Return","","","Move Fast","Move Slow";
	CASE 2:
		TPWrite "     ACHTUNG!     KOLLISIONSGEFAHR!     ";
		TPWrite "----------------------------------------";
		TPWrite "Roboter bewegt sich auf direktem Wege";
		TPWrite "zum gespeichertem Mess-Punkt "\Num:=I;
		TPReadFK n_key,"","Zurueck","","","schnell","langsam";
	CASE 3:
	
	ENDTEST

	TPErase;
	
	TEST n_key
	CASE 1:
		GOTO Re_Start;
	CASE 4:
		n_ErrorCode:=1;
		MoveJ rt_DefWobj_user_p{I},vmax,fine,t_DefWobj_Act_tool;
		n_ErrorCode:=0;
	CASE 5:
		n_ErrorCode:=1;
		MoveJ rt_DefWobj_user_p{I},v50,fine,t_DefWobj_Act_tool;
		n_ErrorCode:=0;
	DEFAULT:
		GOTO Re_Start;
	ENDTEST
	
	Teach:
	TPErase;

	TEST n_sp
	CASE 1:
		TPWrite "Jog the robot to the measurement ";
		TPWrite "point with the tool "+s_DefWobj_Tool_Name+".";
		TPWrite "The current Measurement Point is "\Num:=I;
		TPReadFK n_key,"Has the point been Reached?","Return","","","","Yes";
	CASE 2:
		TPWrite "Bewegen Sie den Roboter mit dem ";
		TPWrite "Mess-Werkzeug "+s_DefWobj_Tool_Name+" zum";
		TPWrite "vermessenen Punkt "\Num:=I;
		TPReadFK n_key,"Ist der Punkt erreicht?","Zurueck","","","","Ja";	
	CASE 3:
	
	ENDTEST
	
	IF n_key=1 GOTO Re_Start;
	IF n_key<>5 GOTO teach;
	
	rt_DefWobj_user_p{I}:=CRobT(\Tool:=t_DefWobj_Act_tool\WObj:=wobj0);
	
	Posexyz:
	TPErase;

	TEST n_sp
	CASE 1:
		TPWrite "The Co-Ordinates for measurement point "\Num:=I;
		TPWrite "for this Work Object are:";
		TPWrite " ";
		TPWrite "   X=: "\Num:=rt_DefWobj_mess_p{I}.trans.x;
		TPWrite "   Y=: "\Num:=rt_DefWobj_mess_p{I}.trans.y;
		TPWrite "   Z=: "\Num:=rt_DefWobj_mess_p{I}.trans.z;
		TPWrite " ";
		TPReadFK n_key,"Are The Co-Ordinates correct?","No","","","","Yes";
	CASE 2:
		TPWrite "Die Koordinaten fuer Mess-Punkt "\Num:=I;
		TPWrite "im Bezug zum Werkobjekt sind:";
		TPWrite " ";
		TPWrite "   X-Wert: "\Num:=rt_DefWobj_mess_p{I}.trans.x;
		TPWrite "   Y-Wert: "\Num:=rt_DefWobj_mess_p{I}.trans.y;
		TPWrite "   Z-Wert: "\Num:=rt_DefWobj_mess_p{I}.trans.z;
		TPWrite " ";
		TPReadFK n_key,"Sind die Koordinaten richtig?","Nein","","","","Ja";
	CASE 3:
	
	ENDTEST

	IF n_key=5 GOTO Pose_ok;
	New_Pos:
	n_DefWobj_px:=0;
	n_DefWobj_py:=0;
	n_DefWobj_pz:=0;
	TPErase;
	
	TEST n_sp
	CASE 1:
		TPWrite "Manually enter ";
		TPWrite "the Co-Ordinates ";
		TPWrite "for the Work Object!";
		TPWrite "for point "\Num:=I;
		TPReadNum n_DefWobj_px,"X-Value:";
		TPErase;
		TPWrite "Manually enter ";
		TPWrite "the Co-Ordinates ";
		TPWrite "for the Work Object!";
		TPWrite "for point "\Num:=I;
		TPReadNum n_DefWobj_py,"Y-Value:";
		TPErase;
		TPWrite "Manually enter ";
		TPWrite "the Co-Ordinates ";
		TPWrite "for the Work Object!";
		TPWrite "for point "\Num:=I;
		TPReadNum n_DefWobj_pz,"Z-Value:";
	CASE 2:
		TPWrite "Geben Sie per Hand die ";
		TPWrite "Koordinaten des Punktes ";
		TPWrite "zum Werkobjekt ein!";
		TPWrite "Punkt "\Num:=I;
		TPReadNum n_DefWobj_px,"X-Wert:";
		TPErase;
		TPWrite "Geben Sie per Hand die ";
		TPWrite "Koordinaten des Punktes ";
		TPWrite "zum Werkobjekt ein!";
		TPWrite "Punkt "\Num:=I;
		TPReadNum n_DefWobj_py,"Y-Wert:";
		TPErase;
		TPWrite "Geben Sie per Hand die ";
		TPWrite "Koordinaten des Punktes ";
		TPWrite "zum Werkobjekt ein!";
		TPWrite "Punkt "\Num:=I;
 		TPReadNum n_DefWobj_pz,"Z-Wert:";
	CASE 3:
	
	ENDTEST
	
	Pose_frag:
	TPErase;

	TEST n_sp
	CASE 1:	
		TPWrite "The value entered for measurement point "\Num:=I;
		TPWrite "are for the Work Object:";
		TPWrite " ";
		TPWrite "   X-Value: "\Num:=n_DefWobj_px;
		TPWrite "   Y-Value: "\Num:=n_DefWobj_py;
		TPWrite "   Z-Value: "\Num:=n_DefWobj_pz;
		TPWrite " ";
		TPReadFK n_key,"Are the Co-Ordinates correct?","No","","Abort","","Yes";
	CASE 2:
		TPWrite "Die eingegebenen Werte fuer Mess-Punkt "\Num:=I;
		TPWrite "im Bezug zum Werkobjekt sind:";
		TPWrite " ";
		TPWrite "   X-Wert: "\Num:=n_DefWobj_px;
		TPWrite "   Y-Wert: "\Num:=n_DefWobj_py;
		TPWrite "   Z-Wert: "\Num:=n_DefWobj_pz;
		TPWrite " ";
		TPReadFK n_key,"Sind die Koordinaten richtig?","Nein","","","","Ja";
	CASE 3:
	
	ENDTEST
	
	IF n_key=3 GOTO Exit_Ende;
	IF n_key=1 GOTO New_Pos;
	IF n_key<>5 GOTO Pose_frag;
	
	rt_DefWobj_mess_p{I}.trans.x:=n_DefWobj_px;
	rt_DefWobj_mess_p{I}.trans.y:=n_DefWobj_py;
	rt_DefWobj_mess_p{I}.trans.z:=n_DefWobj_pz;
	rt_DefWobj_mess_p{I}.rot:=[1,0,0,0];
	Pose_ok:
ENDFOR

TPErase;
n_ErrorCode:=2;
wobj_DefWobj_car0.oframe:=[[0,0,0],[1,0,0,0]];
wobj_DefWobj_car0.uframe:=DefDFrame(rt_DefWobj_mess_p{1},rt_DefWobj_mess_p{2},rt_DefWobj_mess_p{3},rt_DefWobj_user_p{1},rt_DefWobj_user_p{2},rt_DefWobj_user_p{3});
IF M_Errror=TRUE GOTO Ende;
n_ErrorCode:=0;

FOR I FROM 1 TO 3 DO
	Punkt.trans:=rt_DefWobj_mess_p{I}.trans;
	Punkt.rot:=rt_DefWobj_mess_p{I}.rot;
	u_pose:=PoseMult(wobj_DefWobj_car0.uframe,Punkt);
	n_DefWobj_Diff_X{I}:=u_pose.trans.x-rt_DefWobj_user_p{I}.trans.x;
	n_DefWobj_Diff_Y{I}:=u_pose.trans.y-rt_DefWobj_user_p{I}.trans.y;
	n_DefWobj_Diff_Z{I}:=u_pose.trans.z-rt_DefWobj_user_p{I}.trans.z;
	n_DefWob_jDiff_Ges{I}:=Sqrt(n_DefWobj_Diff_X{I}*n_DefWobj_Diff_X{I}+n_DefWobj_Diff_Y{I}*n_DefWobj_Diff_Y{I}+n_DefWobj_Diff_Z{I}*n_DefWobj_Diff_Z{I});
ENDFOR

Message:
TPErase;

TEST n_sp
CASE 1:
	TPWrite "Calculated Work Object Error(in mm) ";
	TPWrite " ";
	TPWrite "In Mess-Point 1: "\Num:=n_DefWob_jDiff_Ges{1};
	TPWrite "In Mess-Point 2: "\Num:=n_DefWob_jDiff_Ges{2};
	TPWrite "In Mess-Point 3: "\Num:=n_DefWob_jDiff_Ges{3};	
	TPWrite " ";
	TPReadFK n_key,"Accept the error deviation?","No","","Info","","Yes";
CASE 2:
	TPWrite "Fehler in mm mit ermitteltem Werkobjekt";
	TPWrite " ";
	TPWrite "am Mess-Punkt 1: "\Num:=n_DefWob_jDiff_Ges{1};
	TPWrite "am Mess-Punkt 2: "\Num:=n_DefWob_jDiff_Ges{2};
	TPWrite "am Mess-Punkt 3: "\Num:=n_DefWob_jDiff_Ges{3};
	TPWrite " ";
	TPReadFK n_key,"Wird Abweichung akzeptiert?","Nein","","Info","","Ja";
CASE 3:

ENDTEST

TEST n_key
CASE 1:
	Wobj_New:=wobj_DefWobj_ACT_wobj;
	GOTO EXIT_Ende;
CASE 3:
	TPErase;

	TEST n_sp
	CASE 1:
		TPWrite "Error!! check the following:";
		TPWrite "- Incorrect/Inaccurate Measurement-Tool";
		TPWrite "- False/Inaccurate Co-ordinates ";
		TPWrite "- Incorrectly calibrated Robot";		
		TPReadFK n_key,"Error > 5 mm not accepted!","","","","","OK";
	CASE 2:
	     TPWrite "Grosse Fehler knnen entsehen durch:";
		TPWrite "- Falsches/ungenaues Mess-Tool";
		TPWrite "- Falsche/ungenaue Koordinaten ";
		TPWrite "- unsauber geteachte Mess-Punkte";
		TPWrite "- falsch kalibrierter Roboter";
		TPReadFK n_key,"Fehler > 5 mm nicht akzeptierten!","","","","","OK";
	CASE 3:
	
	ENDTEST
	
	GOTO Message;
CASE 5:
	Wobj_New:=wobj_DefWobj_car0;
	TPErase;

	TEST n_sp
	CASE 1:
		TPWrite "The Work Object "+s_DefWobj_Wobj_Name+" was";
		TPWrite "configured correctly and ";
		TPWrite "has been stored!";
	CASE 2:
		TPWrite "Das Werkobjekt "+s_DefWobj_Wobj_Name+" wurde mit";
		TPWrite "angegebener Genauigkeit ermittelt";
		TPWrite "und gespeichert!";
	CASE 3:
	
	ENDTEST

	TPReadFK n_key,"","","","","","OK";
		
DEFAULT:
  GOTO Message;
ENDTEST

Ende:
TPErase;
EXIT;
Exit_Ende:
TPErase;
TPWrite " ";
TPWrite " ";

TEST n_sp
CASE 1:
	TPWrite "     Measurement was aborted!      ";
CASE 2:
    TPWrite "     Vermessung wurde abgebrochen!      ";
CASE 3:

ENDTEST

WaitTime 3;

ERROR
!** Error Handler **
TEST n_ErrorCode
CASE 1:
	TPErase;
	
	TEST n_sp
	CASE 1:	
		TPWrite "Stored position";
		TPWrite "is not correct!";
	CASE 2:
		TPWrite "Gespeicherte Position kann";
		TPWrite "nicht angefahren werden!";
	CASE 3:
	
	ENDTEST

  	TPReadFK n_key,"","","","","","OK";
  	TRYNEXT;
CASE 2:
	M_Errror:=TRUE;

	TPErase;
	
	TEST n_sp
	CASE 1:
		TPWrite "The Work Object";
		TPWrite "cannot defined with the ";
		TPWrite "data entered!";
	CASE 2:
		TPWrite "Werkobjekt kann mit den";
		TPWrite "angegebenen Daten nicht";
		TPWrite "ermittelt werden!";
	CASE 3:
	
	ENDTEST

  	TPReadFK n_key,"","","","","","OK";
  	TRYNEXT;
DEFAULT:
  EXIT;
ENDTEST

ENDPROC !(Indirect_WOBJ)

!***************************************************************************

PROC SetHomeColl (\Num Home_Nr, \Num Collision_Nr,\String Collision_Desc)
!*************************************
!* User Routine to set collison zone *
!*        from Initproduction        *
!" When robot is in a Home position  *
!*************************************
!Home_nr            = Home position which collision zone to be requested
!Collision_Nr       = Collision zone to be requested
!Collision_Desc     = Description of other robot/s also using this collision zone

VAR string st_alias;
VAR signaldo do_TempHome;
VAR robtarget rt_CurrentPos;

CheckValue Home_Nr,1,5,0,"Home Number";
CheckValue Collision_Nr,1,62,0,"Collizone Number";

!Create signal to check home output
st_alias :="SYS_do_Home_" +NumToStr(Home_Nr,0);
AliasIO st_alias, do_TempHome;

!check if robot is in Home position and collsion zone not already occupied
IF DOutput (do_TempHome)=1 AND b_CollZoneOccupied{Collision_Nr}=FALSE THEN
	t_Home := CTool();
	wobj_home := CWobj();
	rt_CurrentPos:=CRobT(\Tool:=t_Home\WObj:=wobj_home);
	MoveJ_CollReq Collision_Nr,  rt_CurrentPos,  V10,  fine,  t_Home \ Wobj:=wobj_home\Coll_Desc:=Collision_Desc;
ENDIF

ENDPROC !(SetHomeColl)

ENDMODULE
